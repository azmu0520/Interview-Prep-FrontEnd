# Variables & Hoisting

## üéØ Key Concepts

### 1. var, let, const - The Complete Picture (CRITICAL!)

**What it means:**

- JavaScript has 3 ways to declare variables, each with different behavior
- Understanding scope and hoisting differences is ESSENTIAL for interviews
- Modern code uses let/const exclusively

**The Three Keywords:**

| Feature            | var             | let       | const     |
| ------------------ | --------------- | --------- | --------- |
| Scope              | Function        | Block     | Block     |
| Hoisting           | Yes (undefined) | Yes (TDZ) | Yes (TDZ) |
| Reassignment       | ‚úÖ Yes          | ‚úÖ Yes    | ‚ùå No     |
| Redeclaration      | ‚úÖ Yes          | ‚ùå No     | ‚ùå No     |
| Global property    | ‚úÖ Yes          | ‚ùå No     | ‚ùå No     |
| Temporal Dead Zone | ‚ùå No           | ‚úÖ Yes    | ‚úÖ Yes    |

**var - The Old Way (Avoid!):**

```javascript
var x = 10;
var x = 20; // ‚úÖ Redeclaration allowed (bad!)
x = 30; // ‚úÖ Reassignment allowed

function test() {
  var y = 5; // Function scoped
  if (true) {
    var y = 10; // Same variable! (no block scope)
  }
  console.log(y); // 10
}
```

**let - Block Scoped Variable:**

```javascript
let x = 10;
// let x = 20;   // ‚ùå Error: Cannot redeclare
x = 20; // ‚úÖ Reassignment allowed

function test() {
  let y = 5; // Block scoped
  if (true) {
    let y = 10; // Different variable (block scope)
  }
  console.log(y); // 5
}
```

**const - Block Scoped Constant:**

```javascript
const x = 10;
// x = 20;       // ‚ùå Error: Assignment to constant
// const x = 30; // ‚ùå Error: Cannot redeclare

const obj = { value: 5 };
obj.value = 10; // ‚úÖ Can mutate properties!
// obj = {};     // ‚ùå Cannot reassign
```

**Why This Matters:**

- var causes scope bugs and hoisting confusion
- let/const prevent accidental redeclaration
- const communicates immutability intent
- Block scope prevents variable leaking
- Modern JavaScript uses const by default, let when needed

**The const Misconception:**

```javascript
// const doesn't make objects immutable!
const arr = [1, 2, 3];
arr.push(4); // ‚úÖ Allowed! Mutates array
arr[0] = 99; // ‚úÖ Allowed! Changes element
// arr = [5, 6];    // ‚ùå Error: Reassignment

const obj = { x: 1 };
obj.x = 2; // ‚úÖ Allowed! Mutates property
obj.y = 3; // ‚úÖ Allowed! Adds property
// obj = { x: 5 };  // ‚ùå Error: Reassignment
```

**Interview Gold:** "const prevents reassignment, not mutation. Use Object.freeze() for immutability."

---

### 2. Scope - Function vs Block (CRITICAL!)

**What it means:**

- Scope determines where variables are accessible
- var has function scope, let/const have block scope
- Understanding scope prevents bugs and variable shadowing issues

**Function Scope (var):**

```javascript
function example() {
  var x = 1;

  if (true) {
    var x = 2; // Same variable!
    var y = 3; // Function scoped
  }

  console.log(x); // 2 (changed in if block)
  console.log(y); // 3 (accessible outside if)
}
```

**Block Scope (let/const):**

```javascript
function example() {
  let x = 1;

  if (true) {
    let x = 2; // Different variable!
    let y = 3; // Block scoped
    console.log(x); // 2
  }

  console.log(x); // 1 (original unchanged)
  // console.log(y); // ‚ùå ReferenceError
}
```

**Block Definition:**
A block is anything between `{}`:

- if/else statements
- for/while loops
- switch statements
- try/catch blocks
- Standalone blocks `{}`

**Loop Scope - Classic Interview Question:**

```javascript
// var problem
for (var i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 100);
}
// Prints: 3, 3, 3 (var is function scoped!)

// let solution
for (let i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 100);
}
// Prints: 0, 1, 2 (let creates new binding per iteration!)
```

**Scope Chain:**

```javascript
const global = "global";

function outer() {
  const outerVar = "outer";

  function inner() {
    const innerVar = "inner";

    // Can access all three
    console.log(global); // ‚úÖ
    console.log(outerVar); // ‚úÖ
    console.log(innerVar); // ‚úÖ
  }

  // console.log(innerVar); // ‚ùå ReferenceError
}
```

**Why Block Scope Matters:**

- Prevents variable leaking from loops
- Enables proper closure behavior
- Makes code more predictable
- Reduces naming conflicts
- Better memory management

---

### 3. Hoisting - The Mechanism (CRITICAL!)

**What it means:**

- JavaScript moves declarations to the top of their scope
- Only declarations are hoisted, not initializations
- Different behavior for var, let/const, and functions

**The Hoisting Process:**

Before execution, JavaScript:

1. Scans for all declarations
2. Allocates memory for them
3. Initializes var to undefined
4. Leaves let/const uninitialized (TDZ)

**var Hoisting:**

```javascript
// What you write:
console.log(x); // undefined (not error!)
var x = 5;
console.log(x); // 5

// How JavaScript sees it:
var x; // Declaration hoisted
console.log(x); // undefined
x = 5; // Assignment stays in place
console.log(x); // 5
```

**let/const Hoisting (with TDZ):**

```javascript
// What you write:
console.log(x); // ‚ùå ReferenceError: Cannot access before initialization
let x = 5;

// How JavaScript sees it:
// let x;           // Declaration hoisted BUT in TDZ
// console.log(x);  // ‚ùå Still in TDZ!
let x = 5; // TDZ ends here
```

**Function Hoisting:**

```javascript
// Function declarations are fully hoisted
greet(); // ‚úÖ "Hello" (works!)

function greet() {
  console.log("Hello");
}

// Function expressions are NOT fully hoisted
// sayHi(); // ‚ùå TypeError: sayHi is not a function

var sayHi = function () {
  console.log("Hi");
};
```

**Hoisting Order:**

1. Function declarations (highest priority)
2. Variable declarations
3. Assignments (not hoisted)

**Practical Impact:**

```javascript
var name = "Global";

function test() {
  console.log(name); // undefined (not "Global"!)
  var name = "Local";
  console.log(name); // "Local"
}

// Why? Hoisting creates this:
function test() {
  var name; // Hoisted, shadows global
  console.log(name); // undefined
  name = "Local";
  console.log(name); // "Local"
}
```

**Interview Gold:** "Hoisting is JavaScript's default behavior of moving declarations to the top of their scope before code execution."

---

### 4. Temporal Dead Zone (TDZ) (Asked in 80% of Interviews!)

**What it means:**

- Period between entering scope and variable initialization
- Only applies to let, const, and class declarations
- Accessing variable in TDZ throws ReferenceError

**The TDZ Visualized:**

```javascript
// TDZ starts at beginning of scope
{
  // TDZ for x starts here ‚ö†Ô∏è
  console.log(x); // ‚ùå ReferenceError
  // Still in TDZ ‚ö†Ô∏è

  let x = 5; // TDZ ends here ‚úÖ
  console.log(x); // ‚úÖ 5
}
```

**TDZ with Different Declarations:**

```javascript
// var - NO TDZ
console.log(a); // undefined
var a = 1;

// let - HAS TDZ
// console.log(b); // ‚ùå ReferenceError
let b = 2;

// const - HAS TDZ
// console.log(c); // ‚ùå ReferenceError
const c = 3;

// function - NO TDZ
greet(); // ‚úÖ Works
function greet() {}
```

**TDZ in Function Parameters:**

```javascript
// Error: param in TDZ
function test(a = b, b = 2) {
  // b is in TDZ when evaluating a
  return a + b;
}
// test(); // ‚ùå ReferenceError

// Correct order:
function test(b = 2, a = b) {
  return a + b;
}
test(); // ‚úÖ Works
```

**TDZ with typeof:**

```javascript
// var behavior
console.log(typeof undeclaredVar); // "undefined"

// let/const behavior
// console.log(typeof x); // ‚ùå ReferenceError (in TDZ)
let x = 5;
```

**Why TDZ Exists:**

- Catches reference errors early
- Prevents using variables before initialization
- Makes const truly constant (can't access before assignment)
- Encourages better coding practices

**Common TDZ Mistake:**

```javascript
let x = x + 1; // ‚ùå ReferenceError
// x is in TDZ on the right side!

// Should be:
let x = 1;
x = x + 1; // ‚úÖ Works
```

**Interview Pattern:**

```javascript
// Question: What does this print?
let x = 1;
{
  console.log(x); // ‚ùå ReferenceError
  let x = 2; // This creates TDZ for x in this block
}

// Why? Block-scoped x shadows outer x
// and is in TDZ when console.log runs
```

---

### 5. Variable Shadowing (Important!)

**What it means:**

- Inner scope variable with same name as outer scope
- Inner variable "shadows" (hides) the outer one
- Different rules for var vs let/const

**Block Scope Shadowing (let/const):**

```javascript
let x = 1;

function test() {
  let x = 2; // Shadows outer x
  console.log(x); // 2

  {
    let x = 3; // Shadows function x
    console.log(x); // 3
  }

  console.log(x); // 2
}

console.log(x); // 1
```

**Function Scope Shadowing (var):**

```javascript
var x = 1;

function test() {
  var x = 2; // Shadows global x
  console.log(x); // 2
}

console.log(x); // 1
```

**Illegal Shadowing:**

```javascript
// Can't shadow let/const with var in same function
function test() {
  let x = 1;
  {
    var x = 2; // ‚ùå SyntaxError!
    // var is function scoped, conflicts with let
  }
}

// But this works:
function test() {
  let x = 1;
  {
    let x = 2; // ‚úÖ Different block scope
  }
}
```

**Parameter Shadowing:**

```javascript
function greet(name) {
  // let name = "Inner"; // ‚ùå Error: 'name' already declared
  var name = "Inner"; // ‚úÖ var can shadow parameter
  console.log(name);
}
```

**Why Shadowing Happens:**

```javascript
// Useful: Same variable name in different scopes
function calculate(data) {
  let result = data * 2;

  if (data > 10) {
    let result = data * 3; // Different calculation
    return result;
  }

  return result;
}
```

---

### 6. Global Scope & Global Object (Important!)

**What it means:**

- Variables in outermost scope are global
- In browsers: global object is `window`
- In Node.js: global object is `global`
- var creates properties on global object, let/const don't

**var on Global Object:**

```javascript
// In browser
var globalVar = "I'm global";
console.log(window.globalVar); // "I'm global"

let globalLet = "Also global";
console.log(window.globalLet); // undefined
```

**Implicit Globals (BAD!):**

```javascript
function test() {
  // Forgot var/let/const
  x = 10; // Creates global! ‚ö†Ô∏è
}

test();
console.log(x); // 10 (global!)
```

**Strict Mode Prevention:**

```javascript
"use strict";

function test() {
  x = 10; // ‚ùå ReferenceError: x is not defined
}
```

**Global Scope Pollution:**

```javascript
// Bad: Pollutes global scope
var $ = "My library";
var data = [1, 2, 3];

// Good: Use modules or IIFE
(function () {
  var $ = "My library";
  var data = [1, 2, 3];
})();
```

**Global in Different Environments:**

```javascript
// Universal access to global object
const globalObject =
  typeof window !== "undefined"
    ? window
    : typeof global !== "undefined"
    ? global
    : typeof self !== "undefined"
    ? self
    : this;

// ES2020: globalThis
console.log(globalThis); // Works everywhere!
```

---

### 7. Best Practices (Must Follow!)

**What it means:**

- Modern JavaScript has clear guidelines
- Following these prevents common bugs
- Shows maturity in interviews

**Declaration Order:**

```javascript
// ‚úÖ BEST: Use const by default
const PI = 3.14159;
const config = { debug: true };

// ‚úÖ GOOD: Use let when reassignment needed
let counter = 0;
counter++;

// ‚ùå AVOID: Never use var
// var x = 10;
```

**Declaration Style:**

```javascript
// ‚úÖ GOOD: Declare at top of scope
function process() {
  const items = [];
  let total = 0;
  let count = 0;

  // ... use them
}

// ‚ùå BAD: Scattered declarations
function process() {
  // some code
  const items = [];
  // more code
  let total = 0;
  // even more code
  let count = 0;
}
```

**One Declaration Per Line:**

```javascript
// ‚úÖ GOOD: Easy to read
const name = "Alice";
const age = 30;
const city = "NYC";

// ‚ùå AVOID: Hard to read
const name = "Alice",
  age = 30,
  city = "NYC";
```

**Always Initialize:**

```javascript
// ‚úÖ GOOD: Initialize when declaring
let count = 0;
const config = {};

// ‚ùå AVOID: Uninitialized let
let count;
// ... lots of code
count = 0; // Easy to forget or mistake
```

**No Implicit Globals:**

```javascript
// ‚úÖ ALWAYS: Use strict mode
"use strict";

function test() {
  // x = 10; // ‚ùå Error caught!
  let x = 10; // ‚úÖ Proper declaration
}
```

**Scope Minimization:**

```javascript
// ‚úÖ GOOD: Minimal scope
for (let i = 0; i < 10; i++) {
  // i only exists here
}

// ‚ùå BAD: Unnecessary wide scope
let i;
for (i = 0; i < 10; i++) {
  // i exists in entire function
}
```

---

## üé§ Top Interview Questions & Model Answers

### Q1: What's the difference between var, let, and const?

**Perfect Answer:**

> "The main differences are scope, hoisting behavior, and reassignment. `var` is function-scoped and hoisted with an initial value of `undefined`, meaning you can access it before declaration without an error. `let` and `const` are block-scoped and also hoisted, but they're in the Temporal Dead Zone until their declaration is reached, so accessing them early throws a ReferenceError.
>
> For reassignment, `var` and `let` allow it, but `const` doesn't - though `const` only prevents reassignment of the binding, not mutation of objects or arrays. Another key difference: `var` creates properties on the global object in browsers, while `let` and `const` don't.
>
> In modern code, I use `const` by default for values that won't be reassigned, `let` when I need reassignment, and never use `var` because its function scope and hoisting behavior can cause bugs."

---

### Q2: What is hoisting in JavaScript?

**Perfect Answer:**

> "Hoisting is JavaScript's behavior of moving variable and function declarations to the top of their scope during the compilation phase, before code execution. It's important to understand that only declarations are hoisted, not initializations.
>
> For `var`, the declaration is hoisted and initialized to `undefined`, so you can reference it before the declaration line without an error - you just get `undefined`. For `let` and `const`, the declaration is hoisted but they remain uninitialized in what's called the Temporal Dead Zone until the line where they're declared is reached.
>
> Function declarations are fully hoisted - both declaration and definition - so you can call them before they appear in the code. Function expressions assigned to variables follow the variable hoisting rules.
>
> Understanding hoisting helps avoid bugs, but best practice is to always declare variables at the top of their scope anyway, making the hoisting behavior explicit in your code."

---

### Q3: What is the Temporal Dead Zone?

**Perfect Answer:**

> "The Temporal Dead Zone is the period between entering a scope and a variable's initialization where accessing that variable throws a ReferenceError. It applies to `let`, `const`, and `class` declarations, but not `var`.
>
> The TDZ starts at the beginning of the scope and ends when the variable is initialized. For example, if you try to access a `let` variable before its declaration line, you'll get a ReferenceError even though the declaration has been hoisted.
>
> The TDZ exists to catch bugs early - it prevents you from using variables before they're ready. It also makes `const` truly constant because you can't access the variable before it's assigned. This is different from `var`, where you'd just get `undefined`, which can hide bugs.
>
> A common gotcha is that the TDZ applies per-scope, so a `let` variable in an inner scope can shadow an outer one and create its own TDZ, even if the outer variable is accessible."

---

### Q4: Can you change a const object's properties?

**Perfect Answer:**

> "Yes, you absolutely can. `const` only prevents reassignment of the variable binding itself, not mutation of the value it points to. For objects and arrays, `const` means you can't make the variable point to a different object, but you can freely modify the properties or elements of the existing object.
>
> For example, `const obj = { x: 1 }; obj.x = 2;` works fine - you're mutating the object, not reassigning it. But `obj = { x: 2 }` would error because you're trying to reassign the variable.
>
> If you want true immutability, you need to use `Object.freeze()` for shallow immutability, or use immutable data structures or techniques like spreading objects for deep immutability. In React and Redux, we follow immutability patterns even though we typically use `const` - we create new objects rather than mutating existing ones.
>
> The const keyword is about the variable, not the value - it's a binding constraint, not a value constraint."

---

### Q5: Explain the classic var loop problem and how let solves it

**Perfect Answer:**

> "The classic problem occurs when using `var` in a loop with async callbacks. Since `var` is function-scoped, there's only one `i` variable shared across all iterations. By the time the async callbacks run, the loop has finished and `i` has its final value.
>
> For example, with `for(var i=0; i<3; i++) { setTimeout(() => console.log(i), 100); }`, you'd expect 0, 1, 2, but you get 3, 3, 3 because all callbacks reference the same `i` which is now 3.
>
> `let` solves this because it's block-scoped and creates a new binding for each iteration. Behind the scenes, JavaScript creates a new `i` variable for each iteration of the loop body, so each callback captures its own unique value.
>
> Before ES6, you'd solve this with an IIFE to create a closure: `for(var i=0; i<3; i++) { (function(i) { setTimeout(() => console.log(i), 100); })(i); }`. But with `let`, it just works naturally. This is one of the main reasons `let` was introduced."

---

### Q6: What is variable shadowing?

**Perfect Answer:**

> "Variable shadowing occurs when a variable declared in an inner scope has the same name as a variable in an outer scope. The inner variable 'shadows' or hides the outer one, making it inaccessible within that inner scope.
>
> With `let` and `const`, shadowing works cleanly because of block scope - each block can have its own variable with the same name as an outer one. But there are rules: you can't shadow a `let` or `const` with a `var` in the same function scope because `var` is function-scoped and would create a conflict.
>
> Shadowing can be useful when you want to reuse variable names in different scopes, but it can also cause confusion if overused. It's important to know that shadowing happens per-scope - if you have `let x = 1;` at the global level and `let x = 2;` in a function, they're completely separate variables.
>
> One gotcha is shadowing in the Temporal Dead Zone - if you try to access an outer variable before declaring an inner one with the same name, you'll get a ReferenceError because the inner declaration creates a TDZ, even though the outer variable exists."

---

## üîë Must Know Checklist

### ‚úÖ Critical (Always asked)

- ‚úÖ var, let, const differences (scope, hoisting, reassignment)
- ‚úÖ What is hoisting and how it works
- ‚úÖ Temporal Dead Zone concept and behavior
- ‚úÖ Function scope vs block scope
- ‚úÖ const doesn't prevent mutation
- ‚úÖ Classic var loop problem and let solution

### ‚úÖ Should Know (Frequently asked)

- ‚úÖ Variable shadowing and illegal shadowing
- ‚úÖ Global scope and global object behavior
- ‚úÖ Hoisting order (functions, then variables)
- ‚úÖ Implicit globals (missing declaration)
- ‚úÖ Best practices for modern JavaScript

### ‚úÖ Nice to Know (Senior level)

- [ ] TDZ in function parameters
- [ ] var on global object vs let/const
- [ ] strict mode impact on declarations
- [ ] globalThis for cross-environment code

---

## üö® Common Mistakes to Avoid

### 1. Using var in Modern Code

```javascript
// ‚ùå NEVER do this in new code
var count = 0;
for (var i = 0; i < 10; i++) {
  var item = items[i];
}

// ‚úÖ Always use let/const
let count = 0;
for (let i = 0; i < 10; i++) {
  const item = items[i];
}
```

### 2. Reassigning const Primitives

```javascript
// ‚ùå Error: Assignment to constant
const PI = 3.14;
PI = 3.14159;

// ‚úÖ Use let if reassignment needed
let counter = 0;
counter++;
```

### 3. Forgetting const is Not Immutable

```javascript
// ‚ùå Wrong assumption
const config = { debug: false };
// Can't prevent mutation this way
config.debug = true; // Works!

// ‚úÖ Need Object.freeze for immutability
const config = Object.freeze({ debug: false });
// config.debug = true; // Silent fail (error in strict mode)
```

### 4. Creating Implicit Globals

```javascript
// ‚ùå Forgot to declare
function update() {
  total = 100; // Creates global!
}

// ‚úÖ Always declare
function update() {
  let total = 100;
}

// ‚úÖ Or use strict mode to catch it
("use strict");
function update() {
  total = 100; // ‚ùå ReferenceError!
}
```

### 5. Declaring in Wrong Place

```javascript
// ‚ùå BAD: Declaration after use
console.log(x); // undefined (confusing!)
var x = 5;

// ‚úÖ GOOD: Declare at top
let x = 5;
console.log(x); // 5
```

---

## üí° Pro Tips for Interviews

1. **Always mention TDZ** when discussing let/const hoisting
2. **Explain the var loop problem** - shows deep understanding
3. **Emphasize const doesn't mean immutable** - common misconception
4. **Draw scope diagrams** - visual representation impresses
5. **Use "block" not "curly braces"** - proper terminology
6. **Mention strict mode** - shows awareness of best practices
7. **Connect to React/Redux** - show real-world application
8. **Explain WHY let/const were added** - shows historical context

---

## üìö Quick Reference

### Declaration Rules

```javascript
// Modern JavaScript standards:
const DEFAULT = const;      // Default choice
let   WHEN_NEEDED = let;    // When reassignment needed
var   NEVER = var;          // Never use in new code
```

### Scope Rules

```javascript
// Function scope (var)
if (true) {
  var x = 1; // Accessible outside if
}

// Block scope (let/const)
if (true) {
  let y = 2; // NOT accessible outside if
}
```

### Hoisting Patterns

```javascript
// var hoisting
console.log(x); // undefined
var x = 5;

// let/const hoisting (TDZ)
// console.log(y); // ReferenceError
let y = 5;

// Function hoisting
greet(); // Works!
function greet() {}
```

---

**Remember:** Modern JavaScript is const-first, let-when-needed, never-var. Understanding these fundamentals separates junior from senior developers!
