# Operators & Expressions

## üéØ Key Concepts

### 1. Short-Circuit Evaluation (CRITICAL!)

**What it means:**

- Logical operators (&&, ||) don't always evaluate all operands
- Evaluation stops as soon as result is determined
- Returns the actual operand value, not just true/false
- Essential for conditional execution and default values

**AND (&&) - Short-circuits on first falsy:**

```javascript
// Evaluates left to right, stops at first falsy
true && true && false && console.log("never runs");

// Returns the first falsy value OR last value if all truthy
false && "never evaluated"; // Returns: false
true && false; // Returns: false
true && "last value"; // Returns: "last value"
0 && "not evaluated"; // Returns: 0
null && "not evaluated"; // Returns: null
```

**OR (||) - Short-circuits on first truthy:**

```javascript
// Evaluates left to right, stops at first truthy
false || 0 || "" || console.log("runs!"); // Evaluates all

// Returns the first truthy value OR last value if all falsy
true || "not evaluated"; // Returns: true
false || "second value"; // Returns: "second value"
null || undefined || "last"; // Returns: "last"
"" || 0 || false; // Returns: false (last)
```

**Practical Usage:**

**Conditional Execution:**

```javascript
// Execute only if condition is truthy
isLoggedIn && redirect();
// Same as: if (isLoggedIn) redirect();

hasPermission && user && saveData();
// Both must be truthy to execute
```

**Default Values (Old Way):**

```javascript
// Use || for default values
function greet(name) {
  name = name || "Guest"; // If name is falsy, use "Guest"
  return `Hello, ${name}`;
}

greet(""); // "Hello, Guest" (but "" is valid!)
greet(null); // "Hello, Guest"
greet("Alice"); // "Hello, Alice"
```

**Guard Clauses:**

```javascript
// Check before accessing properties
const name = user && user.profile && user.profile.name;
// Modern: user?.profile?.name (optional chaining)
```

**Why It Matters:**

- Enables concise conditional logic
- Prevents unnecessary function calls
- Performance optimization (skip expensive operations)
- Foundation for nullish coalescing and optional chaining

**Common Gotcha:**

```javascript
// Problem: 0 is valid but falsy
function setVolume(level) {
  level = level || 50; // 0 becomes 50! ‚ùå
  return level;
}

// Solution: Use nullish coalescing
function setVolume(level) {
  level = level ?? 50; // Only null/undefined become 50 ‚úÖ
  return level;
}
```

**Interview Gold:** "Short-circuit evaluation returns the actual operand, not a boolean. && returns first falsy or last value, || returns first truthy or last value."

---

### 2. Nullish Coalescing (??) vs OR (||) (CRITICAL!)

**What it means:**

- `??` checks only for `null` or `undefined`
- `||` checks for any falsy value
- `??` is the modern, safer way to provide defaults

**The Difference:**

| Operator | Checks For         | Use Case                |
| -------- | ------------------ | ----------------------- |
| `??`     | null, undefined    | Default values (strict) |
| `\|\|`   | All 8 falsy values | Legacy default values   |

**Nullish Coalescing (??):**

```javascript
// Only null and undefined trigger fallback
null ?? "default"; // "default"
undefined ?? "default"; // "default"

// Valid falsy values are NOT replaced
0 ?? "default"; // 0 ‚úÖ
"" ?? "default"; // "" ‚úÖ
false ?? "default"; // false ‚úÖ
NaN ?? "default"; // NaN ‚úÖ
```

**OR Operator (||):**

```javascript
// Any falsy value triggers fallback
null || "default"; // "default"
undefined || "default"; // "default"

// Valid falsy values ARE replaced (often wrong!)
0 || "default"; // "default" ‚ùå
"" || "default"; // "default" ‚ùå
false || "default"; // "default" ‚ùå
NaN || "default"; // "default" ‚ùå
```

**Real-World Examples:**

**Volume Control:**

```javascript
// BAD: || treats 0 as missing
function setVolume(level) {
  return level || 50; // 0 becomes 50! ‚ùå
}

// GOOD: ?? only checks null/undefined
function setVolume(level) {
  return level ?? 50; // 0 stays 0 ‚úÖ
}

setVolume(0); // Should be 0, not 50
setVolume(null); // Should be 50
setVolume(undefined); // Should be 50
```

**User Settings:**

```javascript
// User can disable features with false
const settings = {
  notifications: false, // User explicitly disabled
  theme: null, // Not set yet
  fontSize: 0, // Valid small size
};

// BAD with ||
const notify = settings.notifications || true; // true ‚ùå
const size = settings.fontSize || 16; // 16 ‚ùå

// GOOD with ??
const notify = settings.notifications ?? true; // false ‚úÖ
const size = settings.fontSize ?? 16; // 0 ‚úÖ
const theme = settings.theme ?? "light"; // "light" ‚úÖ
```

**API Responses:**

```javascript
// API returns 0 for count (valid)
const response = {
  count: 0,
  page: null,
  total: undefined,
};

// BAD
const count = response.count || 100; // 100 ‚ùå (lost data!)

// GOOD
const count = response.count ?? 100; // 0 ‚úÖ
const page = response.page ?? 1; // 1 ‚úÖ
const total = response.total ?? 0; // 0 ‚úÖ
```

**Chaining with Other Operators:**

```javascript
// Must use parentheses with && or ||
// (a ?? b) && c     // ‚úÖ OK
// a ?? b && c       // ‚ùå SyntaxError

const value = (input ?? 0) && processValue;
```

**When to Use Each:**

Use `??`:

- ‚úÖ Default function parameters
- ‚úÖ Configuration values
- ‚úÖ API response handling
- ‚úÖ When 0, "", false are valid

Use `||`:

- ‚ùå Rarely! Only when ALL falsy values should trigger default
- ‚úÖ Boolean coercion: `!!value || defaultBool`

**Interview Gold:** "Use ?? instead of || for default values. It only checks null/undefined, not all falsy values like 0, '', or false."

---

### 3. Optional Chaining (?.) (CRITICAL!)

**What it means:**

- Safely access nested properties that might not exist
- Short-circuits to `undefined` if any part is null/undefined
- Prevents "Cannot read property of undefined" errors
- Works with properties, methods, and array indexes

**Basic Syntax:**

```javascript
// Without optional chaining
const name = user && user.profile && user.profile.name;

// With optional chaining
const name = user?.profile?.name;

// Returns undefined if any part is null/undefined
```

**Property Access:**

```javascript
const user = null;

// Old way - crashes
// const name = user.profile.name; // ‚ùå TypeError!

// Guard clause - verbose
const name = user && user.profile && user.profile.name;

// Optional chaining - clean
const name = user?.profile?.name; // undefined ‚úÖ
```

**Method Calls:**

```javascript
const user = {
  getName: null,
};

// Without optional chaining
// user.getName(); // ‚ùå TypeError: getName is not a function

// With optional chaining
user.getName?.(); // undefined ‚úÖ (doesn't call if null/undefined)

// Real example
const result = obj.someMethod?.();
// Only calls if someMethod exists
```

**Array Access:**

```javascript
const arr = null;

// Without optional chaining
// const first = arr[0]; // ‚ùå TypeError

// With optional chaining
const first = arr?.[0]; // undefined ‚úÖ

// Nested arrays
const value = data?.[0]?.[1]?.value;
```

**Dynamic Properties:**

```javascript
const key = "name";

// Optional chaining with bracket notation
const value = user?.[key];

// Nested dynamic access
const nested = obj?.["nested"]?.["property"];
```

**Combining with Nullish Coalescing:**

```javascript
// Provide defaults for missing values
const name = user?.profile?.name ?? "Anonymous";
const count = data?.items?.length ?? 0;
const theme = settings?.appearance?.theme ?? "light";

// Method call with default
const result = obj?.calculate?.() ?? 0;
```

**Common Patterns:**

**API Response Handling:**

```javascript
// Safely access nested API data
const city = response?.data?.user?.address?.city;
const firstItem = response?.data?.items?.[0];
const processData = response?.data?.process?.();
```

**Event Handlers:**

```javascript
// Safely access event properties
function handleClick(event) {
  const target = event?.target?.value;
  const key = event?.key?.toLowerCase();
}
```

**DOM Manipulation:**

```javascript
// Safely access DOM elements
const text = document.getElementById("myId")?.textContent;
const firstChild = element?.firstChild?.nodeName;

// Method calls
element?.querySelector(".class")?.addEventListener("click", handler);
```

**Important Limitations:**

**Cannot Use on Left Side of Assignment:**

```javascript
// ‚ùå SyntaxError
obj?.property = value;

// ‚úÖ Must check explicitly
if (obj) {
  obj.property = value;
}
```

**Doesn't Short-Circuit Everything:**

```javascript
// The expression after ?. still evaluates
const result = obj?.method(expensiveFunction());
// expensiveFunction() still runs even if obj is null!

// Solution: Guard the entire thing
const result = obj ? obj.method(expensiveFunction()) : undefined;
```

**Delete Operator:**

```javascript
// ‚ùå Cannot use with delete
delete obj?.property; // SyntaxError

// ‚úÖ Must check explicitly
if (obj) delete obj.property;
```

**Why It Matters:**

- Eliminates boilerplate null checks
- Makes code more readable
- Prevents runtime errors
- Essential for TypeScript and modern JavaScript

**Interview Gold:** "Optional chaining (?.) short-circuits to undefined if any part is null/undefined. It works with properties, methods, and array access, but can't be used on the left side of assignment."

---

### 4. Operator Precedence (Important!)

**What it means:**

- Order in which operators are evaluated
- Higher precedence = evaluated first
- Parentheses override precedence
- Understanding prevents subtle bugs

**Precedence Levels (High to Low):**

1. **Grouping** `()`
2. **Member Access** `.` `?.` `[]`
3. **Function Call** `()`
4. **Postfix** `++` `--`
5. **Prefix** `!` `~` `+` `-` `++` `--` `typeof` `void` `delete`
6. **Exponentiation** `**`
7. **Multiplication/Division** `*` `/` `%`
8. **Addition/Subtraction** `+` `-`
9. **Bitwise Shift** `<<` `>>` `>>>`
10. **Relational** `<` `<=` `>` `>=` `in` `instanceof`
11. **Equality** `==` `!=` `===` `!==`
12. **Bitwise AND** `&`
13. **Bitwise XOR** `^`
14. **Bitwise OR** `|`
15. **Logical AND** `&&`
16. **Logical OR** `||`
17. **Nullish Coalescing** `??`
18. **Conditional** `?:`
19. **Assignment** `=` `+=` `-=` etc.

**Common Examples:**

**Arithmetic:**

```javascript
2 + 3 * 4; // 14 (not 20) - * before +
2 ** (3 ** 2); // 512 (right-to-left) - 3^2 then 2^9
10 - 5 - 2; // 3 (left-to-right) - (10-5)-2
```

**Logical with Comparison:**

```javascript
5 > 3 && 2 < 4; // true - comparisons before &&
x || (y && z); // x || (y && z) - && before ||
!a || b; // (!a) || b - ! before ||
```

**Tricky Cases:**

```javascript
// Without parentheses
let x = 5;
x = x + 1 * 2; // 7 (not 12) - * before +

// With parentheses
x = (x + 1) * 2; // 12 - () overrides precedence

// Comparison and logical
(5 > 3 && 10 < 2) || true; // true
// Evaluated as: ((5 > 3) && (10 < 2)) || true
//              (true && false) || true
//              false || true
//              true
```

**Assignment is Lowest:**

```javascript
let a, b;
a = b = 5; // Both are 5 (right-to-left)
// b = 5, then a = b

let x = (y = 10); // ‚ö†Ô∏è Creates global y if not declared!
```

**Nullish Coalescing Caveat:**

```javascript
// Must use parentheses with && or ||
// a ?? b && c     // ‚ùå SyntaxError
(a ?? b) && c; // ‚úÖ OK
a ?? (b && c); // ‚úÖ OK

// Forces you to be explicit
```

**Best Practices:**

```javascript
// ‚ùå Rely on precedence (hard to read)
result = (a + b * c > d && e) || f;

// ‚úÖ Use parentheses for clarity
result = (a + b * c > d && e) || f;

// ‚úÖ Even better: multiple lines
const sum = a + b * c;
const comparison = sum > d;
result = (comparison && e) || f;
```

**Interview Tip:** Don't memorize the full table, know the common ones: arithmetic before comparison, comparison before logical, && before ||.

---

### 5. Ternary Operator (Important!)

**What it means:**

- Compact if-else expression
- `condition ? ifTrue : ifFalse`
- Returns a value (expression, not statement)
- Can be nested (but don't overdo it)

**Basic Syntax:**

```javascript
const result = condition ? valueIfTrue : valueIfFalse;

// Equivalent to:
let result;
if (condition) {
  result = valueIfTrue;
} else {
  result = valueIfFalse;
}
```

**Simple Examples:**

```javascript
const age = 18;
const canVote = age >= 18 ? "Yes" : "No";

const status = isOnline ? "üü¢ Online" : "‚ö´ Offline";

const price = isMember ? 9.99 : 19.99;
```

**With Function Calls:**

```javascript
const result = isValid ? processData() : handleError();

// Execute different functions based on condition
const handler = isAdmin ? adminHandler() : userHandler();
```

**Nested Ternaries:**

```javascript
// Simple nesting - OK
const message = score >= 90 ? "A" : score >= 80 ? "B" : score >= 70 ? "C" : "F";

// Complex nesting - AVOID
const result = a ? (b ? c : d) : e ? f : g; // ‚ùå Unreadable!

// Better: Use if-else for complex logic
let result;
if (a) {
  result = b ? c : d;
} else {
  result = e ? f : g;
}
```

**With Nullish Coalescing:**

```javascript
// Provide defaults based on condition
const value = isEnabled ? config ?? defaultConfig : null;

// Nested with ??
const display = isActive ? data?.value ?? "N/A" : "Inactive";
```

**Common Patterns:**

**JSX in React:**

```javascript
return (
  <div>
    {isLoggedIn ? <Dashboard /> : <Login />}
    {count > 0 ? <List items={items} /> : <EmptyState />}
  </div>
);
```

**Inline Calculations:**

```javascript
const discount = isPremium ? price * 0.8 : price;
const tax = isEU ? amount * 0.2 : 0;
```

**String Building:**

```javascript
const greeting = `Hello${name ? `, ${name}` : ""}!`;
const label = `${count} item${count === 1 ? "" : "s"}`;
```

**When to Use:**

```javascript
// ‚úÖ GOOD: Simple, readable
const status = isActive ? "Active" : "Inactive";

// ‚úÖ GOOD: One level of nesting
const grade = score >= 60 ? (score >= 80 ? "B" : "C") : "F";

// ‚ùå BAD: Too complex
const result = a ? (b ? (c ? d : e) : f) : g ? h : i;

// ‚ùå BAD: Side effects in ternary
const x = flag ? (sideEffect(), value1) : value2; // Use if-else

// ‚ùå BAD: Multiple statements
const y = flag ? (stmt1, stmt2, value) : value2; // Use if-else
```

**Interview Gold:** "Ternary is an expression that returns a value, unlike if-else which is a statement. Use it for simple cases, but prefer if-else for complex logic or side effects."

---

### 6. Comma Operator (Rare but Useful!)

**What it means:**

- Evaluates multiple expressions left to right
- Returns the value of the last expression
- Rarely used but appears in minified code and for loops

**Basic Usage:**

```javascript
// Evaluates both, returns last
let x = (1, 2, 3);  // x = 3

// Without parentheses - assignment has higher precedence
let y = 1, 2, 3;    // SyntaxError

// Multiple assignments
let a = 1, b = 2, c = 3;  // Valid (variable declaration)
```

**In For Loops:**

```javascript
// Most common use case
for (let i = 0, j = 10; i < j; i++, j--) {
  console.log(i, j);
}

// Multiple updates
for (let i = 0; i < 10; i++, sum += i) {
  // Increment i AND update sum
}
```

**Function Returns:**

```javascript
function doStuff() {
  return cleanup(), result;
  // cleanup() runs first, returns result
}

// Equivalent to:
function doStuff() {
  cleanup();
  return result;
}
```

**With Side Effects:**

```javascript
// Execute multiple things, return last
let result = (console.log("side effect"), 42);
// Logs "side effect", result = 42

// Minified code pattern
(0, obj.method)(); // Calls method without binding this
```

**Why It Exists:**

- Compact multiple operations
- Used in code minification
- Legacy pattern from C
- Occasionally useful in constraints (like for loop)

**When NOT to Use:**

```javascript
// ‚ùå Makes code less readable
let x = (doThis(), doThat(), getFinalValue());

// ‚úÖ Better: Separate statements
doThis();
doThat();
let x = getFinalValue();
```

---

### 7. Increment/Decrement (++/--) (Important!)

**What it means:**

- Prefix (`++x`) vs Postfix (`x++`)
- Both modify the variable by 1
- Difference is in the return value
- Common source of bugs

**Prefix (++x, --x):**

```javascript
// Increments THEN returns
let x = 5;
let y = ++x; // x = 6, y = 6

// Decrements THEN returns
let a = 5;
let b = --a; // a = 4, b = 4
```

**Postfix (x++, x--):**

```javascript
// Returns THEN increments
let x = 5;
let y = x++; // x = 6, y = 5 (old value)

// Returns THEN decrements
let a = 5;
let b = a--; // a = 4, b = 5 (old value)
```

**Common Confusion:**

```javascript
let i = 0;
console.log(i++); // 0 (then i becomes 1)
console.log(i); // 1

let j = 0;
console.log(++j); // 1 (j incremented first)
console.log(j); // 1
```

**In Loops:**

```javascript
// Post-increment (most common)
for (let i = 0; i < 5; i++) {
  // i is 0, 1, 2, 3, 4
}

// Pre-increment (less common)
for (let i = 0; i < 5; ++i) {
  // Same result, but increments before loop body
}

// In loop, difference rarely matters
// But matters in expressions:
let arr = [1, 2, 3];
let i = 0;
console.log(arr[i++]); // 1 (uses 0, then increments)
console.log(arr[++i]); // 3 (increments to 2, uses 2)
```

**Best Practices:**

```javascript
// ‚úÖ Use on separate line (clear intent)
counter++;
doSomething();

// ‚ùå Avoid in complex expressions
result = arr[i++] + arr[++j]; // Confusing!

// ‚úÖ Better: Explicit
result = arr[i] + arr[j + 1];
i++;
j++;
```

---

## üé§ Top Interview Questions & Model Answers

### Q1: Explain short-circuit evaluation in JavaScript

**Perfect Answer:**

> "Short-circuit evaluation means logical operators (&&, ||) don't always evaluate all operands - they stop as soon as the result is determined. With &&, if the left side is falsy, it returns that value immediately without evaluating the right. With ||, if the left side is truthy, it returns that immediately.
>
> The key insight is these operators return the actual operand value, not a boolean. For example, `null && expensive()` returns `null` without calling `expensive()`. This enables patterns like conditional execution: `isLoggedIn && redirect()` only calls redirect if isLoggedIn is truthy.
>
> It's also used for default values with ||, though that has issues with valid falsy values like 0 or empty string. That's why modern code uses nullish coalescing instead, which only short-circuits on null or undefined."

### Q2: What's the difference between || and ?? operators?

**Perfect Answer:**

> "Both provide fallback values, but they check different things. The || operator checks for any falsy value - all eight of them including 0, empty string, and false. The ?? operator (nullish coalescing) only checks for null or undefined specifically.
>
> This matters when 0, false, or empty string are valid values. For example, `level || 50` would replace 0 with 50, which is wrong if 0 is a valid volume level. But `level ?? 50` keeps 0 and only uses 50 for null or undefined.
>
> I always use ?? for default values now because it's more precise. The only time I'd use || is if I genuinely want all falsy values to trigger the default, which is rare. The rule is: if 0, '', or false could be valid, use ??."

### Q3: What is optional chaining and when should you use it?

**Perfect Answer:**

> "Optional chaining (?.) safely accesses nested properties that might not exist. If any part of the chain is null or undefined, it short-circuits and returns undefined instead of throwing a TypeError.
>
> For example, `user?.profile?.name` returns undefined if user or profile is null, instead of crashing. It works with properties, methods (`obj.method?.()`), and array access (`arr?.[0]`).
>
> I use it extensively for API responses, DOM manipulation, and anytime I'm accessing nested data that might not exist. It's much cleaner than chaining && operators. One gotcha: you can't use it on the left side of assignment, and it doesn't prevent the arguments to a method from evaluating.
>
> In TypeScript especially, optional chaining pairs perfectly with the type system to handle nullable types safely."

### Q4: Explain operator precedence and why it matters

**Perfect Answer:**

> "Operator precedence determines the order of evaluation when multiple operators are in an expression. For example, `2 + 3 * 4` equals 14, not 20, because multiplication has higher precedence than addition.
>
> The most important ones to know: arithmetic before comparison, comparison before logical, && before ||. For example, `a || b && c` evaluates as `a || (b && c)` because && has higher precedence.
>
> While there's a full precedence table, I don't memorize it - instead I use parentheses for clarity when there's any doubt. `(a + b) * c` is much more readable than relying on precedence rules, and prevents bugs. This is especially important in code reviews where others need to understand intent.
>
> One special case: nullish coalescing requires explicit parentheses with && or || to force you to be clear about intent."

### Q5: When should you use the ternary operator vs if-else?

**Perfect Answer:**

> "Use ternary for simple expressions that return a value, and if-else for complex logic or statements. The key difference is ternary is an expression - it returns a value and can be used inline. If-else is a statement.
>
> Ternary is perfect for simple assignments like `const status = isActive ? 'Active' : 'Inactive'` or in JSX: `{isLoggedIn ? <Dashboard /> : <Login />}`. It's concise and readable for simple cases.
>
> But avoid nested ternaries beyond one level - they become hard to read. Also avoid ternaries with side effects. If you're executing multiple statements or complex logic, use if-else.
>
> My rule of thumb: if you need to format it across multiple lines or add comments to explain it, use if-else instead. Ternary should make code clearer, not more cryptic."

### Q6: What's the difference between ++x and x++?

**Perfect Answer:**

> "Both increment x by 1, but they differ in what value they return. Prefix (++x) increments first then returns the new value. Postfix (x++) returns the old value then increments.
>
> For example, if x is 5, `y = ++x` makes both x and y equal 6. But `y = x++` makes x equal 6 and y equal 5 - y gets the old value before increment.
>
> In practice, this mostly matters in complex expressions or when the return value is used immediately. In a simple loop like `for(let i=0; i<5; i++)`, it doesn't matter because you're not using the return value.
>
> Best practice is to use increment on its own line when possible to avoid confusion, and only use the return value when absolutely necessary. Code clarity beats cleverness."

---

## üîë Must Know Checklist

### ‚úÖ Critical (Always asked)

- ‚úÖ Short-circuit evaluation (&& and ||)
- ‚úÖ Nullish coalescing (??) vs OR (||)
- ‚úÖ Optional chaining (?.) - syntax and use cases
- ‚úÖ Difference between == and === (covered in section 1.1)
- ‚úÖ Ternary operator usage

### ‚úÖ Should Know (Frequently asked)

- ‚úÖ Operator precedence (common cases)
- ‚úÖ Prefix vs postfix increment
- ‚úÖ Logical operators return values (not booleans)
- ‚úÖ Combining ??, ?., and &&/||

### ‚úÖ Nice to Know (Senior level)

- [ ] Comma operator use cases
- [ ] Bitwise operators
- [ ] typeof vs instanceof
- [ ] in operator for objects

---

## üö® Common Mistakes to Avoid

### 1. Using || Instead of ??

```javascript
// ‚ùå BAD: 0 is valid but replaced
const volume = userLevel || 50; // 0 becomes 50

// ‚úÖ GOOD: Only null/undefined replaced
const volume = userLevel ?? 50; // 0 stays 0
```

### 2. Forgetting Operator Precedence

```javascript
// ‚ùå CONFUSING: Hard to read
if (a || (b && c)) {
}

// ‚úÖ CLEAR: Use parentheses
if (a || (b && c)) {
}
```

### 3. Complex Nested Ternaries

```javascript
// ‚ùå BAD: Unreadable
const x = a ? (b ? c : d) : e ? f : g;

// ‚úÖ GOOD: Use if-else
let x;
if (a) {
  x = b ? c : d;
} else {
  x = e ? f : g;
}
```

### 4. Not Understanding Optional Chaining Limitations

```javascript
// ‚ùå WRONG: Can't assign
obj?.property = value;  // SyntaxError

// ‚úÖ RIGHT: Check explicitly
if (obj) obj.property = value;
```

### 5. Confusing Prefix and Postfix

```javascript
// ‚ùå CONFUSING: Return value used
arr[i++] = value;

// ‚úÖ CLEAR: Separate operations
arr[i] = value;
i++;
```

---

## üí° Pro Tips for Interviews

1. **Explain short-circuit optimization** - show you understand performance
2. **Use ?? for modern code** - shows you know ES2020 features
3. **Draw evaluation trees** - visual representation of precedence
4. **Mention optional chaining** - demonstrates modern JavaScript knowledge
5. **Use parentheses for clarity** - shows you value readable code
6. **Connect to React patterns** - show real-world application
7. **Know when NOT to use clever operators** - shows maturity

---

## üìö Quick Reference

### Logical Operators

```javascript
&&  // AND - returns first falsy or last value
||  // OR  - returns first truthy or last value
!   // NOT - returns boolean
??  // Nullish coalescing - checks null/undefined only
```

### Access Operators

```javascript
.   // Property access
?.  // Optional chaining
[]  // Bracket notation
?. [] // Optional bracket notation
```

### Comparison

```javascript
===  // Strict equality (preferred)
!==  // Strict inequality
==   // Loose equality (avoid)
!=   // Loose inequality (avoid)
<    // Less than
>    // Greater than
<=   // Less than or equal
>=   // Greater than or equal
```

### Ternary

```javascript
condition ? valueIfTrue : valueIfFalse;
```

---

**Remember:** Modern JavaScript favors explicitness over cleverness. Use ??, ?., and clear operators to write code that's both safe and readable!
