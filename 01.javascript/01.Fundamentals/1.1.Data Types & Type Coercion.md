# Data Types & Type Coercion

## ğŸ¯ Key Concepts

### 1. Primitive vs Reference Types (CRITICAL!)

**What it means:**

- **Primitives** are stored by value and are immutable
- **Reference types** are stored by reference and are mutable
- This affects how data is copied, compared, and passed to functions

**The 7 Primitive Types:**

```javascript
1. string    - "hello"
2. number    - 42, 3.14, Infinity, NaN
3. boolean   - true, false
4. undefined - undefined (declared but not assigned)
5. null      - null (intentional absence of value)
6. symbol    - Symbol('id') (unique identifier)
7. bigint    - 9007199254740991n (large integers)
```

**Reference Types:**

```javascript
-Object -
  { key: "value" } -
  Array -
  [1, 2, 3] -
  Function -
  function () {} -
  Date -
  new Date() -
  RegExp -
  /pattern/;
// All are actually objects under the hood!
```

**The Fundamental Difference:**

Primitives - **Copy by Value:**

```javascript
let a = 5;
let b = a; // Copies the VALUE
b = 10;
console.log(a); // 5 (unchanged!)
console.log(b); // 10
```

References - **Copy by Reference:**

```javascript
let obj1 = { value: 5 };
let obj2 = obj1; // Copies the REFERENCE
obj2.value = 10;
console.log(obj1.value); // 10 (changed!)
console.log(obj2.value); // 10
// Both point to same object in memory!
```

**Why This Matters:**

- Function parameters work differently for each type
- Comparison operators behave differently
- Understanding prevents bugs with object mutations
- Critical for React state management, Redux, etc.

**Memory Model:**

```
STACK (Primitives)          HEAP (Objects)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ a: 5        â”‚            â”‚ {value: 5}  â”‚â—„â”€â”€â”
â”‚ b: 5        â”‚            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚ obj1: 0x001 â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤             â”‚   â”‚
â”‚ obj2: 0x001 â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜             â”œâ”€â”€â”€â”˜
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Interview Gold:** Understanding value vs reference is THE most important concept in JavaScript!

---

### 2. typeof Operator & Its Quirks (CRITICAL!)

**What it means:**

- `typeof` returns a string indicating the type of operand
- Has several quirks and edge cases you MUST know

**Basic Usage:**

```javascript
typeof "hello"; // "string"
typeof 42; // "number"
typeof true; // "boolean"
typeof undefined; // "undefined"
typeof Symbol(); // "symbol"
typeof 123n; // "bigint"
typeof function () {}; // "function"
typeof {}; // "object"
typeof []; // "object"
```

**The Famous Quirks:**

**Quirk #1: typeof null (Historical Bug!)**

```javascript
typeof null; // "object" âŒ WRONG!
// This is a bug from JavaScript's creation
// null is primitive, not an object
// Too late to fix - would break the web!
```

**Quirk #2: Arrays are "object"**

```javascript
typeof []; // "object"
// Need Array.isArray() to detect arrays
Array.isArray([]); // true âœ…
```

**Quirk #3: Functions are "function"**

```javascript
typeof function () {}; // "function"
// But functions are actually objects
// typeof gives special treatment
```

**Quirk #4: NaN is "number"**

```javascript
typeof NaN; // "number" (Not a Number is a number ğŸ¤¯)
// Use Number.isNaN() to check
Number.isNaN(NaN); // true
```

**Safe Type Checking Pattern:**

```javascript
function getType(value) {
  if (value === null) return "null";
  if (Array.isArray(value)) return "array";
  return typeof value;
}

getType(null); // "null" âœ…
getType([]); // "array" âœ…
getType({}); // "object" âœ…
```

**Interview Tip:** If asked about typeof, ALWAYS mention the null quirk!

---

### 3. null vs undefined (Asked in 90% of Interviews!)

**What it means:**

- Both represent "no value" but have different meanings
- `undefined` = variable declared but not assigned
- `null` = intentional absence of value

**undefined - "I don't have a value yet":**

```javascript
let x; // undefined (declared, not assigned)
let obj = {};
obj.missing; // undefined (property doesn't exist)
function foo() {}
foo(); // undefined (no return statement)

function bar(param) {
  console.log(param); // undefined if not passed
}
bar();
```

**null - "I intentionally have no value":**

```javascript
let user = null; // Intentionally empty
let result = getUserFromDB();
if (!result) {
  result = null; // Explicitly set to null
}
```

**Key Differences:**

| Feature       | undefined    | null                |
| ------------- | ------------ | ------------------- |
| Type          | `undefined`  | `object` (bug!)     |
| Meaning       | Not assigned | Intentionally empty |
| Default value | Yes          | No                  |
| JSON          | Removed      | Kept as `null`      |
| Arithmetic    | NaN          | 0                   |

**Type Checking:**

```javascript
typeof undefined; // "undefined"
typeof null; // "object" (quirk!)

undefined == null; // true (loose equality)
undefined === null; // false (strict equality)
```

**Arithmetic Behavior:**

```javascript
undefined + 5; // NaN
null + 5; // 5 (null coerces to 0)

Number(undefined); // NaN
Number(null); // 0
```

**Best Practices:**

```javascript
// âœ… Use undefined for uninitialized
let value;

// âœ… Use null for intentionally empty
let currentUser = null;

// âœ… Check both with == (rare case where == is OK)
if (value == null) {
  // Catches both null and undefined
}

// âœ… Or use explicit checks
if (value === null || value === undefined) {
  // More explicit, better
}

// âœ… Or use nullish coalescing
const result = value ?? "default";
```

**Interview Gold:** Know when to use each and how they coerce!

---

### 4. Type Coercion - Implicit vs Explicit (CRITICAL!)

**What it means:**

- JavaScript automatically converts types (implicit coercion)
- You can manually convert types (explicit coercion)
- Understanding prevents 90% of JavaScript "wat" moments

**Explicit Coercion (Recommended):**

```javascript
// To String
String(123); // "123"
String(true); // "true"
String(null); // "null"
String(undefined); // "undefined"

// To Number
Number("123"); // 123
Number("12.5"); // 12.5
Number(true); // 1
Number(false); // 0
Number(null); // 0
Number(undefined); // NaN
Number(""); // 0
Number("abc"); // NaN

// To Boolean
Boolean(1); // true
Boolean(0); // false
Boolean(""); // false
Boolean("text"); // true
Boolean(null); // false
Boolean(undefined); // false
Boolean({}); // true (all objects are truthy!)
Boolean([]); // true (even empty arrays!)
```

**Implicit Coercion (Automatic):**

**String Coercion (+):**

```javascript
"hello" + " world"; // "hello world"
"5" + 5; // "55" (number to string)
"5" + true; // "5true"
"5" + null; // "5null"
"5" + undefined; // "5undefined"

// If one operand is string, both become strings!
```

**Numeric Coercion (-, \*, /, %):**

```javascript
"5" - 2; // 3 (string to number)
"5" * "2"; // 10
"10" / "2"; // 5
"5" % 2; // 1

// - operator always converts to number
```

**Boolean Coercion (if, while, ternary):**

```javascript
if ("hello") {
} // true (non-empty string)
if (0) {
} // false
if ([]) {
} // true (objects are truthy!)

// Converts to boolean in boolean contexts
```

**The Confusing Cases:**

```javascript
[] + []        // "" (empty string!)
[] + {}        // "[object Object]"
{} + []        // 0 (or {} depending on context)
{} + {}        // "[object Object][object Object]" or NaN

// Just use explicit coercion to avoid!
```

**Coercion Rules Summary:**

1. **String Conversion:** Everything can become string
2. **Number Conversion:**
   - `true` â†’ 1, `false` â†’ 0
   - `null` â†’ 0
   - `undefined` â†’ NaN
   - `""` â†’ 0
   - Strings parsed as numbers
3. **Boolean Conversion:** Falsy values, everything else truthy

**Interview Pattern:**

```javascript
// Bad: Implicit coercion
function add(a, b) {
  return a + b; // Could be string or number!
}

// Good: Explicit coercion
function add(a, b) {
  return Number(a) + Number(b);
}
```

---

### 5. Truthy and Falsy Values (Must Memorize!)

**What it means:**

- Values that coerce to `true` or `false` in boolean context
- Only 8 falsy values - everything else is truthy!

**The Complete Falsy List (Memorize!):**

```javascript
1. false         // Boolean false
2. 0             // Number zero
3. -0            // Negative zero
4. 0n            // BigInt zero
5. ""            // Empty string
6. null          // null
7. undefined     // undefined
8. NaN           // Not a Number

// That's ALL of them! Everything else is truthy!
```

**Surprisingly Truthy Values:**

```javascript
Boolean("0"); // true âœ… (non-empty string)
Boolean("false"); // true âœ… (non-empty string)
Boolean([]); // true âœ… (objects are truthy)
Boolean({}); // true âœ…
Boolean(function () {}); // true âœ…
Boolean(new Date()); // true âœ…
Boolean(-1); // true âœ… (non-zero number)
Boolean(Infinity); // true âœ…

// Common mistake: thinking these are falsy!
```

**Practical Usage:**

**Default Values:**

```javascript
// âŒ BAD: Doesn't work for 0, "", false
function greet(name) {
  name = name || "Guest"; // 0 becomes "Guest"!
  return `Hello, ${name}`;
}

// âœ… GOOD: Use nullish coalescing
function greet(name) {
  name = name ?? "Guest"; // Only null/undefined
  return `Hello, ${name}`;
}
```

**Existence Checks:**

```javascript
// âœ… Check if variable exists
if (user) {
  console.log(user.name);
}

// âœ… Check if array has items
if (array.length) {
  // Has items
}

// âœ… Check if string is not empty
if (text) {
  // Has content
}
```

**The Double NOT Trick:**

```javascript
// Convert to boolean explicitly
!!value;

!!""; // false
!!"text"; // true
!!0; // false
!![]; // true

// Same as Boolean(value) but shorter
```

**Interview Gotcha:**

```javascript
const value = "0";

if (value) {
  console.log("truthy"); // Prints! "0" is truthy
}

if (Number(value)) {
  console.log("truthy"); // Doesn't print! 0 is falsy
}

// Know the difference!
```

---

### 6. Equality: == vs === (Top Interview Question!)

**What it means:**

- `==` performs type coercion (loose equality)
- `===` checks type AND value (strict equality)
- `===` is almost always preferred

**Strict Equality (===) - Recommended:**

```javascript
5 === 5; // true
5 === "5"; // false (different types)
true === 1; // false
null === undefined; // false
NaN === NaN; // false (NaN is never equal to itself!)

// No type coercion happens
```

**Loose Equality (==) - Avoid:**

```javascript
5 == "5"         // true âš ï¸ (coerces string to number)
true == 1        // true âš ï¸
false == 0       // true âš ï¸
null == undefined // true âš ï¸
"" == 0          // true âš ï¸
[] == ""         // true âš ï¸ (wat!)

// Type coercion happens - unpredictable!
```

**The Coercion Algorithm for ==:**

When comparing different types:

1. If one is `null` or `undefined`, other must be too
2. If one is number, convert other to number
3. If one is boolean, convert to number (trueâ†’1, falseâ†’0)
4. If one is object, call `toString()` or `valueOf()`

**Confusing Examples:**

```javascript
[] == ![]; // true ğŸ¤¯
// Breaks down to: [] == false â†’ "" == 0 â†’ 0 == 0

"" == 0; // true
"0" == 0; // true
"0" == ""; // false ğŸ¤¯ (not transitive!)

false == ""; // true
false == []; // true
false == {}; // false

// Just use === and avoid the madness!
```

**When == is Actually Useful:**

```javascript
// Only valid use case: checking null/undefined
if (value == null) {
  // Catches both null AND undefined
  // More concise than: value === null || value === undefined
}

// That's basically it!
```

**Object Comparison (Both == and ===):**

```javascript
const obj1 = { a: 1 };
const obj2 = { a: 1 };
const obj3 = obj1;

obj1 === obj2; // false (different references)
obj1 === obj3; // true (same reference)
obj1 == obj2; // false (== doesn't help with objects)

// Objects compared by reference, not by value!
```

**Special Cases with NaN:**

```javascript
NaN === NaN; // false (only value not equal to itself)
NaN == NaN; // false

// Use these instead:
Number.isNaN(NaN); // true âœ…
Object.is(NaN, NaN); // true âœ…
```

**Best Practices:**

```javascript
// âœ… ALWAYS use === by default
if (x === y) {
}

// âœ… Only use == for null check
if (value == null) {
}

// âœ… For NaN comparison
if (Number.isNaN(value)) {
}

// âœ… For object comparison
function deepEqual(obj1, obj2) {
  // Custom deep comparison logic
}
```

**Interview Gold:** Explain why === is preferred and the ONE valid use case for ==!

---

### 7. Object.is() - The "Better" Equality (ES6+)

**What it means:**

- Even stricter than `===`
- Handles special cases correctly
- `Object.is(a, b)` is "same value equality"

**Differences from ===:**

**Case 1: NaN Comparison**

```javascript
NaN === NaN; // false
Object.is(NaN, NaN); // true âœ…

// Finally! Consistent NaN comparison
```

**Case 2: +0 vs -0**

```javascript
+0 === -0; // true
Object.is(+0, -0); // false âœ…

// Distinguishes positive and negative zero
```

**All Other Cases:**

```javascript
Object.is(5, 5); // true
Object.is(5, "5"); // false
Object.is(null, null); // true
Object.is({}, {}); // false (different objects)

// Same as === for everything else
```

**When to Use Object.is():**

```javascript
// âœ… Checking for NaN
if (Object.is(value, NaN)) {
  // Better than isNaN() for strict check
}

// âœ… Distinguishing +0 from -0
if (Object.is(value, -0)) {
  // Rare but sometimes needed
}

// âŒ Not needed for regular comparisons
// === is fine for most cases
```

---

## ğŸ¤ Top Interview Questions & Model Answers

### Q1: What's the difference between null and undefined?

**Perfect Answer:**

> "Both represent absence of value, but with different meanings. `undefined` means a variable has been declared but not assigned a value - it's JavaScript's default for uninitialized variables. `null` is an assignment value that represents intentional absence - you explicitly set something to `null` to indicate 'no value here.'
>
> A key quirk is that `typeof null` returns `'object'` due to a historical bug, while `typeof undefined` correctly returns `'undefined'`. They're loosely equal (`null == undefined` is `true`) but strictly different (`null === undefined` is `false`).
>
> In practice, I use `undefined` for function parameters that weren't passed or object properties that don't exist, and `null` when I want to explicitly clear a value, like setting `currentUser = null` on logout."

---

### Q2: Explain type coercion in JavaScript

**Perfect Answer:**

> "Type coercion is JavaScript's automatic type conversion when operations involve different types. There's implicit coercion (automatic) and explicit coercion (manual).
>
> For example, with the `+` operator, if one operand is a string, JavaScript coerces the other to string: `'5' + 5` becomes `'55'`. But with other operators like `-`, JavaScript coerces to numbers: `'5' - 2` becomes `3`.
>
> The coercion rules follow predictable patterns: numbers convert to strings by adding quotes, strings convert to numbers by parsing, booleans convert to 1 or 0, and objects convert via `toString()` or `valueOf()`.
>
> While coercion enables flexible code, I prefer explicit conversion using `String()`, `Number()`, or `Boolean()` for clarity and predictability. The main exception is checking for null/undefined with `value == null`, which is the one case where `==`'s coercion is actually useful."

---

### Q3: What are falsy values in JavaScript?

**Perfect Answer:**

> "JavaScript has exactly 8 falsy values that coerce to `false` in boolean context: `false`, `0`, `-0`, `0n` (BigInt zero), `''` (empty string), `null`, `undefined`, and `NaN`. Everything else is truthy - including `'0'`, `'false'`, empty arrays, empty objects, and all functions.
>
> This matters for conditional checks. For example, `if (value)` will pass for the string `'0'` but fail for the number `0`. A common pattern is using falsy checks for default values, but I prefer nullish coalescing (`??`) when I want to allow `0` or `''` as valid values, since it only treats `null` and `undefined` as absent.
>
> A good way to remember: if you can count the falsy values on your fingers, you're good. Everything else - truthy."

---

### Q4: Why does typeof null return "object"?

**Perfect Answer:**

> "It's a famous bug from JavaScript's first implementation that's too late to fix. In the original JavaScript engine, values were stored with a type tag, and objects had a tag of 0. `null` was represented as a NULL pointer (0x00), so it got the same tag as objects.
>
> This is one of JavaScript's quirks we have to live with. To properly check for `null`, I use strict equality: `value === null`. If I need to check the actual type of a value and account for this quirk, I'll use a helper function that explicitly checks for `null` before using `typeof`.
>
> It's important in interviews because it shows you understand JavaScript's historical context and don't assume language features are perfect. The takeaway is: always use explicit checks for `null` rather than relying on `typeof`."

---

### Q5: What's the difference between == and ===?

**Perfect Answer:**

> "`===` is strict equality - it checks both type and value without any conversion. `==` is loose equality - it performs type coercion before comparing, which makes it unpredictable.
>
> For example, `5 === '5'` is `false` because they're different types, but `5 == '5'` is `true` because JavaScript coerces the string to a number. This can lead to bizarre behavior: `[] == ![]` is `true` due to multiple coercions!
>
> I always use `===` by default because it's predictable and catches type mismatches. The only exception is checking for `null` or `undefined` together: `value == null` is more concise than `value === null || value === undefined` and is the one legitimate use of `==`.
>
> For comparing objects, both operators check reference equality, not deep equality - so `{a:1} === {a:1}` is always `false` because they're different objects in memory."

---

### Q6: Explain the difference between primitive and reference types

**Perfect Answer:**

> "Primitives (string, number, boolean, null, undefined, symbol, bigint) are stored by value and are immutable. Reference types (objects, arrays, functions) are stored by reference and are mutable.
>
> When you assign a primitive, you copy the value: `let b = a` creates a new independent copy. When you assign an object, you copy the reference: both variables point to the same object in memory, so mutating through one affects both.
>
> This has huge implications: function parameters are passed by value for primitives but by reference for objects. So modifying an object parameter inside a function affects the original, but modifying a primitive doesn't.
>
> This is critical for understanding React state (never mutate directly), working with arrays (methods like `push` vs `concat`), and avoiding bugs where you accidentally share mutable data. It's the foundation of why we use immutable patterns in modern JavaScript development."

---

## ğŸ”‘ Must Know Checklist

### âœ… Critical (Always asked)

- âœ… null vs undefined - differences and use cases
- âœ… typeof operator - all outputs and quirks (especially typeof null)
- âœ… Primitive vs reference types - memory model
- âœ… == vs === - coercion rules and when to use each
- âœ… Truthy/falsy values - all 8 falsy values memorized
- âœ… Type coercion - implicit and explicit patterns

### âœ… Should Know (Frequently asked)

- âœ… NaN behavior and checking
- âœ… Object.is() differences from ===
- âœ… Value vs reference comparison
- âœ… Immutability of primitives
- âœ… Type conversion methods (String, Number, Boolean)

### âœ… Nice to Know (Senior level)

- [ ] Symbol use cases
- [ ] BigInt when and why
- [ ] Abstract Equality Comparison Algorithm
- [ ] Type coercion in edge cases

---

## ğŸš¨ Common Mistakes to Avoid

### 1. Using == Instead of ===

```javascript
// âŒ NEVER do this
if (value == "5") {
  // Could match 5, "5", or even [5]
}

// âœ… Always use strict equality
if (value === "5") {
  // Only matches "5"
}
```

### 2. Truthy Check for Number Zero

```javascript
// âŒ BAD: Rejects valid 0
function setVolume(level) {
  level = level || 50; // 0 becomes 50!
  return level;
}

// âœ… GOOD: Use nullish coalescing
function setVolume(level) {
  level = level ?? 50; // Only null/undefined â†’ 50
  return level;
}
```

### 3. Assuming Empty Array is Falsy

```javascript
// âŒ WRONG assumption
if (!myArray) {
  // This won't work! [] is truthy
}

// âœ… Check length instead
if (myArray.length === 0) {
  // Correct way
}
```

### 4. Mutating Objects Passed as Arguments

```javascript
// âŒ DANGEROUS: Mutates original
function updateUser(user) {
  user.name = "New Name"; // Affects original!
  return user;
}

// âœ… SAFE: Create new object
function updateUser(user) {
  return { ...user, name: "New Name" };
}
```

### 5. Forgetting typeof null Returns "object"

```javascript
// âŒ WRONG null check
if (typeof value === "object") {
  // Matches null AND objects!
}

// âœ… CORRECT null check
if (value !== null && typeof value === "object") {
  // Excludes null properly
}
```

---

## ğŸ’¡ Pro Tips for Interviews

1. **Always mention typeof null quirk** - shows you know JavaScript's history
2. **Explain the ONE valid use of ==** - checking null/undefined together
3. **Draw memory diagrams** - visual representation impresses interviewers
4. **Use correct terminology** - "reference" not "pointer", "coercion" not "conversion"
5. **Mention modern alternatives** - nullish coalescing, optional chaining
6. **Link to practical examples** - React state, Redux immutability
7. **Show you prefer explicit over implicit** - demonstrates good coding practice

---

## ğŸ“š Quick Reference

### Type Checking Methods

```javascript
typeof value; // String type name
Array.isArray(value); // Boolean (is array?)
value instanceof Constructor; // Boolean (is instance?)
Object.prototype.toString.call(value); // "[object Type]"
Number.isNaN(value); // Boolean (is NaN?)
Number.isFinite(value); // Boolean (is finite number?)
```

### Conversion Methods

```javascript
String(value); // â†’ string
Number(value); // â†’ number
Boolean(value); // â†’ boolean
parseInt(str); // â†’ integer
parseFloat(str); // â†’ float
value.toString(); // â†’ string (errors on null/undefined)
```

### Comparison Methods

```javascript
===               // Strict equality (preferred)
==                // Loose equality (only for null check)
Object.is(a, b)   // Same-value equality (handles NaN, Â±0)
```

---

**Remember:** These fundamentals are the foundation of everything in JavaScript. Master them, and the rest becomes much easier!
