# Control Flow - Theoretical Deep Dive

### JavaScript Interview Preparation for Senior Frontend Engineer

---

## üéØ Key Concepts

### What is Control Flow?

Control flow is the order in which individual statements, instructions, or function calls are executed in a program. JavaScript provides various control flow statements to direct the execution path based on conditions, loops, or exceptions.

---

## 1. If/Else Statements

### Basic Concept

**What it means:**
Conditional statements that execute different code blocks based on whether conditions evaluate to truthy or falsy values.

**How it works:**
JavaScript evaluates the condition, coerces it to a boolean if necessary, and executes the corresponding block.

**Structure:**

```javascript
if (condition1) {
  // executes if condition1 is truthy
} else if (condition2) {
  // executes if condition1 is falsy and condition2 is truthy
} else {
  // executes if all conditions are falsy
}
```

**Key Understanding Points:**

- Conditions undergo boolean coercion
- Short-circuit evaluation: once a condition is true, remaining conditions aren't evaluated
- `else if` is syntactic sugar for nested `if/else`
- Blocks with single statements can omit braces (not recommended for readability)

**Why This Matters:**
Understanding truthy/falsy coercion prevents bugs. For example, `if (value)` doesn't work for checking if a number is provided when `0` is valid.

**Interview Question & Perfect Answer:**

**Q: What happens with `if ([] == false)` vs `if ([])`?**

**Perfect Answer:**

> "`if ([] == false)` evaluates to `true` because of type coercion: the empty array converts to an empty string `""`, which then converts to `0`, and `false` also converts to `0`, so `0 == 0` is true.
>
> However, `if ([])` evaluates to `true` because objects (including arrays) are always truthy in boolean context, regardless of their contents.
>
> This demonstrates why we should use strict equality `===` and explicit checks like `array.length` instead of relying on coercion. The first uses loose equality with coercion, the second uses direct boolean coercion‚Äîtwo completely different mechanisms."

---

## 2. Switch Statements

### Basic Concept

**What it means:**
A multi-way branch statement that compares a value against multiple cases using strict equality.

**How it works:**
The switch expression is evaluated once, then compared against each case using `===`. When a match is found, execution continues until a `break` or the end of the switch.

**Structure:**

```javascript
switch (expression) {
  case value1:
    // code executes if expression === value1
    break;
  case value2:
  case value3:
    // code executes if expression === value2 OR value3
    break;
  default:
  // code executes if no cases match
}
```

**Key Understanding Points:**

- Uses **strict equality (===)** - no type coercion
- **Fall-through behavior**: without `break`, execution continues to next case
- Multiple cases can share the same code block
- `default` is optional but recommended
- Expression evaluated only once (unlike multiple if/else)

**When to Use Switch vs If/Else:**

**Use Switch When:**

- Comparing single variable against multiple specific values
- Need fall-through behavior
- Multiple conditions share same logic
- More readable than long if/else chain

**Use If/Else When:**

- Complex boolean conditions
- Range checks (e.g., `x > 10 && x < 20`)
- Different variables in different conditions
- Need type coercion

**Interview Question & Perfect Answer:**

**Q: Why does this switch statement execute multiple cases?**

```javascript
let x = 1;
switch (x) {
  case 1:
    console.log("one");
  case 2:
    console.log("two");
  default:
    console.log("default");
}
// Outputs: one, two, default
```

**Perfect Answer:**

> "This demonstrates fall-through behavior in switch statements. Without `break` statements, execution continues into subsequent cases even after a match is found. Once `case 1:` matches, JavaScript executes all following statements until it hits a `break` or reaches the end of the switch block.
>
> This is both a feature and a common pitfall. Fall-through is useful when multiple cases should execute the same code, but forgetting `break` causes unintended execution. It's different from if/else where only one block executes.
>
> The fix is to add `break` after each case, or intentionally use fall-through when multiple cases should execute the same logic."

**Q: What's the result of this switch statement?**

```javascript
switch (1) {
  case "1":
    console.log("string one");
    break;
  case 1:
    console.log("number one");
    break;
}
```

**Perfect Answer:**

> "This outputs 'number one' because switch uses strict equality (`===`), not loose equality (`==`). The number `1` does not strictly equal the string `'1'`, so the first case doesn't match. The second case matches because both are the number `1`.
>
> This is a crucial difference from if statements where `if (1 == '1')` would be true. Switch statements never perform type coercion, which makes them more predictable but requires exact type matching. If you need type coercion, you must explicitly convert types before the switch or use if/else instead."

---

## 3. For Loops

### 3.1 Traditional For Loop

**What it means:**
A loop that executes a block of code a specific number of times, controlled by an initialization, condition, and increment expression.

**Structure:**

```javascript
for (initialization; condition; increment) {
  // code to execute
}
```

**How it works:**

1. Initialization runs once before the loop starts
2. Condition is checked before each iteration
3. If condition is true, code block executes
4. Increment runs after each iteration
5. Process repeats from step 2

**Key Understanding Points:**

- All three expressions are optional (can create infinite loop)
- Variables declared with `let` are block-scoped to the loop
- Can declare multiple variables: `for (let i = 0, j = 10; i < j; i++, j--)`
- Condition is checked before each iteration (including the first)

**Common Use Cases:**

- Iterating a specific number of times
- Iterating with index access needed
- Backward iteration
- Complex iteration patterns

---

### 3.2 For...In Loop

**What it means:**
Iterates over **enumerable properties** of an object, including inherited properties from the prototype chain.

**Structure:**

```javascript
for (let key in object) {
  // code executes for each enumerable property
}
```

**How it works:**

- Iterates through all enumerable properties (including inherited ones)
- Returns property **keys/names** as strings
- Order is not guaranteed in all engines (though modern engines maintain insertion order)
- Skips non-enumerable properties (like built-in methods)

**Key Understanding Points:**

- **For objects:** Returns property names
- **For arrays:** Returns indices as strings (not recommended for arrays!)
- **Includes inherited properties** from prototype chain
- Use `hasOwnProperty()` to filter out inherited properties
- Non-enumerable properties are skipped

**Why Not Use for...in on Arrays:**

```javascript
Array.prototype.customMethod = function () {};
const arr = [1, 2, 3];

for (let i in arr) {
  console.log(i); // "0", "1", "2", "customMethod" ‚ö†Ô∏è
}
```

**Interview Question & Perfect Answer:**

**Q: What's the output and why?**

```javascript
const obj = { a: 1, b: 2 };
Object.prototype.c = 3;

for (let key in obj) {
  console.log(key, obj[key]);
}
```

**Perfect Answer:**

> "This outputs:
>
> ```
> a 1
> b 2
> c 3
> ```
>
> The for...in loop iterates over all enumerable properties, including those inherited from the prototype chain. We added `c` to `Object.prototype`, which makes it available to all objects.
>
> To iterate only over own properties, we should use:
>
> ```javascript
> for (let key in obj) {
>   if (obj.hasOwnProperty(key)) {
>     console.log(key, obj[key]);
>   }
> }
> ```
>
> Or better yet, use `Object.keys(obj)`, `Object.values(obj)`, or `Object.entries(obj)` which only return own enumerable properties. Modern JavaScript has better alternatives to for...in for most use cases."

---

### 3.3 For...Of Loop

**What it means:**
Iterates over **iterable objects** (arrays, strings, Maps, Sets, NodeLists, etc.), returning their **values** directly.

**Structure:**

```javascript
for (let value of iterable) {
  // code executes for each value
}
```

**How it works:**

- Works with any object that implements the iterable protocol
- Returns **values**, not keys/indices
- Uses iterator protocol under the hood
- Cannot iterate over plain objects (they're not iterable)

**Key Understanding Points:**

- **For arrays:** Returns element values
- **For strings:** Returns individual characters
- **For Maps:** Returns [key, value] pairs
- **For Sets:** Returns values
- **Plain objects are not iterable** (use Object.keys/values/entries)
- More efficient and cleaner than traditional for loop

**What Can You Iterate Over:**

- Arrays
- Strings
- Maps
- Sets
- TypedArrays
- NodeLists
- Arguments object
- Generators
- User-defined iterables

**Interview Question & Perfect Answer:**

**Q: What's the difference between for...in and for...of?**

**Perfect Answer:**

> "They serve completely different purposes:
>
> **for...in** iterates over enumerable **property names** (keys):
>
> - Designed for objects
> - Returns keys as strings
> - Includes inherited properties
> - Not recommended for arrays (returns indices as strings)
> - Example: `for (let key in obj)` gives you property names
>
> **for...of** iterates over **values** from iterables:
>
> - Designed for collections (arrays, strings, Maps, Sets)
> - Returns actual values, not keys
> - Only works with iterables (objects must implement Symbol.iterator)
> - Recommended for arrays (returns elements directly)
> - Example: `for (let value of array)` gives you array elements
>
> Quick rule: Use for...of for arrays/collections (values), use for...in for objects (keys), or better yet use Object.keys/values/entries for objects."

**Q: Why does this code throw an error?**

```javascript
const obj = { a: 1, b: 2 };
for (let value of obj) {
  console.log(value);
}
// TypeError: obj is not iterable
```

**Perfect Answer:**

> "Plain objects are not iterable by default in JavaScript. The for...of loop requires an object to implement the iterable protocol (have a `Symbol.iterator` method).
>
> Arrays, strings, Maps, and Sets are iterable because they have built-in `Symbol.iterator` implementations. Plain objects don't have this.
>
> To iterate over object properties, use:
>
> ```javascript
> // For keys
> for (let key of Object.keys(obj))
>
> // For values
> for (let value of Object.values(obj))
>
> // For entries
> for (let [key, value] of Object.entries(obj))
> ```
>
> These methods return arrays, which are iterable. Alternatively, you can use for...in for the object itself, or implement a custom Symbol.iterator method on the object."

---

## 4. While and Do...While Loops

### 4.1 While Loop

**What it means:**
A loop that continues executing as long as a condition is true, with the condition checked **before** each iteration.

**Structure:**

```javascript
while (condition) {
  // code to execute
}
```

**How it works:**

1. Condition is evaluated
2. If true, code block executes
3. Process repeats from step 1
4. If false initially, block never executes

**Key Understanding Points:**

- Condition checked **before** first iteration
- May never execute if condition is initially false
- Must ensure condition eventually becomes false (or use break)
- Good for unknown number of iterations

---

### 4.2 Do...While Loop

**What it means:**
A loop that executes code block at least once, then continues while a condition is true, with condition checked **after** each iteration.

**Structure:**

```javascript
do {
  // code to execute
} while (condition);
```

**How it works:**

1. Code block executes
2. Condition is evaluated
3. If true, process repeats from step 1
4. If false, loop terminates

**Key Understanding Points:**

- Code block executes **at least once** before condition is checked
- Guarantees one execution even if condition is initially false
- Less common than while loop
- Useful when you need to execute once regardless of condition

**Interview Question & Perfect Answer:**

**Q: What's the difference between while and do...while?**

**Perfect Answer:**

> "The key difference is **when the condition is checked**:
>
> **while loop:** Condition checked **before** execution
>
> - May execute 0 times if condition is initially false
> - Structure: test first, then execute
> - Example: `while (i < 5) { code }`
>
> **do...while loop:** Condition checked **after** execution
>
> - Always executes at least once
> - Structure: execute first, then test
> - Example: `do { code } while (i < 5)`
>
> Practical example:
>
> ```javascript
> let x = 10;
>
> // while: never executes
> while (x < 5) {
>   console.log(x); // doesn't run
> }
>
> // do...while: executes once
> do {
>   console.log(x); // runs once, outputs 10
> } while (x < 5);
> ```
>
> Use do...while when you need at least one execution (like showing a menu before checking user input), and while for everything else."

---

## 5. Break and Continue

### Break Statement

**What it means:**
Immediately terminates the loop and transfers control to the statement following the loop.

**How it works:**

- Exits the innermost loop completely
- Can be used with labels to exit outer loops
- Commonly used in switch statements

**Key Understanding Points:**

- Terminates loop immediately
- Skips remaining iterations
- Exits only the innermost loop (unless labeled)
- Can be used in for, while, do...while, switch

**Use Cases:**

- Exit loop when condition is met
- Stop searching when item is found
- Error conditions or early termination
- Exit switch cases

---

### Continue Statement

**What it means:**
Skips the rest of the current iteration and continues with the next iteration of the loop.

**How it works:**

- Skips remaining code in current iteration
- Jump to next iteration immediately
- Loop condition is re-evaluated

**Key Understanding Points:**

- Skips only current iteration, not entire loop
- Loop continues with next iteration
- Can be used with labels to continue outer loops
- Only works in loops (not switch statements)

**Use Cases:**

- Skip specific values
- Filter during iteration
- Avoid deeply nested if statements

**Interview Question & Perfect Answer:**

**Q: What's the difference between break and continue?**

**Perfect Answer:**

> "Both control loop flow, but in opposite ways:
>
> **break:** Exits the loop completely
>
> - Terminates all remaining iterations
> - Control moves to code after the loop
> - Like saying 'stop looping entirely'
> - Example: Stop searching once item is found
>
> **continue:** Skips current iteration only
>
> - Remaining iterations still execute
> - Jump to next iteration immediately
> - Like saying 'skip this one, continue with next'
> - Example: Skip processing invalid values
>
> Example:
>
> ```javascript
> for (let i = 0; i < 5; i++) {
>   if (i === 2) break;
>   console.log(i);
> }
> // Output: 0, 1 (stops completely)
>
> for (let i = 0; i < 5; i++) {
>   if (i === 2) continue;
>   console.log(i);
> }
> // Output: 0, 1, 3, 4 (skips 2, continues)
> ```
>
> Use break when you want to exit completely (found what you're looking for), use continue when you want to skip specific items but keep processing (filtering during iteration)."

---

## 6. Labeled Statements

### Basic Concept

**What it means:**
Labels provide an identifier for a statement that can be referenced by break or continue to control nested loop flow.

**Structure:**

```javascript
labelName: statement

// Common usage
outerLoop: for (...) {
  for (...) {
    break outerLoop; // breaks out of outer loop
  }
}
```

**How it works:**

- Labels identify statements (usually loops)
- break/continue can reference labels to control specific loops
- Enables breaking out of nested loops
- Less common in modern JavaScript (can often be refactored)

**Key Understanding Points:**

- Any statement can be labeled (not just loops)
- break with label exits the labeled statement
- continue with label jumps to next iteration of labeled loop
- Labels have their own namespace (don't conflict with variables)
- Rarely used in practice (can indicate need for refactoring)

**Interview Question & Perfect Answer:**

**Q: How do labeled statements work? Explain this code:**

```javascript
outerLoop: for (let i = 0; i < 3; i++) {
  for (let j = 0; j < 3; j++) {
    if (i === 1 && j === 1) {
      break outerLoop;
    }
    console.log(i, j);
  }
}
```

**Perfect Answer:**

> "This demonstrates labeled break for exiting nested loops. Let me trace through it:
>
> The label `outerLoop:` identifies the outer for loop. When `i === 1 && j === 1`, `break outerLoop` exits the entire outer loop, not just the inner loop.
>
> Output:
>
> ```
> 0 0
> 0 1
> 0 2
> 1 0
> ```
>
> Without the label, `break` would only exit the inner loop, and the outer loop would continue with `i = 2`.
>
> With the label, when we hit `i=1, j=1`, we completely exit both loops.
>
> This is useful for nested loops where you need to exit multiple levels, but in modern code, it often indicates the logic should be extracted into a function where you can use `return` instead. Labels are rarely used in practice because:
>
> 1. Functions with early returns are clearer
> 2. Array methods like `.find()` or `.some()` handle many use cases
> 3. Labels can make code harder to follow
>
> However, they're valid JavaScript and useful to know for interviews."

---

## 7. Exception Handling (Try/Catch/Finally)

### Basic Concept

**What it means:**
A mechanism to handle runtime errors gracefully without crashing the program, using try/catch/finally blocks.

**Structure:**

```javascript
try {
  // code that might throw an error
} catch (error) {
  // code to handle the error
} finally {
  // code that always executes
}
```

**How it works:**

1. Code in try block executes
2. If an error occurs, control jumps to catch block
3. Error object passed to catch contains error details
4. Finally block always executes (even with return statements)

**Key Understanding Points:**

- **try:** Contains code that might throw errors
- **catch:** Handles errors if they occur
- **finally:** Always executes, regardless of errors or returns
- Can have try/catch, try/finally, or all three
- Errors can be thrown explicitly with `throw`
- Catch block receives error object

**Error Object Properties:**

- `name`: Error type (Error, TypeError, ReferenceError, etc.)
- `message`: Error description
- `stack`: Stack trace (browser-specific)

**When to Use:**

- Handling runtime errors
- Network requests
- JSON parsing
- File operations
- User input validation
- Third-party library calls

**Interview Question & Perfect Answer:**

**Q: Does the finally block execute if there's a return in the try block?**

**Perfect Answer:**

> "Yes, the finally block ALWAYS executes, even with return statements, break/continue, or thrown errors. It's one of the most important characteristics of finally.
>
> Example:
>
> ```javascript
> function test() {
>   try {
>     console.log("try");
>     return "from try";
>   } finally {
>     console.log("finally");
>     // This runs before the function actually returns!
>   }
> }
>
> test();
> // Output:
> // try
> // finally
> // Returns: 'from try'
> ```
>
> The only case where finally won't execute is if the process crashes or exits (like `process.exit()` in Node.js).
>
> This makes finally perfect for cleanup operations like:
>
> - Closing database connections
> - Releasing resources
> - Stopping loading spinners
> - Cleaning up temporary files
>
> Even if try has a return, or catch throws another error, finally still runs before control leaves the try/catch/finally statement."

**Q: What's the difference between these three patterns?**

```javascript
// Pattern 1
try {
} catch (e) {
} finally {
}

// Pattern 2
try {
} catch (e) {}

// Pattern 3
try {
} finally {
}
```

**Perfect Answer:**

> "All three are valid, but serve different purposes:
>
> **Pattern 1: try/catch/finally** - Complete error handling
>
> - Handle errors in catch
> - Guarantee cleanup in finally
> - Most comprehensive approach
> - Use when you need both error handling and guaranteed cleanup
> - Example: Database operations (catch errors, finally close connection)
>
> **Pattern 2: try/catch** - Error handling only
>
> - Handle errors and recover
> - No guaranteed cleanup code
> - Most common pattern
> - Use when cleanup isn't needed or you handle it in catch
> - Example: JSON parsing with fallback value
>
> **Pattern 3: try/finally** - Guaranteed cleanup without handling
>
> - No error handling (errors still propagate)
> - Guarantee cleanup code runs
> - Less common but valid
> - Use when you need cleanup but want errors to propagate up
> - Example: Temporarily changing a state that must be restored
>
> Example of Pattern 3:
>
> ```javascript
> function processWithLock() {
>   acquireLock();
>   try {
>     doWork(); // might throw
>   } finally {
>     releaseLock(); // always runs, even if error
>     // error still propagates to caller
>   }
> }
> ```
>
> The key insight is that finally is about guaranteed execution, not error handling. You can use it with or without catch depending on whether you want to handle errors or let them propagate."

**Q: What happens with multiple return statements?**

```javascript
function test() {
  try {
    return 1;
  } finally {
    return 2;
  }
}
console.log(test());
```

**Perfect Answer:**

> "This returns `2`, not `1`. Here's why:
>
> While finally always executes, if finally contains a return statement, it **overrides** any return from try or catch. The execution flow is:
>
> 1. try executes and prepares to return 1
> 2. finally executes before actually returning
> 3. finally's return 2 replaces try's return 1
> 4. Function returns 2
>
> This is generally considered **bad practice** and should be avoided because:
>
> - It's confusing and unexpected
> - The try's return value is silently overridden
> - Makes code hard to debug
> - ESLint has rules against it
>
> The same thing happens with thrown errors:
>
> ```javascript
> function test() {
>   try {
>     throw new Error("try error");
>   } finally {
>     return "finally return";
>   }
> }
> // Returns 'finally return', error is suppressed!
> ```
>
> **Best practice:** Never put return statements in finally blocks. Use finally only for cleanup operations like closing connections or releasing resources."

---

## üéØ Summary of Key Differences

### Loop Comparison Table

| Loop Type      | Iterates Over         | Returns        | Use Case                     | Can Break Object |
| -------------- | --------------------- | -------------- | ---------------------------- | ---------------- |
| **for**        | Index range           | Index          | Known iterations, need index | ‚ùå               |
| **for...in**   | Enumerable properties | Keys (strings) | Object properties            | ‚ùå               |
| **for...of**   | Iterable values       | Values         | Arrays, Maps, Sets, strings  | ‚ùå               |
| **while**      | While condition true  | -              | Unknown iterations           | ‚ùå               |
| **do...while** | While condition true  | -              | Execute at least once        | ‚ùå               |

### When to Use What

**Use for...of when:**

- Iterating arrays, strings, Maps, Sets
- You need the actual values
- Modern, clean syntax preferred
- Don't need index (or can use `.entries()`)

**Use for...in when:**

- Iterating object properties
- You need property names/keys
- Remember to check `hasOwnProperty()`
- Or better: use `Object.keys()`, `Object.values()`, `Object.entries()`

**Use traditional for when:**

- Need index access
- Complex iteration logic
- Backward iteration
- Multiple counters
- Breaking/continuing based on index

**Use while when:**

- Unknown number of iterations
- Condition-based looping
- May need zero iterations

**Use do...while when:**

- Need at least one iteration
- Menu systems, user prompts
- Rare in practice

---

## üé§ Common Interview Scenarios

### Scenario 1: Nested Loop Exit

**Problem:** Exit nested loops when condition is met.

**Solutions:**

```javascript
// 1. Using labeled break (traditional)
outer: for (let i = 0; i < 5; i++) {
  for (let j = 0; j < 5; j++) {
    if (found) break outer;
  }
}

// 2. Using function with return (modern, preferred)
function search() {
  for (let i = 0; i < 5; i++) {
    for (let j = 0; j < 5; j++) {
      if (found) return; // exits entire function
    }
  }
}

// 3. Using flag variable
let shouldBreak = false;
for (let i = 0; i < 5; i++) {
  for (let j = 0; j < 5; j++) {
    if (found) {
      shouldBreak = true;
      break;
    }
  }
  if (shouldBreak) break;
}
```

**Best Practice:** Extract to function and use return.

---

### Scenario 2: Iterating Objects

**Problem:** Iterate over object properties safely.

**Solutions:**

```javascript
const obj = { a: 1, b: 2, c: 3 };

// ‚ùå AVOID: for...in (includes inherited properties)
for (let key in obj) {
  console.log(key, obj[key]);
}

// ‚úÖ GOOD: Object.keys() with for...of
for (let key of Object.keys(obj)) {
  console.log(key, obj[key]);
}

// ‚úÖ GOOD: Object.entries() for key-value pairs
for (let [key, value] of Object.entries(obj)) {
  console.log(key, value);
}

// ‚úÖ GOOD: Object.values() for just values
for (let value of Object.values(obj)) {
  console.log(value);
}

// ‚úÖ GOOD: forEach on keys
Object.keys(obj).forEach((key) => {
  console.log(key, obj[key]);
});
```

**Best Practice:** Use Object.keys/values/entries with for...of or forEach.

---

### Scenario 3: Error Handling with Async

**Problem:** Handle errors in async operations.

**Solutions:**

```javascript
// With async/await
async function fetchData() {
  try {
    const response = await fetch(url);
    const data = await response.json();
    return data;
  } catch (error) {
    console.error("Fetch failed:", error);
    return null;
  } finally {
    hideLoadingSpinner(); // always runs
  }
}

// With promises
fetch(url)
  .then((response) => response.json())
  .then((data) => processData(data))
  .catch((error) => console.error("Error:", error))
  .finally(() => hideLoadingSpinner());
```

---

## üí° Pro Tips for Interviews

1. **Explain the "why"**: Don't just say "for...of is for arrays" - explain it uses the iterable protocol
2. **Mention trade-offs**: "for...in works but Object.keys() is clearer and doesn't include inherited properties"
3. **Know the edge cases**: typeof null, empty array truthiness, finally with return
4. **Use modern alternatives**: Prefer Object.entries() over for...in, array methods over manual loops
5. **Show defensive coding**: Always check hasOwnProperty with for...in, validate before parsing JSON
6. **Connect to real work**: "I use try/catch with async/await for API calls and always clean up in finally"

---

## üö® Common Mistakes to Avoid

### 1. Using for...in on Arrays

```javascript
// ‚ùå WRONG
const arr = [1, 2, 3];
for (let i in arr) {
  console.log(arr[i]); // i is string "0", "1", "2"
}

// ‚úÖ CORRECT
for (let value of arr) {
  console.log(value);
}
```

### 2. Forgetting Break in Switch

```javascript
// ‚ùå WRONG (falls through)
switch (x) {
  case 1:
    doSomething();
  case 2:
    doSomethingElse(); // executes for case 1 too!
}

// ‚úÖ CORRECT
switch (x) {
  case 1:
    doSomething();
    break;
  case 2:
    doSomethingElse();
    break;
}
```

### 3. Not Using hasOwnProperty with for...in

```javascript
// ‚ùå WRONG
for (let key in obj) {
  console.log(key); // includes inherited properties
}

// ‚úÖ CORRECT
for (let key in obj) {
  if (obj.hasOwnProperty(key)) {
    console.log(key);
  }
}

// ‚úÖ BETTER
for (let key of Object.keys(obj)) {
  console.log(key);
}
```

### 4. Returning in Finally

```javascript
// ‚ùå WRONG (suppresses errors and overrides return values)
function bad() {
  try {
    return 1;
  } finally {
    return 2; // overrides try's return
  }
}

// ‚úÖ CORRECT
function good() {
  try {
    return 1;
  } finally {
    cleanup(); // only cleanup, no return
  }
}
```

---

## üìö Quick Reference

### Control Flow Decision Tree

```
Need to execute code conditionally?
‚îú‚îÄ Simple true/false ‚Üí if/else
‚îú‚îÄ Multiple specific values ‚Üí switch
‚îî‚îÄ Complex conditions ‚Üí if/else if

Need to repeat code?
‚îú‚îÄ Know number of iterations ‚Üí for loop
‚îú‚îÄ Iterate array values ‚Üí for...of
‚îú‚îÄ Iterate object properties ‚Üí Object.keys/values/entries with for...of
‚îú‚îÄ Unknown iterations ‚Üí while
‚îî‚îÄ Execute at least once ‚Üí do...while

Need to handle errors?
‚îú‚îÄ Handle and recover ‚Üí try/catch
‚îú‚îÄ Always cleanup ‚Üí try/finally
‚îî‚îÄ Both ‚Üí try/catch/finally

Need to exit early?
‚îú‚îÄ Exit loop ‚Üí break
‚îú‚îÄ Skip iteration ‚Üí continue
‚îî‚îÄ Exit nested loops ‚Üí labeled break or function return
```

---

**Remember:** Control flow is fundamental to programming logic. Master these concepts, understand their differences, and know when to use each. In interviews, demonstrate understanding of not just how they work, but why you'd choose one over another.
