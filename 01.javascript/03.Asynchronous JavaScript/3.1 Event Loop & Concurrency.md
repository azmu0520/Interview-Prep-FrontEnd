# 3.1 Event Loop & Concurrency - Theoretical Guide

## JavaScript Interview Preparation - Senior Frontend Engineer

---

## üìã Overview

> ‚≠ê‚≠ê‚≠ê **CRITICAL TOPIC** - Appears in 95% of JavaScript interviews

Understanding the Event Loop is fundamental to mastering asynchronous JavaScript. This is one of the most commonly asked topics in senior-level interviews.

---

## 1. Call Stack

### What is the Call Stack?

The **call stack** is a LIFO (Last In, First Out) data structure that keeps track of function execution in JavaScript. When a function is called, it's added (pushed) to the stack. When it returns, it's removed (popped) from the stack.

### Key Characteristics

- **Single-threaded**: JavaScript has only ONE call stack
- **Synchronous execution**: Functions execute one at a time
- **LIFO order**: Last function called is first to complete
- **Stack frames**: Each function call creates a stack frame with local variables
- **Stack overflow**: Too many nested calls cause stack overflow error

### How It Works

```
Call Stack Execution Flow:

1. main() (global execution context)
   ‚îú‚îÄ‚îÄ function1()
   ‚îÇ   ‚îú‚îÄ‚îÄ function2()
   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ function3()  ‚Üê Current execution
   ‚îÇ   ‚îî‚îÄ‚îÄ (function3 completes, pops off)
   ‚îî‚îÄ‚îÄ (function2 completes, pops off)
```

### Stack Frame Contents

Each stack frame contains:

- Function parameters
- Local variables
- Return address (where to go after function completes)
- `this` binding

### Interview Points

**Q: What happens if the call stack gets too deep?**

- **A**: Stack overflow error occurs (typically around 10,000-15,000 nested calls in browsers)

**Q: Can you have multiple call stacks in JavaScript?**

- **A**: No, JavaScript is single-threaded with one call stack. However, Web Workers provide separate threads with their own call stacks.

---

## 2. Synchronous vs Asynchronous Execution

### Synchronous (Blocking) Code

Code that executes sequentially, one operation at a time. Each operation must complete before the next one starts.

**Characteristics:**

- **Predictable order**: Operations execute in written order
- **Blocking**: Long operations freeze the entire program
- **Simple to understand**: Linear flow
- **Can cause performance issues**: UI freezes, unresponsive apps

**Example scenarios:**

- Variable assignments
- Function calls (non-async)
- Loops and conditionals
- Mathematical operations

### Asynchronous (Non-blocking) Code

Code that allows operations to start without waiting for previous operations to complete.

**Characteristics:**

- **Non-blocking**: Long operations don't freeze the program
- **Event-driven**: Operations complete via callbacks/promises
- **Concurrent execution**: Multiple operations in progress
- **More complex**: Need to handle callbacks, promises, or async/await

**Example scenarios:**

- Network requests (fetch, AJAX)
- File I/O operations
- Timers (setTimeout, setInterval)
- User interactions (event handlers)
- Database queries

### Why JavaScript Needs Async

JavaScript runs in single-threaded environments (browsers, Node.js) where:

- **Blocking = frozen UI**: Synchronous operations would freeze the browser
- **I/O is slow**: Network requests, file reads take time
- **User experience**: Apps must remain responsive during operations

### Interview Points

**Q: Is JavaScript synchronous or asynchronous?**

- **A**: JavaScript is **synchronous** by nature (single-threaded, one operation at a time) but provides **asynchronous capabilities** through Web APIs, event loop, and callback queues.

**Q: How does JavaScript achieve non-blocking behavior?**

- **A**: Through the event loop, Web APIs (in browsers) or C++ APIs (in Node.js), and callback queues (task queue and microtask queue).

---

## 3. Event Loop Mechanism

### What is the Event Loop?

The **event loop** is the mechanism that enables JavaScript to perform non-blocking operations despite being single-threaded. It continuously checks the call stack and queues to determine what to execute next.

### Event Loop Components

1. **Call Stack**: Where synchronous code executes
2. **Web APIs** (browser) / C++ APIs (Node.js): Handle async operations
3. **Callback/Task Queue** (Macrotask Queue): Holds callbacks for macrotasks
4. **Microtask Queue**: Holds callbacks for microtasks (higher priority)
5. **Event Loop**: Orchestrates everything

### Event Loop Flow

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  1. Execute all sync code ‚îÇ
‚îÇ     (Call Stack)          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
            ‚îÇ
            ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  2. Execute ALL microtasks‚îÇ
‚îÇ     (Promise callbacks)   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
            ‚îÇ
            ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  3. Execute ONE macrotask ‚îÇ
‚îÇ     (setTimeout callback) ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
            ‚îÇ
            ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  4. Render UI (if browser)‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
            ‚îÇ
            ‚ñº
         Repeat ‚àû
```

### Detailed Event Loop Steps

1. **Check call stack**: Is it empty?
2. **Check microtask queue**: Execute ALL microtasks until empty
3. **Check macrotask queue**: Execute ONE macrotask
4. **Render** (in browsers): Update UI if needed
5. **Repeat**: Go back to step 1

### Critical Rules

- **Rule 1**: Synchronous code always runs first (call stack must be empty)
- **Rule 2**: ALL microtasks run before the next macrotask
- **Rule 3**: Only ONE macrotask runs per event loop cycle
- **Rule 4**: Microtasks can create more microtasks (can cause starvation)
- **Rule 5**: Event loop never stops (infinite loop)

### Interview Points

**Q: Explain the event loop**

- **A**: The event loop is a continuous process that monitors the call stack and queues. When the call stack is empty, it first processes all microtasks (promises), then one macrotask (setTimeout), then repeats. This enables non-blocking async operations in single-threaded JavaScript.

**Q: What's the execution order?**

- **A**: Synchronous code ‚Üí All Microtasks ‚Üí One Macrotask ‚Üí Render ‚Üí Repeat

**Q: Can microtasks block the event loop?**

- **A**: Yes! Since ALL microtasks must complete before the next macrotask, infinite microtasks can starve the event loop and prevent macrotasks from running.

---

## 4. Task Queue (Macrotasks)

### What are Macrotasks?

**Macrotasks** (also called Tasks) are callbacks that are queued for execution after the current script completes and all microtasks are processed.

### Macrotask Sources

- `setTimeout` / `setInterval`
- `setImmediate` (Node.js only)
- I/O operations
- UI rendering
- User interaction events
- `requestAnimationFrame` (browser, technically runs before render)

### How Macrotasks Work

1. Async operation completes (e.g., timer expires)
2. Callback is placed in task queue
3. Event loop checks: call stack empty? microtasks done?
4. Event loop executes ONE macrotask
5. Back to checking microtasks

### setTimeout Behavior

**Important characteristics:**

- **Minimum delay**: NOT exact timing
  - Browsers: 4ms minimum (HTML5 spec)
  - Node.js: 1ms minimum
- **Delay = minimum wait time**, not guaranteed execution time
- **Event loop must be free**: Callback won't run if stack is busy
- **setTimeout(fn, 0)**: Still asynchronous, runs after current script

### setTimeout(fn, 0) - Common Interview Question

`setTimeout(fn, 0)` does NOT execute immediately!

**What it does:**

1. Schedules callback in macrotask queue
2. Waits for call stack to empty
3. Waits for ALL microtasks to complete
4. Then executes in next event loop cycle

**Use cases:**

- Defer execution until after current synchronous code
- Allow UI to update before heavy computation
- Break up long-running tasks

### setInterval Issues

**Problem 1: Can queue up calls**

- If callback takes longer than interval, calls can stack
- Multiple callbacks may execute back-to-back

**Problem 2: Not guaranteed timing**

- Same minimum delay issues as setTimeout
- Can drift over time

**Better alternative**: Recursive setTimeout

```javascript
// Better than setInterval
function recursiveTimer() {
  // Do work
  setTimeout(recursiveTimer, delay); // Schedule next
}
```

### Interview Points

**Q: What's the minimum timeout in browsers?**

- **A**: 4ms according to HTML5 spec, though implementation may vary

**Q: Does setTimeout guarantee exact timing?**

- **A**: No, it's a minimum delay. Actual execution depends on event loop availability.

**Q: Why use setTimeout(fn, 0)?**

- **A**: To defer execution until after current script and microtasks, allowing browser to update or breaking up long tasks.

---

## 5. Microtask Queue

### What are Microtasks?

**Microtasks** are callbacks with **higher priority** than macrotasks. ALL pending microtasks execute before the next macrotask.

### Microtask Sources

- `Promise.then()` / `catch()` / `finally()`
- `queueMicrotask()`
- `MutationObserver` callbacks
- `process.nextTick()` (Node.js - highest priority, runs before other microtasks)

### How Microtasks Work

1. Promise resolves or microtask is queued
2. Callback is placed in microtask queue
3. When call stack empties, event loop processes ALL microtasks
4. Each microtask can queue more microtasks (all executed)
5. Only after microtask queue is empty does next macrotask run

### Microtask vs Macrotask Priority

```
Priority Order:
1. Synchronous code (call stack)
2. Microtasks (ALL of them)
3. Macrotasks (ONE at a time)
4. Render (browser)
```

### Microtask Queue Starvation

**Critical Issue**: Since ALL microtasks must complete before the next macrotask:

```javascript
// ‚ùå This blocks the event loop!
function recursiveMicrotask() {
  Promise.resolve().then(recursiveMicrotask);
}
// Macrotasks will NEVER run!
```

**Why it matters:**

- Can prevent setTimeout callbacks from running
- Can block UI updates in browsers
- Can freeze the application

### Common Microtask Patterns

**Pattern 1: Immediate async execution**

```javascript
// Runs before any setTimeout
queueMicrotask(() => {
  console.log("Runs very soon");
});
```

**Pattern 2: Promise chaining**

```javascript
// All .then() create microtasks
Promise.resolve()
  .then(() => {}) // Microtask 1
  .then(() => {}) // Microtask 2
  .then(() => {}); // Microtask 3
// All run before next macrotask
```

### Interview Points

**Q: What's the difference between microtasks and macrotasks?**

- **A**: Microtasks have higher priority and ALL microtasks execute before the next macrotask. Microtasks come from promises and queueMicrotask, while macrotasks come from setTimeout and I/O operations.

**Q: What executes first: setTimeout(fn, 0) or Promise.resolve().then(fn)?**

- **A**: Promise.then() executes first because microtasks run before macrotasks.

**Q: Can microtasks block the event loop?**

- **A**: Yes, infinite microtasks prevent macrotasks from executing, causing starvation.

---

## 6. Stack vs Heap Memory

### The Stack

**What it stores:**

- Primitive values (numbers, strings, booleans, null, undefined, symbols, bigints)
- Function execution contexts
- Local variables
- References to heap objects

**Characteristics:**

- **LIFO structure**: Last in, first out
- **Fixed size**: Limited memory (varies by browser/environment)
- **Fast access**: Direct memory access
- **Automatic management**: Automatically cleaned when function returns
- **Thread-specific**: Each thread has its own stack

**Stack Frame Contents:**

- Function parameters
- Local primitive values
- Return address
- Reference pointers (point to heap)

### The Heap

**What it stores:**

- Objects
- Arrays
- Functions (they are objects)
- Any reference type

**Characteristics:**

- **Unstructured**: No specific order
- **Larger size**: More memory available than stack
- **Slower access**: Indirect access via references
- **Garbage collected**: Cleaned up by GC when no references remain
- **Shared**: Same heap across execution contexts

### Primitive vs Reference Types

**Primitives (Stack):**

```
let a = 10;
let b = a;  // Copy the VALUE
b = 20;     // Only b changes
// a = 10, b = 20
```

**References (Heap):**

```
let obj1 = { x: 10 };
let obj2 = obj1;  // Copy the REFERENCE
obj2.x = 20;      // Modifies shared object
// obj1.x = 20, obj2.x = 20 (same object!)
```

### Memory Allocation Flow

```
Stack:                    Heap:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê          ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ num: 42     ‚îÇ          ‚îÇ                  ‚îÇ
‚îÇ obj: [ref]‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ { value: 100 }   ‚îÇ
‚îÇ arr: [ref]‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ [1, 2, 3]        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò          ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Garbage Collection

**When objects are collected:**

- No more references point to the object
- Object becomes unreachable
- GC runs periodically to free memory

**Cannot be collected:**

- Object has references
- In closure scope (still accessible)
- Global variables (always reachable)

### Interview Points

**Q: What's the difference between stack and heap?**

- **A**: Stack stores primitive values and references with fast, automatic memory management. Heap stores objects and reference types with slower access and garbage collection.

**Q: Why do primitives behave differently from objects?**

- **A**: Primitives are stored by value on the stack (copy the value), while objects are stored on the heap with references on the stack (copy the reference).

**Q: What causes memory leaks in JavaScript?**

- **A**: Unintended references preventing garbage collection (forgotten event listeners, closures holding large objects, global variables, timers not cleared).

---

## 7. Blocking vs Non-Blocking Code

### What is Blocking Code?

Code that **prevents the event loop** from continuing until the operation completes.

**Characteristics:**

- Synchronous operations
- Holds the call stack
- Freezes UI (in browsers)
- No other code can execute
- Timers don't fire
- Promises don't resolve

**Common blocking operations:**

- Infinite loops
- Long synchronous computations
- Synchronous I/O (Node.js)
- Heavy DOM manipulation
- Large data processing

**Example blocking scenarios:**

```javascript
// ‚ùå Blocks for 3 seconds
while (Date.now() < Date.now() + 3000) {}

// ‚ùå Blocks with heavy computation
for (let i = 0; i < 1000000000; i++) {
  // Heavy work
}

// ‚ùå Synchronous file read (Node.js)
const data = fs.readFileSync("huge-file.txt");
```

### What is Non-Blocking Code?

Code that **allows the event loop to continue** while operations complete.

**Characteristics:**

- Asynchronous operations
- Uses callbacks, promises, or async/await
- Doesn't hold call stack
- UI remains responsive
- Other code can execute
- Better performance

**Common non-blocking operations:**

- Async I/O (fetch, file operations)
- Timers (setTimeout, setInterval)
- Promises
- Event handlers

**Example non-blocking approaches:**

```javascript
// ‚úÖ Non-blocking network request
fetch("url").then((data) => process(data));

// ‚úÖ Non-blocking timer
setTimeout(() => heavyWork(), 0);

// ‚úÖ Breaking up work
function processChunks(data) {
  const chunk = data.slice(0, 100);
  process(chunk);
  if (data.length > 100) {
    setTimeout(() => processChunks(data.slice(100)), 0);
  }
}
```

### Impact on User Experience

**Blocking code effects (browsers):**

- Frozen UI, can't click or scroll
- Browser "Not Responding" warning
- Poor user experience
- Can't cancel operation

**Non-blocking code benefits:**

- Smooth, responsive UI
- Can show progress indicators
- User can interact during operations
- Better perceived performance

### How to Avoid Blocking

**Strategy 1: Use async operations**

- Fetch instead of sync XHR
- Async file operations (Node.js)
- Web Workers for heavy computation

**Strategy 2: Break up long tasks**

- Split work into smaller chunks
- Use setTimeout(fn, 0) between chunks
- Allow event loop to process other events

**Strategy 3: Offload to Web Workers**

- Separate thread for heavy computation
- Doesn't block main thread
- Message-based communication

**Strategy 4: Optimize algorithms**

- Use efficient data structures
- Avoid unnecessary loops
- Cache computed results

### Interview Points

**Q: What's the difference between blocking and non-blocking code?**

- **A**: Blocking code holds the call stack and prevents the event loop from processing other operations, while non-blocking code releases control and allows other operations to execute via async mechanisms.

**Q: How do you prevent blocking the event loop?**

- **A**: Use async operations (fetch, promises), break long tasks into chunks with setTimeout, offload heavy work to Web Workers, and optimize algorithms.

**Q: What happens when JavaScript code blocks for too long?**

- **A**: In browsers, the UI freezes and users see "page unresponsive" warnings. No timers fire, no promises resolve, and no events are processed.

---

## 8. Concurrency Model

### JavaScript's Concurrency Model

**Run-to-completion**: Each message (task) runs completely before processing the next message. No preemption - functions can't be interrupted mid-execution.

**Single-threaded**: JavaScript has ONE call stack and executes one piece of code at a time on the main thread.

**Event-driven**: Async operations complete and trigger callbacks via the event loop.

**Non-blocking I/O**: I/O operations don't block the main thread.

### Concurrency vs Parallelism

**Concurrency** (JavaScript):

- Multiple operations **in progress** (not necessarily executing simultaneously)
- Interleaved execution
- One thread switching between tasks
- Managed by event loop
- Example: Handling multiple async requests

**Parallelism** (Not JavaScript):

- Multiple operations **executing simultaneously**
- True simultaneous execution
- Multiple threads/cores
- Not available in JavaScript main thread
- Example: Web Workers (separate threads)

### How JavaScript Achieves Concurrency

**1. Event Loop**

- Orchestrates task execution
- Manages queues
- Enables non-blocking operations

**2. Web APIs (Browser)**

- Handle async operations outside JavaScript
- setTimeout, fetch, DOM events
- Run in separate threads
- Notify event loop when complete

**3. Callback Queues**

- Store callbacks for completed operations
- Separate queues for different priorities
- Event loop processes queues

**4. Non-blocking Design**

- Operations don't wait
- Use callbacks/promises
- Event-driven architecture

### Concurrency Patterns

**Pattern 1: Parallel async operations**

```javascript
// Start multiple operations concurrently
Promise.all([fetch("url1"), fetch("url2"), fetch("url3")]);
// All run concurrently, not sequentially
```

**Pattern 2: Sequential async operations**

```javascript
// Run one after another
async function sequential() {
  const result1 = await fetch("url1");
  const result2 = await fetch("url2"); // Waits for result1
  const result3 = await fetch("url3"); // Waits for result2
}
```

**Pattern 3: Task coordination**

```javascript
// Coordinate multiple async tasks
Promise.race([fetch("url1"), timeout(5000)]).then(/* fastest wins */);
```

### Limitations of JavaScript Concurrency

**Cannot do:**

- True parallel computation on main thread
- Multi-threaded shared memory access
- Preemptive multitasking
- Interrupt running functions

**Can do with Web Workers:**

- Parallel computation in separate threads
- Heavy processing without blocking UI
- Message-based communication
- No shared memory (structured cloning)

### Interview Points

**Q: Is JavaScript single-threaded or multi-threaded?**

- **A**: JavaScript is single-threaded (one call stack) but achieves concurrency through the event loop, Web APIs, and non-blocking I/O. Web Workers provide separate threads for parallel computation.

**Q: How does JavaScript handle multiple async operations?**

- **A**: Through concurrency (not parallelism). Operations start concurrently via Web APIs, and the event loop processes their callbacks when complete, creating the illusion of simultaneous execution.

**Q: What's the difference between concurrency and parallelism?**

- **A**: Concurrency is about managing multiple tasks in progress (interleaved), while parallelism is about executing tasks simultaneously. JavaScript has concurrency but not parallelism on the main thread.

---

## 9. Common Interview Questions & Answers

### Question 1: Execution Order

**Question**: What's the output order?

```javascript
console.log("1");
setTimeout(() => console.log("2"), 0);
Promise.resolve().then(() => console.log("3"));
console.log("4");
```

**Answer**: `1, 4, 3, 2`

**Explanation**:

1. Sync code first: `1`, `4`
2. All microtasks (promises): `3`
3. One macrotask (setTimeout): `2`

### Question 2: setTimeout Minimum Delay

**Question**: Why doesn't `setTimeout(fn, 0)` execute immediately?

**Answer**:

- It's still asynchronous and queued as a macrotask
- Must wait for call stack to empty
- Must wait for ALL microtasks to complete
- Minimum delay (4ms in browsers)
- Then executes in next event loop cycle

### Question 3: Microtask Starvation

**Question**: Can promises prevent setTimeout from running?

**Answer**: Yes! Since ALL microtasks must complete before the next macrotask:

```javascript
function infiniteMicrotasks() {
  Promise.resolve().then(infiniteMicrotasks);
}
infiniteMicrotasks(); // Blocks all macrotasks forever!
```

### Question 4: Loop with Closures

**Question**: Why does this print 5, 5, 5, 5, 5?

```javascript
for (var i = 0; i < 5; i++) {
  setTimeout(() => console.log(i), 0);
}
```

**Answer**:

- `var` has function scope (no block scope)
- All callbacks share the same `i` variable
- By the time callbacks run, loop finished and `i === 5`
- **Fix**: Use `let` (block scope) or IIFE

### Question 5: Promise vs setTimeout

**Question**: Which executes first?

```javascript
setTimeout(() => console.log("A"), 0);
Promise.resolve().then(() => console.log("B"));
```

**Answer**: `B` then `A`

**Explanation**:

- Promises create microtasks (higher priority)
- setTimeout creates macrotasks (lower priority)
- All microtasks run before next macrotask

### Question 6: Event Loop Blocking

**Question**: What happens when the call stack is blocked?

**Answer**:

- No timers can fire
- No promises can resolve
- No events are processed
- UI is frozen (browsers)
- "Not responding" warnings
- Poor user experience

**Prevention**:

- Break work into chunks
- Use Web Workers
- Make operations async
- Optimize algorithms

### Question 7: Call Stack Overflow

**Question**: What causes stack overflow?

**Answer**:

- Too many nested function calls
- Deep recursion without base case
- Typical limit: 10,000-15,000 calls
- Each call adds a stack frame
- Stack has fixed size

**Example**:

```javascript
function recursive() {
  recursive(); // No base case!
}
recursive(); // Stack overflow!
```

### Question 8: Memory Management

**Question**: How does JavaScript manage memory?

**Answer**:

- **Stack**: Automatic, LIFO, for primitives and execution contexts
- **Heap**: Garbage collected, for objects and reference types
- **GC**: Removes objects with no references
- **Leaks**: Unintended references prevent collection
- **Common leaks**: Forgotten event listeners, global variables, closures

---

## 10. Critical Concepts Summary

### Must Know for Interviews

**1. Event Loop Flow**

```
Sync Code ‚Üí All Microtasks ‚Üí One Macrotask ‚Üí Render ‚Üí Repeat
```

**2. Priority Order**

```
Call Stack > Microtasks > Macrotasks
```

**3. Microtask Sources**

- Promise.then/catch/finally
- queueMicrotask()
- MutationObserver
- process.nextTick() (Node.js)

**4. Macrotask Sources**

- setTimeout / setInterval
- setImmediate (Node.js)
- I/O operations
- UI events

**5. Key Rules**

- JavaScript is single-threaded
- Event loop enables concurrency
- Microtasks run before macrotasks
- setTimeout is minimum delay, not exact
- Blocking code freezes everything
- Stack stores primitives, heap stores objects

**6. Common Pitfalls**

- Assuming setTimeout(fn, 0) is immediate
- Blocking event loop with long operations
- Not understanding microtask priority
- var in setTimeout loops (use let)
- Memory leaks from uncleaned timers

---

## 11. Interview Preparation Tips

### What Interviewers Look For

1. **Understanding**: Can you explain the event loop clearly?
2. **Practical knowledge**: Can you predict execution order?
3. **Problem-solving**: Can you debug async issues?
4. **Best practices**: Do you know how to write non-blocking code?
5. **Trade-offs**: Do you understand microtask vs macrotask?

### How to Explain Event Loop

**Simple explanation**: "JavaScript is single-threaded with one call stack. The event loop continuously checks if the stack is empty, then processes all microtasks (like promises), then one macrotask (like setTimeout), then repeats. This enables non-blocking async operations despite being single-threaded."

**Detailed explanation**: Walk through the components (call stack, Web APIs, queues) and explain the flow step by step with an example.

### Practice Questions

1. Predict output order for mixed sync/async code
2. Explain why certain code blocks the event loop
3. Compare microtasks vs macrotasks with examples
4. Debug issues with closures in setTimeout loops
5. Optimize blocking code to be non-blocking
6. Explain memory management (stack vs heap)

### Red Flags to Avoid

- ‚ùå Saying JavaScript is multi-threaded
- ‚ùå Confusing concurrency with parallelism
- ‚ùå Not knowing microtask priority
- ‚ùå Thinking setTimeout is accurate timing
- ‚ùå Not understanding blocking vs non-blocking
- ‚ùå Unclear about stack vs heap memory

---

## 12. Additional Resources

### Key Concepts to Study

- Visualize event loop with loupe tool
- Practice with execution order problems
- Study call stack traces in DevTools
- Understand promise microtask timing
- Learn Web Worker usage for parallelism

### Related Topics

- Promises (detailed promise mechanism)
- Async/await (built on promises and event loop)
- Web Workers (true parallelism)
- Performance optimization (avoiding blocking)
- Memory management (garbage collection)

---

**Last Updated**: January 2026
**Target Role**: Senior Frontend Engineer
**Focus**: Event Loop & Concurrency Deep Dive
