# Promises - Theoretical Deep Dive

### JavaScript Interview Preparation for Senior Frontend Engineer

---

## ðŸŽ¯ Key Concepts

### What are Promises?

A Promise is an object representing the eventual completion (or failure) of an asynchronous operation and its resulting value. Introduced in ES6 (ES2015), Promises provide a cleaner, more powerful alternative to callbacks for handling asynchronous code, solving callback hell and enabling better error handling.

**Topics Covered:**

- Promise states (pending, fulfilled, rejected)
- Promise constructor
- then, catch, finally methods
- Promise chaining
- Error propagation
- Promise.all, Promise.race, Promise.allSettled, Promise.any
- Creating custom promises
- Promisification

---

## 1. Promise States

### Basic Concept

**What it means:**
A Promise is always in one of three states: pending (initial), fulfilled (completed successfully), or rejected (failed). A Promise can only transition onceâ€”from pending to either fulfilled or rejected. Once settled (fulfilled or rejected), it's immutable.

**The Three States:**

```javascript
// 1. PENDING - Initial state, neither fulfilled nor rejected
const promise = new Promise((resolve, reject) => {
  // Async operation in progress
});

// 2. FULFILLED - Operation completed successfully
const promise = Promise.resolve("Success!");

// 3. REJECTED - Operation failed
const promise = Promise.reject(new Error("Failed!"));
```

**State Transitions:**

```
        PENDING
           |
           |
    +------+------+
    |             |
    v             v
FULFILLED     REJECTED
(immutable)   (immutable)
```

**Key Understanding Points:**

- Promises start in pending state
- Can only transition once (pending â†’ fulfilled OR pending â†’ rejected)
- Once settled (fulfilled/rejected), state cannot change
- A settled Promise is immutable
- Fulfilled Promise has a value
- Rejected Promise has a reason (error)
- State is internalâ€”cannot be directly accessed

**Why This Matters:**

- Guarantees Promise resolves/rejects only once
- Prevents callbacks from being called multiple times
- Makes async operations more predictable
- Immutability after settlement ensures consistency
- Foundation for understanding Promise behavior

**Interview Question & Perfect Answer:**

**Q: What are the three states of a Promise? Can a Promise change state multiple times?**

**Perfect Answer:**

> "A Promise has three states: pending, fulfilled, and rejected. A Promise can only transition onceâ€”from pending to either fulfilled or rejected. Once settled, it's immutable and cannot change state again.
>
> **The Three States:**
>
> **1. Pending (Initial State):**
>
> ```javascript
> const promise = new Promise((resolve, reject) => {
>   // Async operation in progress
>   setTimeout(() => {
>     resolve("Done"); // Will transition to fulfilled
>   }, 1000);
> });
>
> console.log(promise); // Promise { <pending> }
> ```
>
> - Starting state of all Promises
> - Operation is in progress
> - Not yet settled
> - Will eventually become fulfilled or rejected
>
> **2. Fulfilled (Resolved Successfully):**
>
> ```javascript
> const promise = Promise.resolve("Success!");
> console.log(promise); // Promise { 'Success!' }
>
> // Or via constructor
> const promise2 = new Promise((resolve, reject) => {
>   resolve("Success!"); // Transition to fulfilled
> });
> ```
>
> - Operation completed successfully
> - Has a value (the resolution value)
> - Immutableâ€”cannot change anymore
> - `.then()` handlers will be called with the value
>
> **3. Rejected (Failed):**
>
> ```javascript
> const promise = Promise.reject(new Error("Failed!"));
> console.log(promise); // Promise { <rejected> Error: Failed! }
>
> // Or via constructor
> const promise2 = new Promise((resolve, reject) => {
>   reject(new Error("Failed!")); // Transition to rejected
> });
> ```
>
> - Operation failed
> - Has a reason (typically an Error object)
> - Immutableâ€”cannot change anymore
> - `.catch()` handlers will be called with the reason
>
> **State Transition Rules:**
>
> **Rule 1: One-Way Transition**
>
> ```javascript
> const promise = new Promise((resolve, reject) => {
>   resolve("First");
>   resolve("Second"); // Ignored! Already fulfilled
>   reject("Error"); // Ignored! Already fulfilled
> });
>
> promise.then((value) => console.log(value)); // 'First'
> // Only the first resolution counts
> ```
>
> **Rule 2: Immutable After Settlement**
>
> ```javascript
> const promise = Promise.resolve("Value");
>
> // Cannot change to rejected
> // Cannot change value
> // The Promise is frozen in fulfilled state
>
> promise.then((value) => console.log(value)); // Always 'Value'
> promise.then((value) => console.log(value)); // Always 'Value'
> // Same value every time
> ```
>
> **Rule 3: Cannot Go Back to Pending**
>
> ```javascript
> // Once settled, cannot become pending again
> const promise = new Promise((resolve) => {
>   resolve("Done");
>   // Cannot make it pending again
> });
> ```
>
> **Visual State Machine:**
>
> ```
> NEW PROMISE
>     |
>     v
> [PENDING] â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
>     |                       |
>     | resolve()        reject()
>     v                       v
> [FULFILLED] â†â”€â”€â”€â”€â”€â”€Xâ”€â”€â†’ [REJECTED]
>  (immutable)          (immutable)
>     |                       |
>     v                       v
> .then() called        .catch() called
> ```
>
> **Practical Example:**
>
> ```javascript
> function fetchUser(id) {
>   return new Promise((resolve, reject) => {
>     // State: pending
>
>     fetch(`/api/users/${id}`)
>       .then((response) => {
>         if (response.ok) {
>           return response.json();
>         }
>         throw new Error("User not found");
>       })
>       .then((user) => {
>         resolve(user); // State: fulfilled
>       })
>       .catch((error) => {
>         reject(error); // State: rejected
>       });
>   });
> }
>
> const userPromise = fetchUser(123);
> // State: pending during fetch
>
> userPromise.then((user) => {
>   console.log("User:", user);
>   // If fulfilled, this runs
> });
>
> userPromise.catch((error) => {
>   console.error("Error:", error);
>   // If rejected, this runs
> });
> ```
>
> **Why Immutability Matters:**
>
> ```javascript
> // With callbacks - can be called multiple times (bug!)
> function unreliableAsync(callback) {
>   callback("First call");
>   callback("Second call"); // Bug: called twice!
> }
>
> // With Promises - guaranteed single resolution
> function reliableAsync() {
>   return new Promise((resolve) => {
>     resolve("First call");
>     resolve("Second call"); // Ignored!
>   });
> }
>
> reliableAsync().then((value) => {
>   console.log(value); // 'First call' - only once!
> });
> ```
>
> **Checking Promise State (Indirectly):**
>
> ```javascript
> // Cannot directly access state, but can check behavior
> const promise = Promise.resolve("value");
>
> promise.then(
>   (value) => console.log("Fulfilled:", value),
>   (reason) => console.log("Rejected:", reason)
> );
>
> // Or use Promise.race trick
> Promise.race([promise, Promise.resolve("default")]).then((value) =>
>   console.log("Result:", value)
> );
> ```
>
> **Common Misconceptions:**
>
> **Misconception 1: "Resolved" vs "Fulfilled"**
>
> ```javascript
> // "Resolved" is often used loosely to mean fulfilled
> // But technically, "resolved" means settled (fulfilled OR rejected)
>
> const fulfilled = Promise.resolve("value"); // Fulfilled
> const rejected = Promise.reject("error"); // Also "resolved" (settled)
>
> // Prefer "fulfilled" and "rejected" for clarity
> ```
>
> **Misconception 2: Multiple Settlements**
>
> ```javascript
> // This doesn't create two Promises
> new Promise((resolve, reject) => {
>   if (condition) {
>     resolve("A"); // Settles here
>   }
>   resolve("B"); // Never executes if first ran
> });
>
> // Both branches should have return or else
> new Promise((resolve, reject) => {
>   if (condition) {
>     return resolve("A"); // Exit after settling
>   }
>   resolve("B"); // Only if condition false
> });
> ```
>
> **Key Takeaways:**
>
> 1. **Three states:** pending â†’ fulfilled OR rejected
> 2. **One transition:** Cannot change state twice
> 3. **Immutable:** Once settled, frozen forever
> 4. **Predictable:** Always resolves/rejects exactly once
> 5. **Guaranteed:** No multiple callbacks like with traditional callbacks
>
> Understanding Promise states is fundamental to working with asynchronous JavaScript. The immutability guarantee is what makes Promises more reliable than callbacks and forms the foundation for all Promise behavior."

**Q: What's the difference between "resolved" and "fulfilled"?**

**Perfect Answer:**

> "This is a common source of confusion! In casual usage, 'resolved' and 'fulfilled' are often used interchangeably, but technically they have different meanings:
>
> **Fulfilled:**
>
> - One of the three Promise states (pending, fulfilled, rejected)
> - Means the Promise completed successfully
> - Has a value
> - Immutable
>
> **Resolved:**
>
> - Not a state, but a condition
> - Means the Promise is settled (either fulfilled OR rejected)
> - A resolved Promise cannot become pending again
> - Sometimes used loosely to mean fulfilled
>
> **Technically:**
>
> ```javascript
> // Both of these are "resolved" (settled)
> const fulfilled = Promise.resolve("value"); // Fulfilled (resolved to value)
> const rejected = Promise.reject("error"); // Rejected (resolved to rejection)
>
> // Only this is pending (not resolved)
> const pending = new Promise(() => {});
> ```
>
> **Why It Matters:**
>
> ```javascript
> // Promise.resolve() doesn't always create fulfilled Promise
> const promise1 = Promise.resolve("value");
> // State: fulfilled
>
> const promise2 = Promise.resolve(Promise.reject("error"));
> // State: rejected (!)
> // "Resolved" to a rejection
> ```
>
> **Best Practice:**
> Use precise terms:
>
> - **Pending** - not yet settled
> - **Fulfilled** - completed successfully
> - **Rejected** - failed
> - **Settled** - fulfilled or rejected (not pending)
>
> Avoid 'resolved' in technical discussionsâ€”use 'fulfilled' for success, 'settled' for completed (either way)."

---

## 2. Promise Constructor

### Basic Concept

**What it means:**
The Promise constructor creates a new Promise object. It takes an executor function that receives two functions as parameters: `resolve` (to fulfill the Promise) and `reject` (to reject it). The executor runs immediately when the Promise is created.

**Structure:**

```javascript
const promise = new Promise((resolve, reject) => {
  // Executor function runs immediately

  // Perform async operation
  if (success) {
    resolve(value); // Fulfill the Promise
  } else {
    reject(error); // Reject the Promise
  }
});
```

**Key Understanding Points:**

- Executor function runs synchronously (immediately)
- Receives `resolve` and `reject` callbacks
- Call `resolve(value)` to fulfill
- Call `reject(reason)` to reject
- Should call one or the other, not both
- Throwing in executor automatically rejects
- Only first call to resolve/reject matters

**Interview Question & Perfect Answer:**

**Q: How do you create a Promise? Explain the Promise constructor.**

**Perfect Answer:**

> "You create a Promise using the `new Promise()` constructor, which takes an executor function as its argument. The executor receives two functionsâ€”`resolve` and `reject`â€”which you call to settle the Promise.
>
> **Basic Syntax:**
>
> ```javascript
> const promise = new Promise((resolve, reject) => {
>   // Executor function - runs immediately!
>
>   // Perform async operation
>   asyncOperation((error, result) => {
>     if (error) {
>       reject(error); // Reject on failure
>     } else {
>       resolve(result); // Fulfill on success
>     }
>   });
> });
> ```
>
> **Key Characteristics:**
>
> **1. Executor Runs Immediately:**
>
> ```javascript
> console.log("1");
>
> const promise = new Promise((resolve, reject) => {
>   console.log("2"); // Runs immediately!
>   resolve("3");
> });
>
> console.log("4");
>
> promise.then((value) => console.log(value));
>
> // Output: 1, 2, 4, 3
> // Executor is synchronous, .then() is async
> ```
>
> **2. Resolve vs Reject:**
>
> ```javascript
> // Resolve - fulfills the Promise
> const success = new Promise((resolve, reject) => {
>   resolve("Success value");
> });
>
> // Reject - rejects the Promise
> const failure = new Promise((resolve, reject) => {
>   reject(new Error("Failure reason"));
> });
>
> // Should call one or the other
> const mixed = new Promise((resolve, reject) => {
>   if (condition) {
>     resolve("Success");
>   } else {
>     reject(new Error("Failed"));
>   }
> });
> ```
>
> **3. Automatic Error Handling:**
>
> ```javascript
> // Throwing in executor automatically rejects
> const promise = new Promise((resolve, reject) => {
>   throw new Error("Oops!"); // Same as reject(new Error('Oops!'))
> });
>
> promise.catch((error) => {
>   console.error(error); // Error: Oops!
> });
>
> // This also rejects
> const promise2 = new Promise((resolve, reject) => {
>   JSON.parse("invalid json"); // Throws SyntaxError
> });
> ```
>
> **4. Only First Settlement Counts:**
>
> ```javascript
> const promise = new Promise((resolve, reject) => {
>   resolve("First");
>   resolve("Second"); // Ignored
>   reject("Error"); // Ignored
> });
>
> promise.then((value) => console.log(value)); // 'First'
> ```
>
> **Real-World Examples:**
>
> **Example 1: Wrapping setTimeout:**
>
> ```javascript
> function delay(ms) {
>   return new Promise((resolve) => {
>     setTimeout(() => {
>       resolve(); // Fulfill after delay
>     }, ms);
>   });
> }
>
> // Usage
> delay(1000).then(() => {
>   console.log("1 second passed");
> });
> ```
>
> **Example 2: Wrapping Callback API:**
>
> ```javascript
> function readFilePromise(path) {
>   return new Promise((resolve, reject) => {
>     fs.readFile(path, "utf8", (error, data) => {
>       if (error) {
>         reject(error); // Reject on error
>       } else {
>         resolve(data); // Fulfill with data
>       }
>     });
>   });
> }
>
> // Usage
> readFilePromise("file.txt")
>   .then((data) => console.log(data))
>   .catch((error) => console.error(error));
> ```
>
> **Example 3: Conditional Resolution:**
>
> ```javascript
> function validateUser(user) {
>   return new Promise((resolve, reject) => {
>     if (!user) {
>       reject(new Error("User required"));
>     } else if (!user.email) {
>       reject(new Error("Email required"));
>     } else if (!isValidEmail(user.email)) {
>       reject(new Error("Invalid email"));
>     } else {
>       resolve(user); // All validations passed
>     }
>   });
> }
> ```
>
> **Example 4: Immediate Resolution:**
>
> ```javascript
> // Sometimes you have the value immediately
> function getCachedData(key) {
>   return new Promise((resolve, reject) => {
>     const cached = cache.get(key);
>     if (cached) {
>       resolve(cached); // Immediate resolution
>     } else {
>       // Fetch from API
>       fetchFromAPI(key)
>         .then((data) => resolve(data))
>         .catch((error) => reject(error));
>     }
>   });
> }
> ```
>
> **Common Patterns:**
>
> **Pattern 1: Promisifying Callbacks:**
>
> ```javascript
> function promisify(callbackFn) {
>   return function (...args) {
>     return new Promise((resolve, reject) => {
>       callbackFn(...args, (error, result) => {
>         if (error) {
>           reject(error);
>         } else {
>           resolve(result);
>         }
>       });
>     });
>   };
> }
>
> // Usage
> const readFilePromise = promisify(fs.readFile);
> ```
>
> **Pattern 2: Timeout Wrapper:**
>
> ```javascript
> function withTimeout(promise, ms) {
>   return new Promise((resolve, reject) => {
>     const timer = setTimeout(() => {
>       reject(new Error("Timeout"));
>     }, ms);
>
>     promise
>       .then((value) => {
>         clearTimeout(timer);
>         resolve(value);
>       })
>       .catch((error) => {
>         clearTimeout(timer);
>         reject(error);
>       });
>   });
> }
>
> // Usage
> withTimeout(fetch("/api/data"), 5000)
>   .then((data) => console.log(data))
>   .catch((error) => console.error(error));
> ```
>
> **Pattern 3: Retry Logic:**
>
> ```javascript
> function retry(fn, maxAttempts = 3) {
>   return new Promise((resolve, reject) => {
>     let attempts = 0;
>
>     function attempt() {
>       attempts++;
>       fn()
>         .then(resolve)
>         .catch((error) => {
>           if (attempts >= maxAttempts) {
>             reject(error);
>           } else {
>             console.log(`Retry ${attempts}/${maxAttempts}`);
>             setTimeout(attempt, 1000 * attempts);
>           }
>         });
>     }
>
>     attempt();
>   });
> }
> ```
>
> **Common Mistakes:**
>
> **Mistake 1: Not Returning Promise:**
>
> ```javascript
> // âŒ WRONG - function doesn't return Promise
> function getData() {
>   new Promise((resolve) => {
>     resolve("data");
>   });
> }
>
> // âœ… CORRECT
> function getData() {
>   return new Promise((resolve) => {
>     resolve("data");
>   });
> }
> ```
>
> **Mistake 2: Forgetting to Call Resolve/Reject:**
>
> ```javascript
> // âŒ WRONG - Promise never settles
> const promise = new Promise((resolve, reject) => {
>   const data = fetchData();
>   // Forgot to call resolve!
> });
>
> // âœ… CORRECT
> const promise = new Promise((resolve, reject) => {
>   const data = fetchData();
>   resolve(data);
> });
> ```
>
> **Mistake 3: Not Handling Errors:**
>
> ```javascript
> // âŒ WRONG - errors not caught
> const promise = new Promise((resolve, reject) => {
>   const data = JSON.parse(invalidJSON); // Throws!
>   // Should wrap in try/catch or let it auto-reject
> });
>
> // âœ… CORRECT - explicit error handling
> const promise = new Promise((resolve, reject) => {
>   try {
>     const data = JSON.parse(jsonString);
>     resolve(data);
>   } catch (error) {
>     reject(error);
>   }
> });
> ```
>
> **When to Use Promise Constructor:**
>
> - Wrapping callback-based APIs
> - Creating custom async operations
> - Adding timeout/retry logic
> - Combining multiple async sources
> - When you need manual control over resolution
>
> **When NOT to Use:**
>
> - Wrapping existing Promises (just return them)
> - When Promise.resolve/reject is simpler
> - When async/await is clearer
>
> The Promise constructor is the foundation for creating custom async operations, especially when converting callback-based code to Promises. Understanding how resolve and reject work is essential for creating reliable async code."

---

## 3. Then, Catch, Finally Methods

### Basic Concept

**What it means:**
`.then()`, `.catch()`, and `.finally()` are methods on Promise objects that let you register callbacks to run when the Promise settles. They're the primary way to consume Promise values and handle errors.

**Structure:**

```javascript
promise
  .then((value) => {
    // Runs if Promise fulfilled
    return processedValue;
  })
  .catch((error) => {
    // Runs if Promise rejected
    return fallbackValue;
  })
  .finally(() => {
    // Always runs after settlement
    // Cannot modify value/error
  });
```

**Method Signatures:**

```javascript
// .then() - handles success (and optionally failure)
promise.then(onFulfilled, onRejected);

// .catch() - handles rejection (sugar for .then(null, onRejected))
promise.catch(onRejected);

// .finally() - runs regardless of outcome
promise.finally(onFinally);
```

**Key Understanding Points:**

- All three methods return new Promises (chainable)
- `.then()` can take one or two callbacks
- `.catch()` is syntactic sugar for `.then(null, onRejected)`
- `.finally()` callback receives no arguments
- Handlers run asynchronously (microtask queue)
- Each creates a new Promise in the chain

**Interview Question & Perfect Answer:**

**Q: Explain .then(), .catch(), and .finally(). How do they differ?**

**Perfect Answer:**

> "`.then()`, `.catch()`, and `.finally()` are the three methods used to handle Promise results. Each returns a new Promise, enabling chaining, but they serve different purposes.
>
> **1. .then() - Handle Success (and Failure):**
>
> Registers callbacks for fulfilled and/or rejected states.
>
> ```javascript
> promise.then(
>   (value) => {
>     // onFulfilled - runs if Promise fulfilled
>     console.log("Success:", value);
>     return value * 2;
>   },
>   (error) => {
>     // onRejected - runs if Promise rejected (optional)
>     console.error("Error:", error);
>     return fallbackValue;
>   }
> );
>
> // Usually just handle success
> promise.then((value) => {
>   console.log("Success:", value);
>   return processedValue;
> });
> ```
>
> **Key Characteristics:**
>
> - Returns a new Promise
> - Can take one or two callbacks
> - If callback returns value, new Promise fulfilled with that value
> - If callback returns Promise, new Promise follows that Promise
> - If callback throws, new Promise is rejected
>
> ```javascript
> Promise.resolve(5)
>   .then((value) => {
>     console.log(value); // 5
>     return value * 2; // Returns 10
>   })
>   .then((value) => {
>     console.log(value); // 10
>     return value + 3; // Returns 13
>   })
>   .then((value) => {
>     console.log(value); // 13
>   });
> ```
>
> **2. .catch() - Handle Rejection:**
>
> Registers callback specifically for rejected state. Syntactic sugar for `.then(null, onRejected)`.
>
> ```javascript
> promise.catch((error) => {
>   // Runs if Promise rejected
>   console.error("Error:", error);
>   return fallbackValue; // Can recover
> });
>
> // Equivalent to:
> promise.then(null, (error) => {
>   console.error("Error:", error);
>   return fallbackValue;
> });
> ```
>
> **Key Characteristics:**
>
> - Returns new Promise
> - Catches rejections from earlier in chain
> - Can recover by returning value (fulfilled Promise)
> - If throws, propagates rejection
> - More readable than second `.then()` parameter
>
> ```javascript
> Promise.reject("Error!")
>   .catch((error) => {
>     console.error("Caught:", error); // 'Error!'
>     return "Recovered"; // Recovery!
>   })
>   .then((value) => {
>     console.log(value); // 'Recovered'
>   });
> ```
>
> **3. .finally() - Always Runs:**
>
> Registers callback that runs after settlement, regardless of outcome.
>
> ```javascript
> promise.finally(() => {
>   // Runs whether Promise fulfilled or rejected
>   // No arguments passed
>   cleanup();
> });
> ```
>
> **Key Characteristics:**
>
> - Returns new Promise
> - Runs after fulfillment OR rejection
> - Receives no arguments (doesn't know outcome)
> - Cannot modify Promise value/error
> - Used for cleanup (close connections, hide loaders, etc.)
> - Value/error passes through unchanged
>
> ```javascript
> fetch("/api/data")
>   .then((response) => response.json())
>   .catch((error) => {
>     console.error("Fetch failed:", error);
>     return null;
>   })
>   .finally(() => {
>     hideLoadingSpinner(); // Always runs
>     console.log("Request complete");
>   });
> ```
>
> **Comparison Table:**
>
> | Method         | When Runs                       | Arguments        | Return Affects    | Use Case        |
> | -------------- | ------------------------------- | ---------------- | ----------------- | --------------- |
> | **.then()**    | Fulfilled (+ optional rejected) | value (or error) | New Promise value | Process results |
> | **.catch()**   | Rejected                        | error            | Can recover       | Handle errors   |
> | **.finally()** | Always                          | none             | Passes through    | Cleanup         |
>
> **Detailed Examples:**
>
> **Example 1: Full Chain:**
>
> ```javascript
> fetchUser(userId)
>   .then((user) => {
>     console.log("User loaded:", user.name);
>     return fetch(`/api/posts?userId=${user.id}`);
>   })
>   .then((response) => {
>     return response.json();
>   })
>   .then((posts) => {
>     console.log("Posts loaded:", posts.length);
>     return posts;
>   })
>   .catch((error) => {
>     console.error("Something failed:", error);
>     return []; // Fallback
>   })
>   .finally(() => {
>     console.log("Request complete");
>     hideLoadingSpinner();
>   });
> ```
>
> **Example 2: Error Propagation:**
>
> ```javascript
> Promise.resolve(5)
>   .then((value) => {
>     console.log("Step 1:", value); // 5
>     return value * 2;
>   })
>   .then((value) => {
>     console.log("Step 2:", value); // 10
>     throw new Error("Oops!"); // Error thrown
>   })
>   .then((value) => {
>     console.log("Step 3:", value); // Skipped!
>   })
>   .catch((error) => {
>     console.error("Caught:", error); // Error: Oops!
>     return 999; // Recover
>   })
>   .then((value) => {
>     console.log("Step 4:", value); // 999 - continues!
>   });
> ```
>
> **Example 3: .finally() Doesn't Modify:**
>
> ```javascript
> Promise.resolve("value")
>   .finally(() => {
>     console.log("Finally runs");
>     return "ignored"; // This is ignored!
>   })
>   .then((value) => {
>     console.log(value); // 'value' (original, not 'ignored')
>   });
>
> Promise.reject("error")
>   .finally(() => {
>     console.log("Finally runs");
>     return "ignored"; // This is ignored!
>   })
>   .catch((error) => {
>     console.error(error); // 'error' (original, not 'ignored')
>   });
> ```
>
> **Example 4: Multiple .then() vs Single:**
>
> ```javascript
> const promise = Promise.resolve(1);
>
> // Branch 1
> promise.then((value) => {
>   console.log("Branch 1:", value); // 1
> });
>
> // Branch 2
> promise.then((value) => {
>   console.log("Branch 2:", value); // 1
> });
>
> // Both run independently with same value
> // Each .then() creates a new Promise
> ```
>
> **Common Patterns:**
>
> **Pattern 1: Error Recovery:**
>
> ```javascript
> fetchData()
>   .catch((error) => {
>     console.warn("Primary failed, trying backup");
>     return fetchBackupData();
>   })
>   .catch((error) => {
>     console.warn("Backup failed, using cached");
>     return getCachedData();
>   })
>   .catch((error) => {
>     console.error("All sources failed");
>     return getDefaultData();
>   })
>   .then((data) => {
>     processData(data); // Guaranteed to have data
>   });
> ```
>
> **Pattern 2: Cleanup Resources:**
>
> ```javascript
> let connection;
>
> openConnection()
>   .then((conn) => {
>     connection = conn;
>     return performOperations(conn);
>   })
>   .then((result) => {
>     return saveResult(result);
>   })
>   .catch((error) => {
>     console.error("Operation failed:", error);
>   })
>   .finally(() => {
>     if (connection) {
>       connection.close(); // Always cleanup
>     }
>   });
> ```
>
> **Pattern 3: Conditional Chaining:**
>
> ```javascript
> getUserData(userId)
>   .then((user) => {
>     if (user.needsVerification) {
>       return verifyUser(user).then((verified) => {
>         return { ...user, verified: true };
>       });
>     }
>     return user;
>   })
>   .then((user) => {
>     console.log("User ready:", user);
>   });
> ```
>
> **Common Mistakes:**
>
> **Mistake 1: Not Returning in .then():**
>
> ```javascript
> // âŒ WRONG - doesn't return Promise
> promise
>   .then((value) => {
>     asyncOperation(value); // Missing return!
>   })
>   .then((result) => {
>     console.log(result); // undefined!
>   });
>
> // âœ… CORRECT
> promise
>   .then((value) => {
>     return asyncOperation(value);
>   })
>   .then((result) => {
>     console.log(result); // Actual result
>   });
> ```
>
> **Mistake 2: Nesting Instead of Chaining:**
>
> ```javascript
> // âŒ WRONG - callback hell returns
> promise.then((value) => {
>   return asyncOp1(value).then((result1) => {
>     return asyncOp2(result1).then((result2) => {
>       return asyncOp3(result2);
>     });
>   });
> });
>
> // âœ… CORRECT - flat chain
> promise
>   .then((value) => asyncOp1(value))
>   .then((result1) => asyncOp2(result1))
>   .then((result2) => asyncOp3(result2));
> ```
>
> **Mistake 3: Forgetting .catch():**
>
> ```javascript
> // âŒ WRONG - unhandled rejection
> promise.then((value) => {
>   processValue(value);
> });
> // If Promise rejects, unhandled rejection!
>
> // âœ… CORRECT
> promise
>   .then((value) => processValue(value))
>   .catch((error) => console.error(error));
> ```
>
> **Key Takeaways:**
>
> 1. **`.then()`** - process fulfilled values, optionally handle rejections
> 2. **`.catch()`** - handle rejections, can recover
> 3. **`.finally()`** - cleanup regardless of outcome
> 4. **All return new Promises** - enables chaining
> 5. **Errors propagate** - until caught
> 6. **Finally doesn't modify** - value/error passes through
>
> Understanding these three methods is essential for working with Promises effectively. They form the foundation of Promise-based async programming and must be used correctly to avoid subtle bugs and unhandled rejections."

---

## 4. Promise Chaining

### Basic Concept

**What it means:**
Promise chaining is the pattern of calling `.then()` multiple times in sequence, where each `.then()` returns a new Promise. This allows you to perform sequential asynchronous operations without nesting (avoiding callback hell).

**Structure:**

```javascript
promise
  .then((result1) => {
    // Process result1
    return asyncOperation2(result1);
  })
  .then((result2) => {
    // Process result2
    return asyncOperation3(result2);
  })
  .then((result3) => {
    // Process result3
    console.log("Final result:", result3);
  })
  .catch((error) => {
    // Catches errors from any step
    console.error("Error:", error);
  });
```

**Key Rules:**

1. Each `.then()` returns a new Promise
2. If callback returns a value, Promise fulfilled with that value
3. If callback returns a Promise, new Promise follows that Promise
4. If callback throws, Promise is rejected
5. Values flow down the chain
6. Errors propagate until caught

**Interview Question & Perfect Answer:**

**Q: How does Promise chaining work? Why is it better than nested callbacks?**

**Perfect Answer:**

> "Promise chaining allows you to sequence asynchronous operations by returning Promises from `.then()` handlers. Each `.then()` returns a new Promise, enabling a flat, readable structure instead of nested callbacks.
>
> **How Chaining Works:**
>
> **Rule 1: Returning Values**
>
> ```javascript
> Promise.resolve(5)
>   .then((value) => {
>     console.log(value); // 5
>     return value * 2; // Return plain value
>   })
>   .then((value) => {
>     console.log(value); // 10 (wrapped in Promise.resolve)
>     return value + 3;
>   })
>   .then((value) => {
>     console.log(value); // 13
>   });
>
> // Each return value is automatically wrapped in Promise.resolve()
> ```
>
> **Rule 2: Returning Promises**
>
> ```javascript
> fetch("/api/user")
>   .then((response) => {
>     console.log("Got response");
>     return response.json(); // Returns Promise!
>   })
>   .then((user) => {
>     console.log("Got user:", user);
>     return fetch(`/api/posts?userId=${user.id}`); // Returns Promise!
>   })
>   .then((response) => {
>     console.log("Got posts response");
>     return response.json();
>   })
>   .then((posts) => {
>     console.log("Got posts:", posts);
>   });
>
> // New Promise waits for returned Promise to settle
> ```
>
> **Rule 3: Throwing Errors**
>
> ```javascript
> Promise.resolve(5)
>   .then((value) => {
>     if (value < 10) {
>       throw new Error("Too small!");
>     }
>     return value;
>   })
>   .then((value) => {
>     console.log("Never runs");
>   })
>   .catch((error) => {
>     console.error("Caught:", error); // Error: Too small!
>   });
> ```
>
> **vs. Callback Hell:**
>
> **With Callbacks (Nested):**
>
> ```javascript
> // âŒ Callback hell - hard to read
> getUser(userId, function (error, user) {
>   if (error) return handleError(error);
>
>   getOrders(user.id, function (error, orders) {
>     if (error) return handleError(error);
>
>     getOrderDetails(orders[0].id, function (error, details) {
>       if (error) return handleError(error);
>
>       getShipping(details.shippingId, function (error, shipping) {
>         if (error) return handleError(error);
>
>         console.log("Finally:", shipping);
>       });
>     });
>   });
> });
> ```
>
> **With Promise Chaining (Flat):**
>
> ```javascript
> // âœ… Promise chain - readable
> getUser(userId)
>   .then((user) => getOrders(user.id))
>   .then((orders) => getOrderDetails(orders[0].id))
>   .then((details) => getShipping(details.shippingId))
>   .then((shipping) => {
>     console.log("Finally:", shipping);
>   })
>   .catch((error) => {
>     handleError(error); // Single error handler!
>   });
> ```
>
> **Why Chaining is Better:**
>
> **1. Flat Structure:**
>
> - No rightward drift
> - Easy to read top-to-bottom
> - Clear sequence of operations
>
> **2. Single Error Handler:**
>
> - One `.catch()` handles all errors
> - No repeated error checks
> - Error propagates down chain
>
> **3. Value Flow:**
>
> - Return value automatically passed to next `.then()`
> - All previous values in scope with proper structure
> - No variable scope issues
>
> **4. Easier to Modify:**
>
> - Add steps by adding `.then()`
> - Remove steps by removing `.then()`
> - Reorder steps easily
>
> **Detailed Example:**
>
> ```javascript
> // User registration flow
> validateEmail(email)
>   .then((isValid) => {
>     if (!isValid) {
>       throw new Error("Invalid email");
>     }
>     return checkEmailAvailability(email);
>   })
>   .then((isAvailable) => {
>     if (!isAvailable) {
>       throw new Error("Email taken");
>     }
>     return hashPassword(password);
>   })
>   .then((hashedPassword) => {
>     return createUser({
>       email,
>       password: hashedPassword,
>     });
>   })
>   .then((user) => {
>     return sendWelcomeEmail(user.email);
>   })
>   .then(() => {
>     return redirectToLogin();
>   })
>   .catch((error) => {
>     console.error("Registration failed:", error);
>     showErrorMessage(error.message);
>   });
> ```
>
> **Value Access Pattern:**
>
> ```javascript
> // Need multiple values from chain?
> // Store in outer scope
> let user;
> let orders;
>
> getUser(userId)
>   .then((u) => {
>     user = u; // Store for later
>     return getOrders(user.id);
>   })
>   .then((o) => {
>     orders = o; // Store for later
>     return getDetails(orders[0].id);
>   })
>   .then((details) => {
>     // Can access user, orders, and details
>     return processData({ user, orders, details });
>   });
>
> // Or use Promise.all for parallel
> getUser(userId)
>   .then((user) => {
>     return Promise.all([
>       Promise.resolve(user), // Pass along
>       getOrders(user.id),
>     ]);
>   })
>   .then(([user, orders]) => {
>     // Both available here
>     return processData({ user, orders });
>   });
> ```
>
> **Error Propagation:**
>
> ```javascript
> step1()
>   .then((result1) => step2(result1)) // If step1 fails, skipped
>   .then((result2) => step3(result2)) // If step1/2 fail, skipped
>   .then((result3) => step4(result3)) // If step1/2/3 fail, skipped
>   .catch((error) => {
>     // Catches error from any step
>     console.error("Failed at some step:", error);
>   })
>   .finally(() => {
>     console.log("All done (success or failure)");
>   });
> ```
>
> **Common Patterns:**
>
> **Pattern 1: Transform Data Through Chain:**
>
> ```javascript
> fetch("/api/data")
>   .then((response) => response.json())
>   .then((data) => data.items)
>   .then((items) => items.filter((item) => item.active))
>   .then((activeItems) => activeItems.map((item) => item.name))
>   .then((names) => names.sort())
>   .then((sortedNames) => {
>     console.log("Final result:", sortedNames);
>   });
> ```
>
> **Pattern 2: Conditional Chains:**
>
> ```javascript
> getUser(userId)
>   .then((user) => {
>     if (user.premium) {
>       return getPremiumContent(user.id);
>     }
>     return getStandardContent(user.id);
>   })
>   .then((content) => {
>     displayContent(content);
>   });
> ```
>
> **Pattern 3: Dynamic Chains:**
>
> ```javascript
> let promise = Promise.resolve(initialValue);
>
> operations.forEach((op) => {
>   promise = promise.then((value) => op(value));
> });
>
> promise.then((finalResult) => {
>   console.log("Final:", finalResult);
> });
> ```
>
> **Common Mistakes:**
>
> **Mistake 1: Forgetting to Return:**
>
> ```javascript
> // âŒ WRONG
> promise
>   .then((value) => {
>     asyncOp(value); // No return!
>   })
>   .then((result) => {
>     console.log(result); // undefined!
>   });
>
> // âœ… CORRECT
> promise
>   .then((value) => {
>     return asyncOp(value);
>   })
>   .then((result) => {
>     console.log(result); // Actual result
>   });
> ```
>
> **Mistake 2: Nesting Promises:**
>
> ```javascript
> // âŒ WRONG - defeats purpose of chaining
> promise.then((value) => {
>   return asyncOp1(value).then((result) => {
>     return asyncOp2(result).then((final) => {
>       return final;
>     });
>   });
> });
>
> // âœ… CORRECT - flat chain
> promise
>   .then((value) => asyncOp1(value))
>   .then((result) => asyncOp2(result))
>   .then((final) => final);
> ```
>
> **Mistake 3: Creating Unnecessary Promises:**
>
> ```javascript
> // âŒ WRONG - wraps Promise in Promise
> function getData() {
>   return new Promise((resolve) => {
>     fetch("/api/data")
>       .then((response) => response.json())
>       .then((data) => resolve(data));
>   });
> }
>
> // âœ… CORRECT - just return the Promise chain
> function getData() {
>   return fetch("/api/data").then((response) => response.json());
> }
> ```
>
> **Key Takeaways:**
>
> 1. **Each `.then()` returns new Promise** - enables chaining
> 2. **Return values flow down** - automatically wrapped in Promise
> 3. **Errors propagate down** - until caught with `.catch()`
> 4. **Flat structure** - no nesting, no callback hell
> 5. **Single error handler** - one `.catch()` for entire chain
> 6. **Always return** - forgetting breaks the chain
>
> Promise chaining transformed asynchronous JavaScript from nested callback hell into readable, maintainable sequential flows. It's the foundation that makes Promises superior to callbacks and is essential understanding before moving to async/await."

---

## 5. Promise Combinators

### The Four Combinators

JavaScript provides four static methods for combining multiple Promises: `Promise.all`, `Promise.race`, `Promise.allSettled`, and `Promise.any`. Each serves different use cases.

**Promise.all - All Must Succeed:**

```javascript
Promise.all([promise1, promise2, promise3])
  .then(([result1, result2, result3]) => {
    // All succeeded
  })
  .catch((error) => {
    // Any one failed
  });
```

**Promise.race - First to Finish:**

```javascript
Promise.race([promise1, promise2, promise3]).then((result) => {
  // First to settle (fulfill or reject)
});
```

**Promise.allSettled - All Results:**

```javascript
Promise.allSettled([promise1, promise2, promise3]).then((results) => {
  // All settled (fulfilled or rejected)
  // results: [{ status, value/reason }, ...]
});
```

**Promise.any - First Success:**

```javascript
Promise.any([promise1, promise2, promise3])
  .then((result) => {
    // First to fulfill (ignores rejections)
  })
  .catch((error) => {
    // All rejected
  });
```

**Comparison Table:**

| Combinator             | Resolves When  | Rejects When             | Returns                 |
| ---------------------- | -------------- | ------------------------ | ----------------------- |
| **Promise.all**        | All fulfill    | Any rejects              | Array of values         |
| **Promise.race**       | First settles  | First rejects (if first) | Single value/error      |
| **Promise.allSettled** | All settle     | Never                    | Array of result objects |
| **Promise.any**        | First fulfills | All reject               | Single value            |

**Interview Question & Perfect Answer:**

**Q: Explain Promise.all, Promise.race, Promise.allSettled, and Promise.any. When would you use each?**

**Perfect Answer:**

> "JavaScript provides four Promise combinators for handling multiple Promises concurrently. Each has different resolution/rejection behavior suited to specific use cases.
>
> **1. Promise.all - All Must Succeed:**
>
> Waits for all Promises to fulfill, or rejects as soon as any Promise rejects (fail-fast).
>
> ```javascript
> const promise1 = fetch("/api/users");
> const promise2 = fetch("/api/posts");
> const promise3 = fetch("/api/comments");
>
> Promise.all([promise1, promise2, promise3])
>   .then(([users, posts, comments]) => {
>     // All three succeeded
>     console.log("All data loaded");
>     renderDashboard({ users, posts, comments });
>   })
>   .catch((error) => {
>     // Any one failed - entire operation fails
>     console.error("Loading failed:", error);
>   });
> ```
>
> **When to use:**
>
> - All operations must succeed for result to be useful
> - Loading required data in parallel
> - Multiple validations must all pass
> - Batch processing where all items must succeed
>
> **Behavior:**
>
> - **Resolves:** When all Promises fulfill â†’ array of values (same order)
> - **Rejects:** As soon as any Promise rejects â†’ first rejection reason
> - **Short-circuits:** Stops waiting after first rejection
>
> ```javascript
> Promise.all([
>   Promise.resolve(1),
>   Promise.reject("Error"), // Fails here
>   Promise.resolve(3), // Never checked
> ]).catch((error) => console.error(error)); // 'Error'
> ```
>
> **2. Promise.race - First to Finish Wins:**
>
> Returns when the first Promise settles (fulfills or rejects), ignoring others.
>
> ```javascript
> const timeout = new Promise((_, reject) =>
>   setTimeout(() => reject("Timeout"), 5000)
> );
>
> const fetchData = fetch("/api/data");
>
> Promise.race([fetchData, timeout])
>   .then((data) => {
>     console.log("Data arrived in time");
>   })
>   .catch((error) => {
>     if (error === "Timeout") {
>       console.error("Request timed out");
>     }
>   });
> ```
>
> **When to use:**
>
> - Implementing timeouts
> - Using fastest of multiple sources
> - Cancellation logic
> - "Whichever finishes first" scenarios
>
> **Behavior:**
>
> - **Settles:** When first Promise settles (fulfill or reject)
> - **Returns:** Value or error from first settled Promise
> - **Ignores:** All other Promises
>
> ```javascript
> Promise.race([
>   delay(1000).then(() => "slow"),
>   delay(100).then(() => "fast"), // Finishes first
>   delay(500).then(() => "medium"),
> ]).then((result) => console.log(result)); // 'fast'
> ```
>
> **3. Promise.allSettled - All Results, No Fail:**
>
> Waits for all Promises to settle (fulfill or reject), never rejects.
>
> ```javascript
> const promises = [
>   fetch("/api/users"),
>   fetch("/api/posts"),
>   fetch("/api/comments"),
> ];
>
> Promise.allSettled(promises).then((results) => {
>   results.forEach((result, index) => {
>     if (result.status === "fulfilled") {
>       console.log(`Request ${index} succeeded:`, result.value);
>     } else {
>       console.error(`Request ${index} failed:`, result.reason);
>     }
>   });
>
>   const successful = results.filter((r) => r.status === "fulfilled");
>   const failed = results.filter((r) => r.status === "rejected");
>
>   console.log(`${successful.length} succeeded, ${failed.length} failed`);
> });
> ```
>
> **When to use:**
>
> - Want all results, even if some fail
> - Partial success is acceptable
> - Logging/analytics where failures shouldn't stop others
> - Gathering data from multiple sources where some may be down
>
> **Behavior:**
>
> - **Resolves:** When all Promises settle â†’ never rejects
> - **Returns:** Array of result objects:
>   ```javascript
>   { status: 'fulfilled', value: result }
>   { status: 'rejected', reason: error }
>   ```
>
> ```javascript
> Promise.allSettled([
>   Promise.resolve(1),
>   Promise.reject("Error"),
>   Promise.resolve(3),
> ]).then((results) => console.log(results));
> // [
> //   { status: 'fulfilled', value: 1 },
> //   { status: 'rejected', reason: 'Error' },
> //   { status: 'fulfilled', value: 3 }
> // ]
> ```
>
> **4. Promise.any - First Success Wins:**
>
> Returns when first Promise fulfills, ignoring rejections until all reject.
>
> ```javascript
> const mirrors = [
>   fetch("https://mirror1.com/data"),
>   fetch("https://mirror2.com/data"),
>   fetch("https://mirror3.com/data"),
> ];
>
> Promise.any(mirrors)
>   .then((response) => {
>     console.log("Got data from fastest working mirror");
>     return response.json();
>   })
>   .catch((error) => {
>     console.error("All mirrors failed:", error);
>   });
> ```
>
> **When to use:**
>
> - Multiple fallback sources
> - First successful response is sufficient
> - Redundant operations where any success works
> - Load balancing with retry logic
>
> **Behavior:**
>
> - **Resolves:** When first Promise fulfills
> - **Rejects:** Only if all Promises reject â†’ AggregateError
> - **Ignores:** Individual rejections until all fail
>
> ```javascript
> Promise.any([
>   Promise.reject("Error 1"),
>   Promise.resolve("Success"), // First success
>   Promise.reject("Error 2"),
> ]).then((result) => console.log(result)); // 'Success'
>
> Promise.any([
>   Promise.reject("Error 1"),
>   Promise.reject("Error 2"),
>   Promise.reject("Error 3"),
> ]).catch((error) => {
>   console.log(error instanceof AggregateError); // true
>   console.log(error.errors); // ['Error 1', 'Error 2', 'Error 3']
> });
> ```
>
> **Comparison Summary:**
>
> ```javascript
> const promises = [
>   Promise.resolve(1),
>   Promise.reject("error"),
>   Promise.resolve(3),
> ];
>
> // Promise.all - fails immediately
> Promise.all(promises).catch((error) => console.log("all:", error));
> // Output: 'all: error'
>
> // Promise.allSettled - gets all results
> Promise.allSettled(promises).then((results) =>
>   console.log("allSettled:", results)
> );
> // Output: allSettled: [
> //   { status: 'fulfilled', value: 1 },
> //   { status: 'rejected', reason: 'error' },
> //   { status: 'fulfilled', value: 3 }
> // ]
>
> // Promise.race - first to settle (fulfilled in this case)
> Promise.race(promises).then((result) => console.log("race:", result));
> // Output: 'race: 1'
>
> // Promise.any - first to fulfill
> Promise.any(promises).then((result) => console.log("any:", result));
> // Output: 'any: 1'
> ```
>
> **Real-World Examples:**
>
> **Example 1: Dashboard Loading (Promise.all):**
>
> ```javascript
> async function loadDashboard() {
>   try {
>     const [user, stats, activity] = await Promise.all([
>       fetchUser(),
>       fetchStats(),
>       fetchActivity(),
>     ]);
>     renderDashboard({ user, stats, activity });
>   } catch (error) {
>     showError("Dashboard loading failed");
>   }
> }
> ```
>
> **Example 2: Request Timeout (Promise.race):**
>
> ```javascript
> function fetchWithTimeout(url, timeout = 5000) {
>   return Promise.race([
>     fetch(url),
>     new Promise((_, reject) =>
>       setTimeout(() => reject(new Error("Timeout")), timeout)
>     ),
>   ]);
> }
> ```
>
> **Example 3: Partial Success (Promise.allSettled):**
>
> ```javascript
> async function saveMultipleRecords(records) {
>   const savePromises = records.map((record) => saveRecord(record));
>   const results = await Promise.allSettled(savePromises);
>
>   const saved = results.filter((r) => r.status === "fulfilled").length;
>   const failed = results.filter((r) => r.status === "rejected").length;
>
>   console.log(`Saved: ${saved}, Failed: ${failed}`);
>   return { saved, failed };
> }
> ```
>
> **Example 4: Fallback Sources (Promise.any):**
>
> ```javascript
> async function fetchFromBestSource() {
>   try {
>     const data = await Promise.any([
>       fetch("https://primary-api.com/data"),
>       fetch("https://backup-api.com/data"),
>       fetch("https://cache-api.com/data"),
>     ]);
>     return data.json();
>   } catch (error) {
>     console.error("All sources failed");
>     return getDefaultData();
>   }
> }
> ```
>
> **Choosing the Right Combinator:**
>
> | Scenario           | Use                    |
> | ------------------ | ---------------------- |
> | All must succeed   | **Promise.all**        |
> | Need timeout       | **Promise.race**       |
> | Partial success OK | **Promise.allSettled** |
> | Any success works  | **Promise.any**        |
> | Fastest wins       | **Promise.race**       |
> | Get all results    | **Promise.allSettled** |
>
> Understanding these combinators is essential for writing efficient concurrent async code. They let you express complex async patterns clearly and concisely, handling multiple operations in parallel with different success/failure semantics."

---

## ðŸŽ¯ Summary

### Key Takeaways

1. **Promise States:**

   - Pending â†’ Fulfilled OR Rejected
   - One-time transition, immutable after settlement

2. **Constructor:**

   - `new Promise((resolve, reject) => {})`
   - Executor runs immediately
   - Call resolve() or reject() to settle

3. **Methods:**

   - `.then()` - handle success (and failure)
   - `.catch()` - handle errors
   - `.finally()` - cleanup (always runs)

4. **Chaining:**

   - Each method returns new Promise
   - Flat structure, no callback hell
   - Errors propagate until caught

5. **Combinators:**
   - `Promise.all` - all must succeed
   - `Promise.race` - first wins
   - `Promise.allSettled` - all results
   - `Promise.any` - first success

---

**Remember:** Promises revolutionized async JavaScript by providing a standard, composable way to handle asynchronous operations. They're the foundation for async/await and essential for modern JavaScript development. Master Promises, and async/await becomes trivial!
