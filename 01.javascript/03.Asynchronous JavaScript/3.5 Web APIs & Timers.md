# Web APIs & Timers

## üéØ Key Concepts

### 1. setTimeout and clearTimeout (CRITICAL!)

**What it means:**

- Execute code once after a specified delay
- Delay is MINIMUM, not guaranteed exact time
- Returns a timer ID that can be used to cancel
- Part of Web APIs, not JavaScript language itself

**Basic Usage:**

```javascript
// Execute after delay
const timerId = setTimeout(() => {
  console.log("Executed after 1 second");
}, 1000);

// Cancel before execution
clearTimeout(timerId);
```

**Important Characteristics:**

**1. Minimum Delay, Not Exact:**

```javascript
const start = Date.now();
setTimeout(() => {
  const end = Date.now();
  console.log(`Actual delay: ${end - start}ms`);
}, 1000);
// Might print: "Actual delay: 1004ms" or similar
// Never less than 1000ms, often slightly more
```

**2. Zero Delay Doesn't Mean Immediate:**

```javascript
console.log("1");
setTimeout(() => console.log("2"), 0);
console.log("3");
// Prints: 1, 3, 2
// setTimeout(fn, 0) runs after current call stack clears
```

**3. Timer ID for Cancellation:**

```javascript
const timerId = setTimeout(() => {
  console.log("This won't run");
}, 5000);

// Cancel it
clearTimeout(timerId);
```

**4. Passing Arguments:**

```javascript
// Method 1: Additional parameters
setTimeout(greet, 1000, "Alice", "Hello");

function greet(name, greeting) {
  console.log(`${greeting}, ${name}!`);
}

// Method 2: Arrow function (more common)
setTimeout(() => greet("Alice", "Hello"), 1000);
```

**5. this Context:**

```javascript
const obj = {
  name: "Alice",
  greet: function () {
    setTimeout(function () {
      console.log(this.name); // undefined (this is window/global)
    }, 100);
  },
};

// Solution 1: Arrow function (preserves this)
const obj2 = {
  name: "Alice",
  greet: function () {
    setTimeout(() => {
      console.log(this.name); // "Alice"
    }, 100);
  },
};

// Solution 2: bind
const obj3 = {
  name: "Alice",
  greet: function () {
    setTimeout(
      function () {
        console.log(this.name); // "Alice"
      }.bind(this),
      100
    );
  },
};
```

**Browser Minimums:**

- Normal: 4ms minimum (browsers enforce this)
- Nested (>5 levels deep): 4ms minimum
- Background/inactive tabs: 1000ms minimum (battery saving)
- setTimeout(fn, 0): Still goes to task queue

**Common Patterns:**

**Debouncing:**

```javascript
function debounce(fn, delay) {
  let timerId;
  return function (...args) {
    clearTimeout(timerId);
    timerId = setTimeout(() => fn.apply(this, args), delay);
  };
}

// Usage: Only call after user stops typing
const debouncedSearch = debounce(searchAPI, 300);
input.addEventListener("input", debouncedSearch);
```

**Throttling with setTimeout:**

```javascript
function throttle(fn, limit) {
  let inThrottle;
  return function (...args) {
    if (!inThrottle) {
      fn.apply(this, args);
      inThrottle = true;
      setTimeout(() => (inThrottle = false), limit);
    }
  };
}

// Usage: Limit scroll handler execution
const throttledScroll = throttle(handleScroll, 100);
window.addEventListener("scroll", throttledScroll);
```

**Interview Gold:** "setTimeout doesn't guarantee exact timing. It's a minimum delay. The callback goes to the macrotask queue and executes when the call stack is empty."

---

### 2. setInterval and clearInterval (CRITICAL!)

**What it means:**

- Execute code repeatedly at specified intervals
- Can accumulate calls if execution takes longer than interval
- Should be cleared when no longer needed to prevent memory leaks
- Less precise over time (clock drift)

**Basic Usage:**

```javascript
// Execute repeatedly
const intervalId = setInterval(() => {
  console.log("Tick");
}, 1000);

// Stop after 5 seconds
setTimeout(() => {
  clearInterval(intervalId);
}, 5000);
```

**Critical Problem - Interval Stacking:**

```javascript
// ‚ùå DANGEROUS: Can stack if operation takes longer than interval
setInterval(() => {
  // If this takes 2 seconds...
  expensiveOperation(); // But interval is 1 second
  // Calls will queue up!
}, 1000);

// ‚úÖ BETTER: Use setTimeout recursively
function repeatTask() {
  expensiveOperation();
  setTimeout(repeatTask, 1000); // Waits for completion
}
repeatTask();
```

**Why Recursive setTimeout is Better:**

```javascript
// setInterval issues:
// - Doesn't wait for function to complete
// - Can create overlapping executions
// - Timing drift accumulates

// Recursive setTimeout:
// - Waits for completion before scheduling next
// - Prevents overlapping
// - More predictable timing
function scheduleNext() {
  // Do work
  doWork();

  // Schedule next execution AFTER work completes
  setTimeout(scheduleNext, 1000);
}
```

**Real-World Example - Polling:**

```javascript
// ‚ùå BAD: setInterval can stack API calls
const intervalId = setInterval(async () => {
  await fetchData(); // If this takes >5 seconds, calls stack!
}, 5000);

// ‚úÖ GOOD: Recursive setTimeout waits
async function poll() {
  try {
    await fetchData();
  } catch (error) {
    console.error(error);
  }

  // Schedule next poll after this one completes
  setTimeout(poll, 5000);
}
poll();
```

**Clearing Intervals:**

```javascript
// Always clear intervals to prevent memory leaks
const intervalId = setInterval(() => {
  console.log("Tick");
}, 1000);

// Clear when component unmounts (React)
useEffect(() => {
  const id = setInterval(updateData, 1000);
  return () => clearInterval(id); // Cleanup
}, []);

// Clear when condition met
let count = 0;
const id = setInterval(() => {
  count++;
  if (count >= 10) {
    clearInterval(id); // Stop after 10
  }
}, 100);
```

**Timing Precision:**

```javascript
// setInterval drifts over time
let expectedTime = Date.now() + 1000;
setInterval(() => {
  const drift = Date.now() - expectedTime;
  console.log(`Drift: ${drift}ms`);
  expectedTime += 1000;
}, 1000);
// Drift accumulates: 2ms, 5ms, 8ms, 12ms...
```

**Interview Pattern:**

```javascript
// Question: What's wrong with this code?
const id = setInterval(() => {
  if (condition) {
    clearInterval(id); // ‚ùå May not exist in first call
  }
}, 100);

// Better:
let id;
id = setInterval(() => {
  if (condition) {
    clearInterval(id); // ‚úÖ Now accessible
  }
}, 100);
```

**Interview Gold:** "setInterval can stack calls if the callback takes longer than the interval. Use recursive setTimeout for safer repeated execution."

---

### 3. requestAnimationFrame (CRITICAL!)

**What it means:**

- Browser API for smooth animations
- Syncs with browser's refresh rate (typically 60fps)
- Automatically pauses in background tabs (battery saving)
- Much better than setTimeout/setInterval for animations

**Why Use It:**

```javascript
// ‚ùå BAD: setTimeout for animation (choppy)
function animateWithTimeout() {
  element.style.left = position + "px";
  position += 5;
  setTimeout(animateWithTimeout, 16); // ~60fps, but not synced
}

// ‚úÖ GOOD: requestAnimationFrame (smooth)
function animateWithRAF() {
  element.style.left = position + "px";
  position += 5;
  requestAnimationFrame(animateWithRAF); // Synced with display
}
```

**Basic Usage:**

```javascript
let start = null;

function step(timestamp) {
  if (!start) start = timestamp;
  const progress = timestamp - start;

  // Move element
  element.style.left = Math.min(progress / 10, 200) + "px";

  // Continue if not done
  if (progress < 2000) {
    requestAnimationFrame(step);
  }
}

requestAnimationFrame(step);
```

**Canceling Animation:**

```javascript
let animationId;

function animate() {
  // Animation logic
  updatePosition();
  animationId = requestAnimationFrame(animate);
}

// Start
animationId = requestAnimationFrame(animate);

// Stop
cancelAnimationFrame(animationId);
```

**Timestamp Parameter:**

```javascript
// RAF provides high-resolution timestamp
requestAnimationFrame((timestamp) => {
  console.log(timestamp); // e.g., 1234567.89
  // DOMHighResTimeStamp, more precise than Date.now()
});
```

**Performance Benefits:**

**1. Syncs with Refresh Rate:**

```javascript
// Browser repaints at 60fps (16.67ms intervals)
// RAF automatically matches this
// No wasted frames or visual tearing
```

**2. Automatic Throttling:**

```javascript
// In background tabs, RAF pauses
// Saves CPU and battery
// setTimeout/setInterval keep running!
```

**3. Batches DOM Reads/Writes:**

```javascript
// Browser can optimize reflows/repaints
// Better performance than scattered updates
```

**Real-World Example - Smooth Scroll:**

```javascript
function smoothScroll(targetPosition, duration) {
  const startPosition = window.pageYOffset;
  const distance = targetPosition - startPosition;
  let startTime = null;

  function animation(currentTime) {
    if (!startTime) startTime = currentTime;
    const timeElapsed = currentTime - startTime;
    const progress = Math.min(timeElapsed / duration, 1);

    // Easing function
    const ease = progress * (2 - progress); // ease-out

    window.scrollTo(0, startPosition + distance * ease);

    if (timeElapsed < duration) {
      requestAnimationFrame(animation);
    }
  }

  requestAnimationFrame(animation);
}

// Usage
smoothScroll(1000, 500); // Scroll to 1000px in 500ms
```

**Delta Time Pattern:**

```javascript
let lastTime = 0;

function gameLoop(timestamp) {
  const deltaTime = timestamp - lastTime;
  lastTime = timestamp;

  // Update game state based on time elapsed
  updateGame(deltaTime);
  render();

  requestAnimationFrame(gameLoop);
}

requestAnimationFrame(gameLoop);
```

**Interview Gold:** "requestAnimationFrame syncs with the browser's refresh rate, provides automatic throttling in background tabs, and gives you a high-resolution timestamp. It's the standard for smooth animations."

---

### 4. requestIdleCallback (Important!)

**What it means:**

- Execute low-priority work during browser idle time
- Doesn't block critical rendering or user interactions
- Has timeout option to ensure eventual execution
- Not supported in all browsers (Safari missing)

**Basic Usage:**

```javascript
requestIdleCallback((deadline) => {
  // deadline.timeRemaining() tells you how much time left
  while (deadline.timeRemaining() > 0 && tasks.length > 0) {
    const task = tasks.shift();
    processTask(task);
  }

  // If more tasks, schedule again
  if (tasks.length > 0) {
    requestIdleCallback(processTasksIdle);
  }
});
```

**With Timeout:**

```javascript
// Will execute within 2 seconds, even if not idle
requestIdleCallback(
  (deadline) => {
    console.log("Time remaining:", deadline.timeRemaining());
    console.log("Timed out?", deadline.didTimeout);

    doNonCriticalWork();
  },
  { timeout: 2000 }
);
```

**Use Cases:**

- Analytics sending
- Prefetching data
- Background syncing
- Logging
- Non-critical DOM updates

**Real-World Example - Analytics Queue:**

```javascript
const analyticsQueue = [];

function trackEvent(event) {
  analyticsQueue.push(event);

  requestIdleCallback(
    (deadline) => {
      while (deadline.timeRemaining() > 0 && analyticsQueue.length > 0) {
        const event = analyticsQueue.shift();
        sendToAnalytics(event); // Non-blocking
      }
    },
    { timeout: 5000 }
  );
}
```

**Browser Support:**

```javascript
// Polyfill for unsupported browsers
window.requestIdleCallback =
  window.requestIdleCallback ||
  function (cb) {
    const start = Date.now();
    return setTimeout(() => {
      cb({
        didTimeout: false,
        timeRemaining: () => Math.max(0, 50 - (Date.now() - start)),
      });
    }, 1);
  };
```

---

### 5. Fetch API (CRITICAL!)

**What it means:**

- Modern replacement for XMLHttpRequest
- Promise-based API for HTTP requests
- Returns Response object with useful methods
- Doesn't reject on HTTP errors (404, 500, etc.)

**Basic Usage:**

```javascript
fetch("https://api.example.com/data")
  .then((response) => {
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    return response.json();
  })
  .then((data) => console.log(data))
  .catch((error) => console.error("Error:", error));
```

**With async/await:**

```javascript
async function fetchData() {
  try {
    const response = await fetch("https://api.example.com/data");

    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }

    const data = await response.json();
    return data;
  } catch (error) {
    console.error("Fetch error:", error);
  }
}
```

**Request Methods:**

```javascript
// GET (default)
fetch("/api/users");

// POST
fetch("/api/users", {
  method: "POST",
  headers: {
    "Content-Type": "application/json",
  },
  body: JSON.stringify({ name: "Alice" }),
});

// PUT
fetch("/api/users/1", {
  method: "PUT",
  headers: {
    "Content-Type": "application/json",
  },
  body: JSON.stringify({ name: "Alice Updated" }),
});

// DELETE
fetch("/api/users/1", {
  method: "DELETE",
});
```

**Response Methods:**

```javascript
const response = await fetch("/api/data");

// Parse JSON
const json = await response.json();

// Get text
const text = await response.text();

// Get blob (files)
const blob = await response.blob();

// Get FormData
const formData = await response.formData();

// Get ArrayBuffer (binary)
const buffer = await response.arrayBuffer();
```

**Headers:**

```javascript
fetch("/api/data", {
  headers: {
    Authorization: "Bearer token123",
    "Content-Type": "application/json",
    Accept: "application/json",
  },
});

// Reading response headers
const response = await fetch("/api/data");
console.log(response.headers.get("Content-Type"));
```

**Important: Fetch Doesn't Reject on HTTP Errors:**

```javascript
// ‚ùå WRONG: This doesn't catch 404!
fetch("/api/notfound").catch((error) => {
  // Only network errors reach here
  console.log("This might not run!");
});

// ‚úÖ CORRECT: Check response.ok
fetch("/api/notfound")
  .then((response) => {
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}`);
    }
    return response.json();
  })
  .catch((error) => {
    // Now catches both network AND HTTP errors
    console.error(error);
  });
```

**Aborting Requests:**

```javascript
const controller = new AbortController();
const signal = controller.signal;

fetch("/api/data", { signal })
  .then((response) => response.json())
  .catch((error) => {
    if (error.name === "AbortError") {
      console.log("Fetch aborted");
    }
  });

// Abort after 5 seconds
setTimeout(() => controller.abort(), 5000);
```

**Timeout Pattern:**

```javascript
async function fetchWithTimeout(url, timeout = 5000) {
  const controller = new AbortController();
  const id = setTimeout(() => controller.abort(), timeout);

  try {
    const response = await fetch(url, { signal: controller.signal });
    clearTimeout(id);
    return response;
  } catch (error) {
    clearTimeout(id);
    throw error;
  }
}
```

**Interview Gold:** "Fetch returns a Promise and doesn't reject on HTTP errors like 404 or 500. You must check response.ok manually. It only rejects on network failures."

---

### 6. Web Workers (Important!)

**What it means:**

- Run JavaScript in background thread
- Doesn't block main thread (UI stays responsive)
- No access to DOM, window, or document
- Communication via message passing
- Useful for heavy computations

**Basic Usage:**

**Main Thread:**

```javascript
// Create worker
const worker = new Worker("worker.js");

// Send message to worker
worker.postMessage({ type: "CALCULATE", data: 1000000 });

// Receive message from worker
worker.onmessage = (event) => {
  console.log("Result:", event.data);
};

// Handle errors
worker.onerror = (error) => {
  console.error("Worker error:", error);
};

// Terminate when done
worker.terminate();
```

**Worker Thread (worker.js):**

```javascript
// Receive message from main thread
self.onmessage = (event) => {
  const { type, data } = event.data;

  if (type === "CALCULATE") {
    // Heavy computation
    const result = expensiveCalculation(data);

    // Send result back
    self.postMessage(result);
  }
};

function expensiveCalculation(n) {
  let result = 0;
  for (let i = 0; i < n; i++) {
    result += Math.sqrt(i);
  }
  return result;
}
```

**Limitations:**

- No DOM access
- No window object
- No document object
- Can't access parent scope variables
- Can use: setTimeout, fetch, XMLHttpRequest, IndexedDB

**Use Cases:**

- Image processing
- Large data processing
- Cryptography
- Background sync
- Heavy calculations
- Parsing large files

**Shared Workers:**

```javascript
// Can be accessed by multiple scripts/tabs
const worker = new SharedWorker("shared-worker.js");

worker.port.start();
worker.port.postMessage("Hello");
worker.port.onmessage = (e) => console.log(e.data);
```

**Interview Gold:** "Web Workers run JavaScript in a separate thread, keeping the UI responsive during heavy computations. They can't access the DOM and communicate via postMessage."

---

### 7. Timer Accuracy and Limitations (Important!)

**What it means:**

- JavaScript timers are not precise
- Various factors affect accuracy
- Understanding limitations prevents bugs
- Browser implements minimum delays

**Key Limitations:**

**1. Minimum Delays:**

```javascript
// Browsers enforce minimums
setTimeout(fn, 0); // Actually ~4ms
setTimeout(fn, 1); // Actually ~4ms
setInterval(fn, 0); // Actually ~4ms

// Background tabs
setTimeout(fn, 100); // Might be 1000ms+ in background
```

**2. Nested Timer Clamping:**

```javascript
// After 5 nested levels, minimum becomes 4ms
setTimeout(() => {
  // Level 1
  setTimeout(() => {
    // Level 2
    setTimeout(() => {
      // Level 3
      setTimeout(() => {
        // Level 4
        setTimeout(() => {
          // Level 5
          setTimeout(() => {
            // Level 6 - now clamped to 4ms min
            // Even if you specify 0ms
          }, 0);
        }, 0);
      }, 0);
    }, 0);
  }, 0);
}, 0);
```

**3. Event Loop Blocking:**

```javascript
setTimeout(() => console.log("Timer"), 100);

// Long-running task blocks timer
for (let i = 0; i < 1000000000; i++) {
  // Timer can't fire until this completes
}
// Timer fires after loop, not at 100ms
```

**4. Clock Drift:**

```javascript
// Timers drift over time
let count = 0;
const start = Date.now();

setInterval(() => {
  count++;
  const expected = start + count * 1000;
  const actual = Date.now();
  const drift = actual - expected;
  console.log(`Drift: ${drift}ms`);
}, 1000);
// Drift increases: 2ms, 5ms, 10ms, 15ms...
```

**5. System Sleep:**

```javascript
// Timers don't run during sleep
setTimeout(() => {
  console.log("After 1 minute");
}, 60000);

// If computer sleeps for 1 hour,
// timer fires immediately when waking
```

**Improving Accuracy:**

**Self-Correcting Timer:**

```javascript
function setAccurateInterval(callback, interval) {
  let expected = Date.now() + interval;

  function step() {
    const drift = Date.now() - expected;
    callback();
    expected += interval;
    setTimeout(step, Math.max(0, interval - drift));
  }

  setTimeout(step, interval);
}
```

**Using Performance.now():**

```javascript
// More accurate than Date.now()
const start = performance.now();
setTimeout(() => {
  const elapsed = performance.now() - start;
  console.log(`Actual delay: ${elapsed}ms`);
}, 1000);
```

**Interview Gold:** "Timers have a 4ms minimum delay in browsers, drift over time, and can be delayed by long-running tasks. They're minimum delays, not guaranteed precise timings."

---

## üé§ Top Interview Questions & Model Answers

### Q1: What's the difference between setTimeout and setInterval?

**Perfect Answer:**

> "Both schedule code execution, but setTimeout executes once after a delay, while setInterval repeats at specified intervals. The critical difference is setInterval can stack calls if the callback takes longer than the interval - if your callback takes 2 seconds but the interval is 1 second, calls will queue up.
>
> That's why recursive setTimeout is often better for repeated tasks - it waits for the callback to complete before scheduling the next execution, preventing overlapping calls and providing more predictable timing.
>
> Also, both return IDs that can be used with clearTimeout or clearInterval to cancel execution. This is important for cleanup, especially in React components where you need to clear timers in useEffect cleanup functions to prevent memory leaks."

### Q2: Why use requestAnimationFrame for animations instead of setTimeout?

**Perfect Answer:**

> "requestAnimationFrame is specifically designed for animations and has several advantages. First, it syncs with the browser's refresh rate - typically 60fps - so you get smooth animations without tearing. setTimeout can't guarantee this synchronization even at 16ms intervals.
>
> Second, RAF automatically pauses in background tabs, saving CPU and battery. setTimeout keeps running even when the tab isn't visible, wasting resources. Third, RAF provides a high-resolution timestamp parameter, which is more accurate than Date.now() for animation timing.
>
> Finally, the browser can optimize RAF callbacks - it knows they're for rendering and can batch DOM updates for better performance. This is why RAF is the standard for any visual animation, from simple CSS property changes to complex canvas animations or game loops."

### Q3: How do Web Workers work and when should you use them?

**Perfect Answer:**

> "Web Workers run JavaScript in a separate thread, completely independent of the main thread where your UI code runs. This means heavy computations won't freeze the interface. Communication happens through postMessage and onmessage - you can't directly share memory or access shared variables.
>
> The main limitation is workers can't access the DOM, window, or document objects. They can use setTimeout, fetch, and other APIs, but no DOM manipulation. This makes them perfect for CPU-intensive tasks like image processing, large data parsing, cryptography, or complex calculations.
>
> I'd use Workers when I have processing that takes more than 50-100ms and would cause noticeable UI lag. For example, parsing a large CSV file, computing analytics on the client side, or doing real-time image filters. The communication overhead is negligible compared to the benefit of keeping the UI responsive."

### Q4: Why does fetch not reject on HTTP errors?

**Perfect Answer:**

> "This is a common gotcha - fetch only rejects the Promise on network failures, not HTTP errors like 404 or 500. It considers any response from the server as a successful fetch, even if that response has a 404 status code.
>
> You need to manually check response.ok or response.status. The ok property is true for status codes 200-299 and false otherwise. This design decision was intentional - fetch separates network failures (no response) from HTTP failures (got a response, but it's an error status).
>
> In practice, I always check response.ok and throw an error if it's false, so both network and HTTP errors end up in the catch block. This makes error handling consistent. The pattern is: fetch, check ok, then parse with .json() or .text()."

### Q5: What's the minimum timeout in browsers and why does it exist?

**Perfect Answer:**

> "Browsers enforce a 4ms minimum delay for setTimeout and setInterval. Even if you specify 0ms, it won't execute immediately - it goes to the macrotask queue and runs after the current call stack clears, with at least 4ms delay.
>
> This minimum exists for performance and battery life. Without it, code could create tight loops that monopolize the CPU. There's also 'timer nesting' - after 5 nested setTimeout calls, the minimum jumps to 4ms to prevent recursive timer abuse.
>
> In background tabs, the minimum is even higher - often 1000ms - to save battery. This is why you shouldn't rely on timers for precise timing. For animations, use requestAnimationFrame. For accurate intervals, use a self-correcting timer pattern that adjusts for drift."

### Q6: Explain what happens with setTimeout(fn, 0)

**Perfect Answer:**

> "setTimeout with 0 delay doesn't execute immediately - it schedules the callback to run after the current call stack clears. The function goes into the macrotask queue and waits for the event loop to pick it up.
>
> This means any synchronous code will run first. It's useful for deferring execution until after the current task, like after the DOM updates or after all synchronous code finishes. A classic use case is breaking up long-running tasks: process a chunk, setTimeout(fn, 0), process next chunk, and so on. This prevents blocking the UI.
>
> Even with 0 delay, there's a ~4ms minimum in browsers. So it's more accurate to think of it as 'run this soon' rather than 'run this immediately.' For truly immediate execution, you'd use a microtask like Promise.resolve().then(fn), which runs before the next macrotask."

---

## üîë Must Know Checklist

### ‚úÖ Critical (Always asked)

- ‚úÖ setTimeout vs setInterval - differences and use cases
- ‚úÖ clearTimeout/clearInterval - memory leak prevention
- ‚úÖ requestAnimationFrame - why it's better for animations
- ‚úÖ Fetch API - basic usage and error handling
- ‚úÖ setTimeout(fn, 0) - what actually happens

### ‚úÖ Should Know (Frequently asked)

- ‚úÖ Timer minimum delays (4ms)
- ‚úÖ Recursive setTimeout pattern
- ‚úÖ Timer accuracy limitations
- ‚úÖ Web Workers basics
- ‚úÖ Fetch doesn't reject on HTTP errors

### ‚úÖ Nice to Know (Senior level)

- [ ] requestIdleCallback use cases
- [ ] AbortController for fetch
- [ ] Shared Workers
- [ ] Timer drift and correction
- [ ] Background tab throttling

---

## üö® Common Mistakes to Avoid

### 1. Not Clearing Timers

```javascript
// ‚ùå BAD: Memory leak
useEffect(() => {
  setInterval(() => {
    updateData();
  }, 1000);
}, []); // Runs forever!

// ‚úÖ GOOD: Clear on cleanup
useEffect(() => {
  const id = setInterval(() => {
    updateData();
  }, 1000);

  return () => clearInterval(id);
}, []);
```

### 2. Using setInterval for API Calls

```javascript
// ‚ùå BAD: Can stack requests
setInterval(async () => {
  await fetchData(); // If slow, calls stack!
}, 5000);

// ‚úÖ GOOD: Wait for completion
async function poll() {
  await fetchData();
  setTimeout(poll, 5000);
}
```

### 3. Not Checking fetch Response

```javascript
// ‚ùå BAD: 404 doesn't throw!
fetch("/api/data")
  .then((r) => r.json())
  .catch((e) => console.log(e)); // Might not catch

// ‚úÖ GOOD: Check response.ok
fetch("/api/data")
  .then((r) => {
    if (!r.ok) throw new Error("HTTP error");
    return r.json();
  })
  .catch((e) => console.error(e));
```

### 4. Expecting Precise Timing

```javascript
// ‚ùå WRONG: Assumes exact 1000ms
setTimeout(() => {
  // Might be 1004ms, 1010ms, etc.
}, 1000);

// ‚úÖ RIGHT: Measure actual time
const start = Date.now();
setTimeout(() => {
  const elapsed = Date.now() - start;
  // Use elapsed, not assumed 1000ms
}, 1000);
```

### 5. Using setTimeout for Animation

```javascript
// ‚ùå BAD: Choppy, wastes battery
function animate() {
  updatePosition();
  setTimeout(animate, 16);
}

// ‚úÖ GOOD: Smooth, efficient
function animate() {
  updatePosition();
  requestAnimationFrame(animate);
}
```

---

## üí° Pro Tips for Interviews

1. **Mention event loop** - connect timers to async execution model
2. **Explain macrotasks** - setTimeout/setInterval go to macrotask queue
3. **Know the 4ms minimum** - shows deep understanding
4. **Discuss cleanup** - demonstrates production awareness
5. **Compare RAF vs setTimeout** - shows you know modern best practices
6. **Explain fetch quirks** - common interview topic
7. **Use real examples** - debounce, throttle, polling patterns

---

## üìö Quick Reference

### Timers

```javascript
setTimeout(fn, delay); // Execute once after delay
clearTimeout(id); // Cancel setTimeout
setInterval(fn, delay); // Repeat at interval
clearInterval(id); // Cancel setInterval
```

### Animation

```javascript
requestAnimationFrame(fn); // Sync with refresh rate
cancelAnimationFrame(id); // Cancel animation
requestIdleCallback(fn); // Run during idle time
```

### Fetch

```javascript
fetch(url, options); // HTTP request
```
