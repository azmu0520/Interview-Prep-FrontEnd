# JavaScript - Complete Interview Preparation Guide

### Comprehensive guide for Senior Frontend Engineer role

---

## ðŸ“‹ Table of Contents

1. [JavaScript Fundamentals](#1-javascript-fundamentals) - â­â­â­ CRITICAL
2. [Functions & Scope](#2-functions--scope) - â­â­â­ CRITICAL
3. [Asynchronous JavaScript](#3-asynchronous-javascript) - â­â­â­ CRITICAL
4. [Objects & Prototypes](#4-objects--prototypes) - â­â­â­ CRITICAL
5. [ES6+ Features](#5-es6-features) - â­â­ IMPORTANT
6. [DOM & Browser APIs](#6-dom--browser-apis) - â­â­ IMPORTANT
7. [Design Patterns](#7-design-patterns) - â­â­ IMPORTANT
8. [Performance & Optimization](#8-performance--optimization) - â­ GOOD TO KNOW
9. [Testing & Debugging](#9-testing--debugging) - â­ GOOD TO KNOW
10. [Modern JavaScript Ecosystem](#10-modern-javascript-ecosystem) - â­ GOOD TO KNOW

---

## 1. JavaScript Fundamentals

> â­â­â­ **CRITICAL**

### 1.1 Data Types & Type Coercion

#### Topics to Master:

- Primitive types (string, number, boolean, null, undefined, symbol, bigint)
- Reference types (objects, arrays, functions)
- Type coercion (implicit vs explicit)
- Truthy and falsy values
- typeof operator and its quirks
- Strict vs loose equality (=== vs ==)
- Value vs reference comparison
- Type conversion methods

#### Key Understanding Points:

- JavaScript is dynamically typed
- Primitives are immutable, objects are mutable
- Type coercion happens automatically in many operations
- `typeof null` returns "object" (historical bug)
- Strict equality (===) doesn't perform coercion
- Understanding coercion prevents bugs
- Reference types compared by reference, not value

#### Common Interview Questions:

- What's the difference between `null` and `undefined`?
- Why does `typeof null` return "object"?
- What are falsy values in JavaScript?
- What's the difference between `==` and `===`?
- How does type coercion work in JavaScript?
- What's the difference between primitive and reference types?

---

### 1.2 Variables & Hoisting

#### Topics to Master:

- var, let, const differences
- Variable hoisting
- Temporal Dead Zone (TDZ)
- Block scope vs function scope
- Global scope and global object
- Variable shadowing
- Best practices for variable declaration

#### Key Understanding Points:

- `var` is function-scoped and hoisted
- `let` and `const` are block-scoped
- `const` prevents reassignment, not immutability
- Hoisting moves declarations to top of scope
- TDZ prevents access before declaration with let/const
- Always use const by default, let when needed
- Avoid var in modern JavaScript

#### Common Interview Questions:

- What's hoisting in JavaScript?
- What's the difference between var, let, and const?
- What is the Temporal Dead Zone?
- Can you change a const object's properties?
- What's the scope of let and const?

---

### 1.3 Operators & Expressions

#### Topics to Master:

- Arithmetic operators
- Assignment operators
- Comparison operators
- Logical operators (&&, ||, !)
- Nullish coalescing operator (??)
- Optional chaining (?.)
- Ternary operator
- Comma operator
- Operator precedence

#### Key Understanding Points:

- Short-circuit evaluation in logical operators
- Nullish coalescing only checks null/undefined
- Optional chaining prevents errors on null/undefined
- Operator precedence affects evaluation order
- Logical operators return operands, not booleans
- Bitwise operators work on 32-bit integers

#### Common Interview Questions:

- What's the difference between `??` and `||`?
- How does short-circuit evaluation work?
- What does optional chaining do?
- What's operator precedence?
- How do logical operators behave with non-boolean values?

---

### 1.4 Control Flow

#### Topics to Master:

- if/else statements
- switch statements
- for loops (for, for...in, for...of)
- while and do...while loops
- break and continue
- Labeled statements
- Exception handling (try/catch/finally)

#### Key Understanding Points:

- for...in iterates over enumerable properties
- for...of iterates over iterable values
- switch uses strict equality (===)
- finally always executes (even with return)
- break/continue can use labels
- Use for...of for arrays, for...in for objects

#### Common Interview Questions:

- What's the difference between for...in and for...of?
- When should you use switch vs if/else?
- Does finally execute if there's a return in try?
- How do labeled statements work?

---

## 2. Functions & Scope

> â­â­â­ **CRITICAL**

### 2.1 Function Basics

#### Topics to Master:

- Function declarations vs expressions
- Arrow functions
- Function parameters and arguments
- Default parameters
- Rest parameters
- Arguments object
- Function hoisting
- Named vs anonymous functions

#### Key Understanding Points:

- Function declarations are hoisted, expressions aren't
- Arrow functions don't have their own `this`
- Rest parameters gather remaining arguments into array
- Default parameters evaluated at call time
- Arguments object is array-like, not real array
- Named functions better for debugging

#### Common Interview Questions:

- What's the difference between function declaration and expression?
- How do arrow functions differ from regular functions?
- What are default parameters?
- What's the arguments object?
- When should you use arrow functions?

---

### 2.2 Scope & Closures

#### Topics to Master:

- Lexical scope
- Scope chain
- Closures concept and use cases
- Module pattern with closures
- Private variables with closures
- Memory implications of closures
- IIFE (Immediately Invoked Function Expression)

#### Key Understanding Points:

- Closure is function + lexical environment
- Inner functions have access to outer variables
- Closures preserve variable references, not values
- Closures enable data privacy
- Can cause memory leaks if not careful
- IIFE creates isolated scope

#### Common Interview Questions:

- What is a closure?
- How do closures work?
- What are practical uses of closures?
- Can closures cause memory leaks?
- What's an IIFE and why use it?

---

### 2.3 The `this` Keyword

#### Topics to Master:

- this binding rules (implicit, explicit, new, default)
- this in different contexts (global, function, method, arrow)
- call, apply, bind methods
- this in event handlers
- this in classes
- Strict mode effects on this
- Arrow function this behavior

#### Key Understanding Points:

- `this` determined by how function is called
- Arrow functions inherit parent `this`
- call/apply/bind explicitly set `this`
- new creates new object and sets this
- Method calls set this to object
- Default binding in strict mode is undefined
- Event handlers set this to element

#### Common Interview Questions:

- What is `this` in JavaScript?
- How do you explicitly set `this`?
- What's the difference between call, apply, and bind?
- How does `this` work in arrow functions?
- What's `this` in an event handler?

---

### 2.4 Higher-Order Functions

#### Topics to Master:

- Functions as first-class citizens
- Callback functions
- Function composition
- Currying
- Partial application
- Pure functions
- Side effects

#### Key Understanding Points:

- Functions can be passed and returned
- Higher-order functions take/return functions
- Callbacks enable async operations
- Currying transforms multi-arg function
- Pure functions have no side effects
- Composition builds complex from simple

#### Common Interview Questions:

- What are higher-order functions?
- What's function composition?
- What's currying?
- What's the difference between currying and partial application?
- What are pure functions?

---

### 2.5 Recursion

#### Topics to Master:

- Recursion concept
- Base case and recursive case
- Call stack and stack overflow
- Tail call optimization
- Recursion vs iteration
- Common recursive patterns
- Memoization for recursion

#### Key Understanding Points:

- Recursion is function calling itself
- Must have base case to terminate
- Each call adds to call stack
- Stack overflow from too many calls
- Tail call optimization not widely supported
- Sometimes clearer than iteration
- Can be optimized with memoization

#### Common Interview Questions:

- What is recursion?
- When should you use recursion over iteration?
- What is tail call optimization?
- How do you prevent stack overflow?
- Can you implement factorial/fibonacci recursively?

---

## 3. Asynchronous JavaScript

> â­â­â­ **CRITICAL**

### 3.1 Event Loop & Concurrency

#### Topics to Master:

- Call stack
- Event loop mechanism
- Task queue (macrotasks)
- Microtask queue
- Stack vs heap
- Blocking vs non-blocking code
- Concurrency model
- setTimeout and setInterval

#### Key Understanding Points:

- JavaScript is single-threaded
- Event loop enables async operations
- Microtasks run before macrotasks
- Promises create microtasks
- setTimeout is minimum delay, not exact
- Long operations block event loop
- Understanding event loop critical for performance

#### Common Interview Questions:

- How does the event loop work?
- What's the difference between microtasks and macrotasks?
- Is JavaScript single-threaded?
- How does setTimeout(fn, 0) work?
- What happens when call stack is blocked?

---

### 3.2 Callbacks

#### Topics to Master:

- Callback pattern
- Callback hell (pyramid of doom)
- Error-first callbacks
- Asynchronous error handling
- Callback advantages and disadvantages
- Converting callbacks to promises

#### Key Understanding Points:

- Callbacks handle async operations
- Nested callbacks hard to read/maintain
- Error-first convention in Node.js
- Callbacks can't use try/catch
- Promises solve callback hell
- Still used in many APIs

#### Common Interview Questions:

- What are callbacks?
- What is callback hell?
- How do you handle errors in callbacks?
- What are the problems with callbacks?
- How do you convert callback to promise?

---

### 3.3 Promises

#### Topics to Master:

- Promise states (pending, fulfilled, rejected)
- Promise constructor
- then, catch, finally methods
- Promise chaining
- Error propagation
- Promise.all, Promise.race, Promise.allSettled, Promise.any
- Creating custom promises
- Promisification

#### Key Understanding Points:

- Promises represent eventual value
- Immutable once settled
- Chaining avoids callback hell
- Errors propagate through chain
- catch handles any previous error
- Promise.all fails fast on first rejection
- Microtask queue runs promise callbacks

#### Common Interview Questions:

- What are promises?
- What are promise states?
- How does promise chaining work?
- What's the difference between Promise.all and Promise.race?
- How do you handle errors in promises?
- What's Promise.allSettled?

---

### 3.4 Async/Await

#### Topics to Master:

- async function declaration
- await keyword
- Error handling with try/catch
- Async/await vs promises
- Parallel execution with Promise.all
- Top-level await
- Async iterators
- Common pitfalls

#### Key Understanding Points:

- Async functions always return promises
- Await pauses execution until promise settles
- Try/catch works with async/await
- Syntactic sugar over promises
- Sequential awaits run in series
- Use Promise.all for parallel operations
- Can't use await in regular functions

#### Common Interview Questions:

- What is async/await?
- How do you handle errors with async/await?
- What's the difference between async/await and promises?
- Can you use await outside async functions?
- How do you run async operations in parallel?

---

### 3.5 Web APIs & Timers

#### Topics to Master:

- setTimeout and clearTimeout
- setInterval and clearInterval
- requestAnimationFrame
- requestIdleCallback
- Fetch API
- Web Workers
- Timers accuracy and limitations

#### Key Understanding Points:

- Timers are Web APIs, not JavaScript
- Delays are minimum, not guaranteed
- setInterval can stack calls
- requestAnimationFrame for animations
- Fetch returns promises
- Web Workers run in separate thread
- Timers callback in macrotask queue

#### Common Interview Questions:

- What's the difference between setTimeout and setInterval?
- Why use requestAnimationFrame for animations?
- How do Web Workers work?
- What's the minimum timeout in browsers?
- Can timers be perfectly accurate?

---

## 4. Objects & Prototypes

> â­â­â­ **CRITICAL**

### 4.1 Object Fundamentals

#### Topics to Master:

- Object creation (literal, constructor, Object.create)
- Property access (dot vs bracket notation)
- Property descriptors (value, writable, enumerable, configurable)
- Object.defineProperty and Object.defineProperties
- Property enumeration
- Object.keys, values, entries
- in operator vs hasOwnProperty
- Property deletion

#### Key Understanding Points:

- Objects are collections of properties
- Properties have descriptors
- Bracket notation for dynamic keys
- hasOwnProperty checks own properties
- Enumerable properties show in loops
- Object.keys only returns own properties
- Delete operator removes properties

#### Common Interview Questions:

- How many ways can you create objects?
- What are property descriptors?
- What's the difference between in and hasOwnProperty?
- How do you make a property non-enumerable?
- What's the difference between Object.keys and for...in?

---

### 4.2 Prototypes & Inheritance

#### Topics to Master:

- Prototype chain
- **proto** vs prototype
- Object.getPrototypeOf and Object.setPrototypeOf
- Constructor functions
- new operator behavior
- instanceof operator
- Prototypal inheritance
- Object.create for inheritance
- Shadowing properties

#### Key Understanding Points:

- Every object has a prototype
- Prototype chain enables inheritance
- **proto** accesses object's prototype
- prototype property on functions
- new sets up prototype chain
- Constructor functions create instances
- Properties looked up through chain
- Own properties shadow prototype properties

#### Common Interview Questions:

- What is the prototype chain?
- What's the difference between **proto** and prototype?
- How does prototypal inheritance work?
- What does the new operator do?
- How do you check if property is own or inherited?

---

### 4.3 Classes (ES6+)

#### Topics to Master:

- Class declaration and expression
- Constructor method
- Instance methods and properties
- Static methods and properties
- Getters and setters
- Class inheritance (extends)
- super keyword
- Private fields (#)
- Public class fields

#### Key Understanding Points:

- Classes are syntactic sugar over prototypes
- Constructor runs on instantiation
- Static members on class itself
- Extends sets up prototype chain
- super accesses parent class
- Private fields truly private
- Class fields initialize before constructor

#### Common Interview Questions:

- What are ES6 classes?
- How do classes relate to prototypes?
- What's the difference between static and instance methods?
- How does inheritance work with classes?
- What are private fields?

---

### 4.4 Object Manipulation

#### Topics to Master:

- Object.assign for copying/merging
- Spread operator with objects
- Object destructuring
- Object.freeze, Object.seal, Object.preventExtensions
- Deep vs shallow copy
- Cloning techniques
- Object comparison
- Object.is vs ===

#### Key Understanding Points:

- Object.assign creates shallow copy
- Spread operator also shallow
- Freeze makes object immutable
- Seal prevents add/remove properties
- Deep clone needs recursion or library
- Objects compared by reference
- Object.is handles NaN and -0/+0

#### Common Interview Questions:

- How do you clone an object?
- What's the difference between shallow and deep copy?
- What's the difference between freeze and seal?
- How do you merge objects?
- How is Object.is different from ===?

---

## 5. ES6+ Features

> â­â­ **IMPORTANT**

### 5.1 Destructuring

#### Topics to Master:

- Array destructuring
- Object destructuring
- Nested destructuring
- Default values
- Rest in destructuring
- Renaming in object destructuring
- Destructuring in function parameters
- Swapping variables

#### Key Understanding Points:

- Extract values into variables
- Works with arrays and objects
- Can provide defaults
- Rest gathers remaining items
- Object destructuring uses property names
- Great for function parameters
- Common in modern JavaScript

#### Common Interview Questions:

- What is destructuring?
- How do you provide default values?
- How do you rename destructured properties?
- Can you destructure nested objects?
- How do you swap variables using destructuring?

---

### 5.2 Spread & Rest Operators

#### Topics to Master:

- Spread operator (...)
- Spread with arrays
- Spread with objects
- Rest parameters
- Rest in destructuring
- Spread vs rest
- Use cases and patterns

#### Key Understanding Points:

- Spread expands iterables
- Rest collects into array
- Same syntax, different context
- Spread creates shallow copy
- Rest must be last parameter
- Works with any iterable
- Very common in modern code

#### Common Interview Questions:

- What's the spread operator?
- What's the difference between spread and rest?
- How do you merge arrays?
- How do you copy an array?
- Can you use spread with objects?

---

### 5.3 Template Literals

#### Topics to Master:

- Template literal syntax
- String interpolation
- Multi-line strings
- Tagged templates
- Expression in templates
- Nesting templates
- Raw strings

#### Key Understanding Points:

- Backticks (`) create template literals
- ${} for interpolation
- Multi-line without \n
- Tagged templates for custom processing
- Can contain any expression
- Cleaner than concatenation
- Widely supported and used

#### Common Interview Questions:

- What are template literals?
- What are tagged templates?
- How do you create multi-line strings?
- Can you nest template literals?

---

### 5.4 Modules (Import/Export)

#### Topics to Master:

- Named exports
- Default exports
- Import syntax variations
- Re-exporting
- Dynamic imports
- Module scope
- CommonJS vs ES Modules
- Tree shaking

#### Key Understanding Points:

- Modules create separate scope
- Named exports export multiple items
- One default export per module
- Import creates bindings (not copies)
- Dynamic import returns promise
- ES modules static structure
- Tree shaking removes unused code

#### Common Interview Questions:

- What's the difference between named and default exports?
- How do dynamic imports work?
- What's the difference between ES modules and CommonJS?
- What is tree shaking?
- Can you re-export from modules?

---

### 5.5 Symbols & Iterators

#### Topics to Master:

- Symbol primitive type
- Symbol.for and Symbol.keyFor
- Well-known symbols
- Iterator protocol
- Iterable protocol
- Generators
- yield keyword
- Custom iterables

#### Key Understanding Points:

- Symbols are unique identifiers
- Used for private-ish properties
- Well-known symbols customize behavior
- Iterators define iteration behavior
- Generators simplify iterator creation
- for...of uses iterator protocol
- yield pauses generator execution

#### Common Interview Questions:

- What are symbols?
- How do iterators work?
- What are generators?
- What's the iterator protocol?
- How do you create a custom iterable?

---

### 5.6 Maps & Sets

#### Topics to Master:

- Map vs Object
- Map methods (get, set, has, delete, clear)
- WeakMap
- Set operations
- WeakSet
- Use cases for each
- Performance considerations

#### Key Understanding Points:

- Map allows any key type
- Set stores unique values
- WeakMap/WeakSet allow garbage collection
- Map maintains insertion order
- Set useful for uniqueness
- Better performance for certain operations
- WeakMap keys must be objects

#### Common Interview Questions:

- What's the difference between Map and Object?
- When should you use Set?
- What are WeakMap and WeakSet?
- How do you check if Set has a value?
- Can Map keys be objects?

---

## 6. DOM & Browser APIs

> â­â­ **IMPORTANT**

### 6.1 DOM Manipulation

#### Topics to Master:

- Selecting elements (querySelector, getElementById, etc.)
- Creating elements (createElement, createTextNode)
- Modifying elements (textContent, innerHTML, classList)
- Attributes (getAttribute, setAttribute, dataset)
- Traversing DOM (parentElement, children, nextSibling)
- Inserting/removing elements
- DocumentFragment
- Performance considerations

#### Key Understanding Points:

- querySelector uses CSS selectors
- innerHTML can be security risk (XSS)
- classList better than className
- dataset accesses data-\* attributes
- Batch DOM changes for performance
- DocumentFragment for multiple inserts
- Modern APIs more flexible

#### Common Interview Questions:

- What's the difference between innerHTML and textContent?
- How do you select elements?
- What are data attributes?
- How do you optimize DOM manipulation?
- What's DocumentFragment?

---

### 6.2 Event Handling

#### Topics to Master:

- addEventListener and removeEventListener
- Event object properties
- Event bubbling and capturing
- Event delegation
- preventDefault and stopPropagation
- Event types (click, input, submit, etc.)
- Custom events
- Once option for listeners

#### Key Understanding Points:

- Events bubble up from target to root
- Capturing is opposite of bubbling
- Event delegation uses bubbling
- preventDefault stops default behavior
- stopPropagation stops bubbling
- removeEventListener needs same function reference
- Event delegation improves performance

#### Common Interview Questions:

- What's event bubbling and capturing?
- What's event delegation?
- What's the difference between preventDefault and stopPropagation?
- How do you remove event listeners?
- What are custom events?

---

### 6.3 Browser Storage

#### Topics to Master:

- localStorage
- sessionStorage
- Cookies
- IndexedDB
- Storage limits
- Storage events
- Security considerations
- Best practices

#### Key Understanding Points:

- localStorage persists across sessions
- sessionStorage cleared when tab closes
- Both store strings only
- Cookies sent with requests
- IndexedDB for large data
- Storage is synchronous
- Same-origin policy applies
- Always JSON.stringify/parse for objects

#### Common Interview Questions:

- What's the difference between localStorage and sessionStorage?
- How much can you store?
- How do you store objects?
- What are cookies used for?
- When should you use IndexedDB?

---

### 6.4 Browser APIs

#### Topics to Master:

- Fetch API
- Geolocation API
- History API
- Notification API
- Web Storage API
- Intersection Observer
- Mutation Observer
- ResizeObserver

#### Key Understanding Points:

- Fetch replaces XMLHttpRequest
- Fetch returns promises
- Many APIs require user permission
- Observers enable efficient watching
- History API for SPA routing
- Feature detection important
- Polyfills for older browsers

#### Common Interview Questions:

- How does the Fetch API work?
- What's Intersection Observer?
- How do you handle browser compatibility?
- What's the History API used for?

---

## 7. Design Patterns

> â­â­ **IMPORTANT**

### 7.1 Creational Patterns

#### Topics to Master:

- Singleton pattern
- Factory pattern
- Constructor pattern
- Module pattern
- Revealing module pattern
- Prototype pattern

#### Key Understanding Points:

- Singleton ensures single instance
- Factory creates objects without specifying class
- Module pattern creates private scope
- Each pattern solves specific problem
- Modern JavaScript has better alternatives
- Understanding helps read legacy code

#### Common Interview Questions:

- What is the singleton pattern?
- What's the module pattern?
- When would you use factory pattern?
- How do you implement these in JavaScript?

---

### 7.2 Structural Patterns

#### Topics to Master:

- Decorator pattern
- Facade pattern
- Adapter pattern
- Proxy pattern
- Composite pattern
- Flyweight pattern

#### Key Understanding Points:

- Decorator adds functionality
- Facade simplifies interface
- Adapter makes incompatible interfaces work
- Proxy controls access
- ES6 Proxy native support
- Patterns compose behaviors

#### Common Interview Questions:

- What is the decorator pattern?
- How does the proxy pattern work?
- What's a facade?
- How do you implement adapter pattern?

---

### 7.3 Behavioral Patterns

#### Topics to Master:

- Observer pattern (Pub/Sub)
- Strategy pattern
- Command pattern
- Chain of responsibility
- Iterator pattern
- Mediator pattern
- State pattern

#### Key Understanding Points:

- Observer enables loose coupling
- Strategy encapsulates algorithms
- Command encapsulates requests
- Patterns define object interactions
- Many built into modern frameworks
- EventEmitter is observer pattern

#### Common Interview Questions:

- What is the observer pattern?
- Explain pub/sub pattern
- What's the strategy pattern?
- How does the command pattern work?

---

## 8. Performance & Optimization

> â­ **GOOD TO KNOW**

### 8.1 Performance Optimization

#### Topics to Master:

- Debouncing and throttling
- Lazy loading
- Code splitting
- Memoization
- Virtual DOM concept
- Minimizing reflows/repaints
- RequestAnimationFrame
- Performance API

#### Key Understanding Points:

- Debounce delays execution
- Throttle limits execution rate
- Lazy loading defers resource loading
- Memoization caches results
- Minimize DOM manipulation
- Use DevTools for profiling
- RequestAnimationFrame for smooth animations

#### Common Interview Questions:

- What's the difference between debounce and throttle?
- How do you optimize render performance?
- What is memoization?
- How do you measure performance?

---

### 8.2 Memory Management

#### Topics to Master:

- Garbage collection
- Memory leaks
- Common leak causes (event listeners, closures, timers)
- WeakMap and WeakSet for memory
- Memory profiling
- Best practices

#### Key Understanding Points:

- JavaScript has automatic garbage collection
- References prevent garbage collection
- Remove event listeners to prevent leaks
- Clear timers when done
- Large closures can cause leaks
- Use DevTools memory profiler

#### Common Interview Questions:

- How does garbage collection work?
- What causes memory leaks?
- How do you detect memory leaks?
- How do you prevent memory leaks?

---

## 9. Testing & Debugging

> â­ **GOOD TO KNOW**

### 9.1 Debugging Techniques

#### Topics to Master:

- Browser DevTools
- Console methods (log, error, table, time)
- Breakpoints and debugging
- Source maps
- Error handling
- Stack traces
- Performance profiling

#### Key Understanding Points:

- DevTools essential for debugging
- Console.log not just for logging
- Breakpoints pause execution
- Source maps map minified to source
- Always handle errors gracefully
- Stack traces show call hierarchy

#### Common Interview Questions:

- What debugging tools do you use?
- How do you debug async code?
- What are source maps?
- How do you profile performance?

---

### 9.2 Testing Fundamentals

#### Topics to Master:

- Unit testing
- Integration testing
- Testing frameworks (Jest, Mocha)
- Assertions
- Mocking and stubbing
- Test-driven development (TDD)
- Code coverage

#### Key Understanding Points:

- Tests ensure code works as expected
- Unit tests test isolated functions
- Integration tests test interactions
- Mocking isolates dependencies
- TDD writes tests first
- High coverage doesn't guarantee quality
- Tests are documentation

#### Common Interview Questions:

- What types of testing do you know?
- What is TDD?
- How do you mock dependencies?
- What's code coverage?

---

## 10. Modern JavaScript Ecosystem

> â­ **GOOD TO KNOW**

### 10.1 Build Tools & Bundlers

#### Topics to Master:

- Webpack basics
- Vite
- Rollup
- Babel transpilation
- Module bundling concept
- Tree shaking
- Code splitting
- Source maps

#### Key Understanding Points:

- Bundlers combine modules
- Babel converts modern JS
- Tree shaking removes unused code
- Code splitting improves load time
- Vite faster for development
- Build tools optimize production code

#### Common Interview Questions:

- What is a bundler?
- What's the difference between Webpack and Vite?
- What is tree shaking?
- What does Babel do?

---

### 10.2 Package Management

#### Topics to Master:

- npm and yarn
- package.json structure
- Semantic versioning
- npm scripts
- Dependencies vs devDependencies
- package-lock.json / yarn.lock
- Publishing packages

#### Key Understanding Points:

- npm is package manager
- package.json defines project
- Semantic versioning (major.minor.patch)
- Lock files ensure consistency
- Scripts automate tasks
- DevDependencies only for development

#### Common Interview Questions:

- What is npm?
- What's semantic versioning?
- What's the difference between dependencies and devDependencies?
- What's package-lock.json for?

---

## Additional Study Resources

### Practice Projects:

1. **Todo App with Vanilla JS**

   - DOM manipulation, events, storage
   - Practice: All fundamentals

2. **Promise Implementation**

   - Build your own Promise class
   - Practice: Async, classes, callbacks

3. **Event Emitter**

   - Pub/sub pattern implementation
   - Practice: Design patterns, closures

4. **Debounce/Throttle Implementation**

   - Build utility functions
   - Practice: Closures, timers, higher-order functions

5. **Mini Framework**
   - Simple reactive framework
   - Practice: Advanced concepts, design patterns

### Common Coding Challenges:

1. Implement debounce and throttle
2. Deep clone an object
3. Flatten nested array
4. Implement Promise.all
5. Event delegation system
6. LRU Cache implementation
7. Custom map/filter/reduce
8. Async retry mechanism
9. Curry function implementation
10. Deep object comparison

### Books and References:

- You Don't Know JS (Kyle Simpson)
- JavaScript: The Good Parts (Douglas Crockford)
- Eloquent JavaScript (Marijn Haverbeke)
- JavaScript AllongÃ© (Reg Braithwaite)
- MDN Web Docs (comprehensive reference)

### Online Practice:

- JavaScript30 (Wes Bos)
- LeetCode (JavaScript problems)
- Codewars
- HackerRank
- FreeCodeCamp

---

## Interview Preparation Checklist

### Core JavaScript (Weeks 1-2)

- [ ] Master data types and coercion
- [ ] Understand variables and hoisting
- [ ] Practice with operators
- [ ] Control flow mastery

### Functions & Scope (Week 3)

- [ ] Function types and usage
- [ ] Closures deeply understood
- [ ] Master `this` keyword
- [ ] Higher-order functions practice

### Async Programming (Week 4)

- [ ] Event loop visualization
- [ ] Promises mastery
- [ ] Async/await fluency
- [ ] Build async projects

### Objects & OOP (Week 5)

- [ ] Prototypes understanding
- [ ] Classes and inheritance
- [ ] Object manipulation
- [ ] Build OOP projects

### Modern Features (Week 6)

- [ ] ES6+ features practice
- [ ] Destructuring fluency
- [ ] Modules understanding
- [ ] Maps, Sets, Symbols

### Browser & DOM (Week 7)

- [ ] DOM manipulation practice
- [ ] Event handling mastery
- [ ] Browser APIs knowledge
- [ ] Build interactive projects

### Patterns & Performance (Week 8)

- [ ] Common design patterns
- [ ] Performance optimization
- [ ] Memory management
- [ ] Code review practice

### Before Interview:

- [ ] Review all CRITICAL sections daily
- [ ] Practice coding challenges (2 per day)
- [ ] Do mock interviews
- [ ] Review your project code
- [ ] Prepare examples and stories
- [ ] Practice explaining concepts
- [ ] Review common interview questions

---

## Key Principles to Remember

1. **JavaScript is Single-Threaded**: Event loop handles async operations
2. **Everything is an Object**: (Almost) everything inherits from Object.prototype
3. **Functions are First-Class Citizens**: Can be passed, returned, assigned
4. **Prototypal Inheritance**: Objects inherit from other objects, not classes
5. **Closures are Powerful**: Enable data privacy and functional patterns
6. **This is Dynamic**: Determined by call-site, not definition
7. **Async is Non-Blocking**: Callbacks, promises, async/await for concurrency
8. **Coercion Happens**: Understand implicit type conversion
9. **Let Event Loop Work**: Don't block with long synchronous operations
10. **Immutability Matters**: Avoid mutations when possible for predictability
11. **Scope Chain is Lexical**: Inner functions access outer variables
12. **Modern Features Improve Code**: Use ES6+ for cleaner, more maintainable code
13. **Performance Costs Matter**: Profile before optimizing
14. **Handle Errors Gracefully**: Always plan for failure cases
15. **Read the Specs**: ECMAScript spec defines JavaScript behavior

---

## Interview Success Tips

### Technical Preparation:

- **Code Daily**: Practice coding challenges every day
- **Build Projects**: Apply concepts in real applications
- **Explain Out Loud**: Practice explaining concepts verbally
- **Read Others' Code**: Learn from open source projects
- **Debug Deliberately**: Don't just fix, understand why

### During the Interview:

- **Think Out Loud**: Explain your reasoning process
- **Ask Clarifying Questions**: Ensure you understand the problem
- **Start Simple**: Get basic solution working first
- **Consider Edge Cases**: Think about error conditions
- **Discuss Trade-offs**: Show you understand pros/cons
- **Be Honest**: Say "I don't know but here's how I'd find out"
- **Stay Calm**: It's okay to take time to think

### Common Interview Topics (Be Extra Prepared):

1. **Closures** - Appears in 90% of JavaScript interviews
2. **Promises & Async/Await** - Essential for modern development
3. **Event Loop** - Shows deep understanding
4. **This Keyword** - Common source of confusion
5. **Prototypes** - Fundamental to JavaScript
6. **Array Methods** - map, filter, reduce usage
7. **Event Delegation** - Efficient event handling
8. **Debounce/Throttle** - Performance optimization
9. **Deep vs Shallow Copy** - Object manipulation
10. **Memory Leaks** - Shows production awareness

---

## Quick Reference: Must-Know Code Snippets

### Debounce Implementation

```javascript
function debounce(fn, delay) {
  let timeoutId;
  return function (...args) {
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => fn.apply(this, args), delay);
  };
}
```

### Throttle Implementation

```javascript
function throttle(fn, limit) {
  let inThrottle;
  return function (...args) {
    if (!inThrottle) {
      fn.apply(this, args);
      inThrottle = true;
      setTimeout(() => (inThrottle = false), limit);
    }
  };
}
```

### Deep Clone

```javascript
function deepClone(obj) {
  if (obj === null || typeof obj !== "object") return obj;
  if (obj instanceof Date) return new Date(obj);
  if (obj instanceof Array) return obj.map((item) => deepClone(item));

  const cloned = {};
  for (let key in obj) {
    if (obj.hasOwnProperty(key)) {
      cloned[key] = deepClone(obj[key]);
    }
  }
  return cloned;
}
```

### Promise.all Implementation

```javascript
function promiseAll(promises) {
  return new Promise((resolve, reject) => {
    if (!Array.isArray(promises)) {
      return reject(new TypeError("Argument must be an array"));
    }

    const results = [];
    let completed = 0;

    if (promises.length === 0) {
      return resolve(results);
    }

    promises.forEach((promise, index) => {
      Promise.resolve(promise)
        .then((value) => {
          results[index] = value;
          completed++;
          if (completed === promises.length) {
            resolve(results);
          }
        })
        .catch(reject);
    });
  });
}
```

### Curry Function

```javascript
function curry(fn) {
  return function curried(...args) {
    if (args.length >= fn.length) {
      return fn.apply(this, args);
    }
    return function (...nextArgs) {
      return curried.apply(this, args.concat(nextArgs));
    };
  };
}
```

---

## Final Thoughts

JavaScript is a language with many quirks and "gotchas", but understanding its fundamental principles will make you a stronger developer. Focus on:

- **Core concepts** before frameworks
- **Why** things work, not just how
- **Practical application** of patterns
- **Performance implications** of your choices
- **Clean, readable code** over clever tricks

Remember: Interviews test problem-solving and communication as much as technical knowledge. Show your thought process, admit what you don't know, and demonstrate your ability to learn.

Good luck with your interview! ðŸš€

---

## Contributing

Found an error or want to add content? Contributions are welcome! Please feel free to submit a pull request or open an issue.

## License

This guide is open source and available for anyone preparing for JavaScript interviews.

---

**Last Updated**: January 2026
**Target Role**: Senior Frontend Engineer
**Focus**: Interview Preparation & Deep Understanding
