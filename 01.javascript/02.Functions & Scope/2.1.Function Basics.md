# 2.1 Function Basics - Theoretical Deep Dive

### JavaScript Interview Preparation for Senior Frontend Engineer

---

## üéØ Key Concepts

### What are Functions?

Functions are reusable blocks of code that perform specific tasks. They're first-class citizens in JavaScript, meaning they can be assigned to variables, passed as arguments, and returned from other functions.

---

## 1. Function Declarations vs Expressions

### Basic Concept

**What it means:**
Two primary ways to define functions in JavaScript, differing in syntax, hoisting behavior, and use cases.

**Function Declaration:**

```javascript
function greet(name) {
  return `Hello, ${name}`;
}
```

**Function Expression:**

```javascript
const greet = function (name) {
  return `Hello, ${name}`;
};
```

**How They Work:**

**Function Declaration:**

- Named function defined at parse time
- Fully hoisted (entire function available before declaration)
- Can be called before the line where it's defined
- Creates a function in the current scope

**Function Expression:**

- Function assigned to a variable
- Only variable declaration is hoisted, not the function
- Cannot be called before the assignment line
- More flexible (can be anonymous or named)

**Key Understanding Points:**

| Feature                    | Declaration          | Expression                   |
| -------------------------- | -------------------- | ---------------------------- |
| **Hoisting**               | ‚úÖ Fully hoisted     | ‚ùå Variable hoisted only     |
| **Name Required**          | ‚úÖ Yes               | ‚ùå Optional                  |
| **Call Before Definition** | ‚úÖ Yes               | ‚ùå No                        |
| **Syntax**                 | `function name() {}` | `const name = function() {}` |
| **Modern Usage**           | Less common          | More common                  |

**Hoisting Behavior Deep Dive:**

```javascript
// Declaration - Works!
greet(); // "Hello!"
function greet() {
  return "Hello!";
}

// Expression - Error!
sayHi(); // TypeError: sayHi is not a function
const sayHi = function() {
  return "Hi!";
};

// Why? Because it's hoisted like this:
const sayHi; // Declaration hoisted (undefined)
sayHi(); // Calling undefined()
sayHi = function() {}; // Assignment here
```

**Why This Matters:**

- Understanding hoisting prevents bugs
- Modern codebases prefer expressions for consistency
- Expressions work better with const/let
- Declarations can lead to confusing execution order

**Named Function Expressions:**

```javascript
const factorial = function fact(n) {
  if (n <= 1) return 1;
  return n * fact(n - 1); // Can call itself by name
};
// 'fact' only available inside the function
// Outside: factorial() works, fact() doesn't
```

**Interview Question & Perfect Answer:**

**Q: What's the difference between function declarations and function expressions?**

**Perfect Answer:**

> "The key differences are syntax, hoisting, and usage patterns:
>
> **Function Declaration** (`function name() {}`):
>
> - Fully hoisted - the entire function is available before the line where it's defined
> - Must have a name
> - Can be called anywhere in the scope, even before declaration
> - Example: `greet()` works even if called before `function greet() {}`
>
> **Function Expression** (`const name = function() {}`):
>
> - Only the variable declaration is hoisted, not the function assignment
> - Can be anonymous or named
> - Cannot be called before the assignment line
> - With `const`, you get TDZ protection
> - More flexible - can be conditional: `const fn = condition ? fn1 : fn2`
>
> Modern JavaScript prefers expressions because:
>
> 1. Works better with `const` - prevents accidental reassignment
> 2. More explicit about when function is available
> 3. Consistent with other variable declarations
> 4. Better for conditional function creation
>
> However, declarations are still valid and useful for utility functions where hoisting improves readability."

**Q: What's the output and why?**

```javascript
console.log(typeof foo);
console.log(typeof bar);

function foo() {}
var bar = function () {};
```

**Perfect Answer:**

> "The output is:
>
> ```
> function
> undefined
> ```
>
> Here's why: Both get hoisted, but differently.
>
> **`foo` (declaration):**
>
> - The entire function is hoisted
> - At the top of scope, `foo` is already the function
> - `typeof foo` returns `'function'`
>
> **`bar` (expression with `var`):**
>
> - Only `var bar` is hoisted, initialized as `undefined`
> - The function assignment `= function() {}` happens at runtime
> - At the top, `bar` is `undefined`
> - `typeof bar` returns `'undefined'`
>
> The code effectively becomes:
>
> ```javascript
> function foo() {} // Entire function hoisted
> var bar; // Only declaration hoisted
>
> console.log(typeof foo); // 'function'
> console.log(typeof bar); // 'undefined'
>
> bar = function () {}; // Assignment happens here
> ```
>
> This demonstrates why understanding hoisting is crucial and why modern code prefers `const` with function expressions - it would throw ReferenceError instead of silently returning undefined."

---

## 2. Arrow Functions

### Basic Concept

**What it means:**
A concise syntax for writing functions introduced in ES6, with lexical `this` binding and implicit returns.

**Syntax Evolution:**

```javascript
// Traditional function
function add(a, b) {
  return a + b;
}

// Function expression
const add = function (a, b) {
  return a + b;
};

// Arrow function - full syntax
const add = (a, b) => {
  return a + b;
};

// Arrow function - implicit return
const add = (a, b) => a + b;

// Single parameter - no parentheses
const square = (x) => x * x;

// No parameters - empty parentheses
const getRandom = () => Math.random();

// Returning object - wrap in parentheses
const makePerson = (name) => ({ name, age: 30 });
```

**How It Works:**

Arrow functions are syntactic sugar with important behavioral differences:

1. No own `this` binding (inherits from parent scope)
2. No `arguments` object
3. Cannot be used as constructors
4. No `prototype` property
5. Cannot be generators (no `function*`)

**Critical Differences from Regular Functions:**

### 1. Lexical `this` Binding (MOST IMPORTANT!)

**What it means:** Arrow functions don't have their own `this`. They capture `this` from the surrounding scope where they're defined.

```javascript
// Regular function - 'this' depends on HOW it's called
const person = {
  name: "Alice",
  greet: function () {
    setTimeout(function () {
      console.log(this.name); // undefined (this is window/global)
    }, 1000);
  },
};

// Arrow function - 'this' from WHERE it's defined
const person = {
  name: "Alice",
  greet: function () {
    setTimeout(() => {
      console.log(this.name); // "Alice" (inherits from greet)
    }, 1000);
  },
};
```

**Why This Matters:**

- Solves the "this confusion" in callbacks
- No need for `.bind(this)` or `const self = this`
- Perfect for callbacks in methods
- But problematic as object methods

### 2. No `arguments` Object

```javascript
// Regular function - has arguments
function sum() {
  return Array.from(arguments).reduce((a, b) => a + b);
}
sum(1, 2, 3); // 6

// Arrow function - no arguments, use rest parameters
const sum = (...args) => args.reduce((a, b) => a + b);
sum(1, 2, 3); // 6
```

### 3. Cannot Use as Constructor

```javascript
// Regular function - can use 'new'
function Person(name) {
  this.name = name;
}
const p = new Person("Alice"); // ‚úÖ Works

// Arrow function - cannot use 'new'
const Person = (name) => {
  this.name = name;
};
const p = new Person("Alice"); // ‚ùå TypeError: Person is not a constructor
```

### 4. No `prototype` Property

```javascript
function regular() {}
console.log(regular.prototype); // {} (exists)

const arrow = () => {};
console.log(arrow.prototype); // undefined (doesn't exist)
```

**Key Understanding Points:**

**When to Use Arrow Functions:**

- ‚úÖ Callbacks (map, filter, forEach, setTimeout)
- ‚úÖ When you want to preserve outer `this`
- ‚úÖ Short, simple functions
- ‚úÖ Functional programming patterns
- ‚úÖ Promise chains and async operations

**When NOT to Use Arrow Functions:**

- ‚ùå Object methods (loses `this` context)
- ‚ùå Event handlers needing element `this`
- ‚ùå Functions needing `arguments` object
- ‚ùå Constructors
- ‚ùå Methods that need to be dynamically bound
- ‚ùå When function name aids debugging

**Interview Question & Perfect Answer:**

**Q: Explain the key differences between arrow functions and regular functions.**

**Perfect Answer:**

> "Arrow functions differ from regular functions in five critical ways:
>
> **1. Lexical `this` Binding** (most important):
>
> - Arrow functions don't have their own `this`
> - They inherit `this` from the parent scope where defined
> - Regular functions get `this` based on how they're called
> - Example: In `setTimeout(() => this.value)`, arrow captures outer `this`
> - This eliminates the need for `.bind(this)` in callbacks
>
> **2. No `arguments` Object:**
>
> - Arrow functions can't access `arguments`
> - Use rest parameters instead: `(...args) => {}`
> - Regular functions have `arguments` pseudo-array
>
> **3. Cannot be Constructors:**
>
> - Arrow functions can't use `new` keyword
> - They don't have `[[Construct]]` internal method
> - Regular functions can be constructors with `new`
>
> **4. No `prototype` Property:**
>
> - Arrow functions don't have `.prototype`
> - Regular functions have prototype for inheritance
>
> **5. Implicit Return:**
>
> - Single expression arrow functions return automatically
> - `const double = x => x * 2` (no return keyword needed)
> - Must use explicit return with block: `x => { return x * 2 }`
>
> **Practical Usage:**
>
> ```javascript
> // ‚úÖ Good: Arrow in callback
> array.map((item) => item * 2);
>
> // ‚ùå Bad: Arrow as method
> const obj = {
>   name: "Alice",
>   greet: () => console.log(this.name), // undefined!
> };
>
> // ‚úÖ Good: Regular function as method
> const obj = {
>   name: "Alice",
>   greet() {
>     console.log(this.name);
>   }, // Works!
> };
> ```
>
> Use arrow functions for callbacks and functional programming, but use regular functions for methods, constructors, and when you need dynamic `this` binding."

**Q: What's the output and why?**

```javascript
const obj = {
  name: "Alice",
  greet: () => {
    console.log(this.name);
  },
  greetNormal: function () {
    console.log(this.name);
  },
};

obj.greet();
obj.greetNormal();
```

**Perfect Answer:**

> "The output is:
>
> ```
> undefined
> Alice
> ```
>
> **`obj.greet()` outputs `undefined`:**
>
> - `greet` is an arrow function
> - Arrow functions don't have their own `this`
> - They inherit `this` from where they're defined
> - The object literal is not a scope, so `this` refers to the outer scope (global/window)
> - In global scope (or undefined in strict mode), there's no `name` property
>
> **`obj.greetNormal()` outputs `'Alice'`:**
>
> - `greetNormal` is a regular function
> - When called as `obj.greetNormal()`, `this` is set to `obj`
> - `this.name` correctly refers to `obj.name`
>
> **The key lesson:** Never use arrow functions as object methods when you need `this` to refer to the object. Arrow functions inherit `this` from the outer scope, not from how they're called.
>
> **Correct pattern for methods:**
>
> ```javascript
> const obj = {
>   name: "Alice",
>   greet() {
>     // Method shorthand
>     console.log(this.name);
>   },
> };
> ```
>
> **When arrow functions ARE useful in objects:**
>
> ```javascript
> const obj = {
>   name: "Alice",
>   delayedGreet() {
>     setTimeout(() => {
>       console.log(this.name); // Arrow inherits 'this' from delayedGreet
>     }, 1000);
>   },
> };
> ```
>
> Here, the arrow function inside the method correctly inherits `this` from the outer method."

---

## 3. Function Parameters

### Basic Concept

**What it means:**
JavaScript provides multiple ways to handle function inputs: default values, rest parameters, destructuring, and the legacy `arguments` object.

---

### 3.1 Default Parameters (ES6+)

**What it means:**
Parameters can have default values that are used when the argument is `undefined` or not provided.

**Syntax:**

```javascript
function greet(name = "Guest") {
  return `Hello, ${name}`;
}
```

**How It Works:**

- Default value is used ONLY when argument is `undefined` (or not passed)
- `null`, `0`, `""`, `false` DO NOT trigger default
- Defaults evaluated at call time, not definition time
- Can reference earlier parameters
- Can use expressions (including function calls)

**Key Understanding Points:**

**When Defaults Apply:**

```javascript
function test(a = 10) {
  console.log(a);
}

test(); // 10 (no argument ‚Üí default)
test(undefined); // 10 (undefined ‚Üí default)
test(null); // null (null !== undefined)
test(0); // 0 (0 !== undefined)
test(""); // "" (empty string !== undefined)
test(false); // false (false !== undefined)
```

**Defaults Are Evaluated at Call Time:**

```javascript
function greet(name = "Guest", time = new Date()) {
  return `Hello, ${name}! Time: ${time}`;
}

greet(); // Time is NOW
// Wait 1 second
greet(); // Time is different (re-evaluated!)
```

**Can Reference Earlier Parameters:**

```javascript
function makeFullName(first, last = first) {
  return `${first} ${last}`;
}
makeFullName("Alice"); // "Alice Alice"

function greet(name, greeting = `Hello, ${name}`) {
  return greeting;
}
greet("Alice"); // "Hello, Alice"
```

**Can Use Expressions:**

```javascript
function createUser(
  name,
  id = Math.random(),
  role = getUserRole(),
  timestamp = Date.now()
) {
  return { name, id, role, timestamp };
}
```

**Old Way (Before ES6):**

```javascript
// ‚ùå Bad: 0, false, "" become default
function greet(name) {
  name = name || "Guest"; // 0 becomes "Guest"!
}

// ‚úÖ Better: Check for undefined
function greet(name) {
  if (name === undefined) {
    name = "Guest";
  }
}

// ‚úÖ Best: Use default parameters
function greet(name = "Guest") {
  // Modern, clean, correct
}
```

**Interview Question & Perfect Answer:**

**Q: What's the difference between using `||` and default parameters for default values?**

**Perfect Answer:**

> "The key difference is when the default value is applied:
>
> **`||` operator (old way):**
>
> - Uses default for ALL falsy values
> - Falsy: `false`, `0`, `''`, `null`, `undefined`, `NaN`
> - Problem: Valid values like `0` or `''` trigger default
> - Example: `value || 50` makes `0` become `50`
>
> **Default parameters (modern):**
>
> - Uses default ONLY for `undefined`
> - Passing `null`, `0`, `''`, `false` uses those values
> - More precise control over when default applies
> - Example: `(value = 50)` only uses `50` if `undefined`
>
> **Practical example:**
>
> ```javascript
> // ‚ùå Problem with ||
> function setVolume(level) {
>   const volume = level || 50;
>   return volume;
> }
> setVolume(0); // 50 (wrong! 0 is valid)
> setVolume(25); // 25 (correct)
>
> // ‚úÖ Correct with default parameter
> function setVolume(level = 50) {
>   return level;
> }
> setVolume(0); // 0 (correct!)
> setVolume(null); // null (explicit null kept)
> setVolume(); // 50 (undefined ‚Üí default)
> ```
>
> **When to use each:**
>
> - Use default parameters (modern, correct for `undefined` check)
> - Use `||` only when you want ALL falsy values to trigger default
> - For `null`/`undefined` check, use nullish coalescing: `value ?? 50`
>
> Default parameters are the standard modern approach and should be preferred."

---

### 3.2 Rest Parameters (ES6+)

**What it means:**
Collects remaining arguments into a real array. Uses `...` syntax.

**Syntax:**

```javascript
function sum(...numbers) {
  return numbers.reduce((total, n) => total + n, 0);
}
```

**How It Works:**

- Collects all remaining arguments into an array
- Must be the last parameter
- Creates a real Array (not array-like)
- Can have parameters before rest
- Only one rest parameter allowed

**Key Understanding Points:**

**Rest Parameter Rules:**

```javascript
// ‚úÖ Correct: Rest is last
function log(level, ...messages) {
  console.log(`[${level}]`, ...messages);
}

// ‚ùå Error: Rest must be last
function wrong(...args, last) {} // SyntaxError

// ‚ùå Error: Only one rest parameter
function wrong(...a, ...b) {} // SyntaxError

// ‚úÖ Correct: Parameters before rest
function process(first, second, ...rest) {
  console.log(first); // First argument
  console.log(second); // Second argument
  console.log(rest); // Array of remaining arguments
}
```

**Rest vs Arguments:**

```javascript
// Old way: arguments object
function sumOld() {
  const args = Array.from(arguments); // Convert to array
  return args.reduce((a, b) => a + b);
}

// Modern: rest parameters
function sumModern(...numbers) {
  return numbers.reduce((a, b) => a + b); // Already an array!
}
```

**Real Array Methods:**

```javascript
function example(...args) {
  // All array methods work
  console.log(args.length);
  console.log(args.map((x) => x * 2));
  console.log(args.filter((x) => x > 0));
  console.log(Array.isArray(args)); // true
}
```

**Interview Question & Perfect Answer:**

**Q: What's the difference between rest parameters and the arguments object?**

**Perfect Answer:**

> "Rest parameters and `arguments` both collect function arguments, but they're fundamentally different:
>
> **Rest Parameters** (`...args`):
>
> - ES6 feature
> - Real Array - has all array methods (map, filter, reduce, etc.)
> - Only collects remaining arguments after named parameters
> - Can be used in arrow functions
> - Must be last parameter
> - Clearly declared in function signature
> - Example: `function sum(...numbers)`
>
> **Arguments Object:**
>
> - Legacy feature (pre-ES6)
> - Array-like object - NOT a real array
> - Has `length` and indices, but no array methods
> - Collects ALL arguments
> - NOT available in arrow functions
> - Always exists in regular functions (even if not used)
> - Must convert to array: `Array.from(arguments)` or `[...arguments]`
>
> **Comparison:**
>
> ```javascript
> // Old way: arguments
> function oldSum() {
>   const args = Array.from(arguments); // Must convert
>   return args.reduce((a, b) => a + b);
> }
>
> // Modern: rest parameters
> function modernSum(...numbers) {
>   return numbers.reduce((a, b) => a + b); // Already array!
> }
>
> // Arrow functions
> const arrowSum = (
>   ...numbers // ‚úÖ Works
> ) => numbers.reduce((a, b) => a + b);
>
> const arrowSumBad = () => {
>   return Array.from(arguments); // ‚ùå ReferenceError
> };
> ```
>
> **Key advantages of rest parameters:**
>
> 1. Real array with all methods
> 2. More explicit and readable
> 3. Works with arrow functions
> 4. Can separate initial parameters: `(first, ...rest)`
> 5. Modern standard
>
> **When you might still see arguments:**
>
> - Legacy code
> - When you need to modify arguments dynamically
> - Advanced meta-programming
>
> Always prefer rest parameters in modern code."

---

### 3.3 Arguments Object (Legacy)

**What it means:**
An array-like object available in all non-arrow functions containing all arguments passed to the function.

**Characteristics:**

```javascript
function example(a, b) {
  console.log(arguments); // [1, 2, 3, 4] (all arguments)
  console.log(arguments.length); // 4
  console.log(arguments[0]); // 1
  console.log(Array.isArray(arguments)); // false (array-like!)
}
example(1, 2, 3, 4);
```

**Key Understanding Points:**

- Array-like: has `length` and indices, but NO array methods
- Contains ALL arguments (not just undeclared ones)
- NOT available in arrow functions
- Has `callee` property (function itself) - deprecated in strict mode
- Must convert to array to use array methods

**Why It's Legacy:**

- Rest parameters are cleaner and more powerful
- Doesn't work with arrow functions
- Not a real array
- Can be confusing

---

### 3.4 Parameter Destructuring

**What it means:**
Destructure objects or arrays directly in the parameter list.

**Object Destructuring:**

```javascript
// Instead of this:
function greet(user) {
  return `Hello, ${user.name}! Age: ${user.age}`;
}

// Do this:
function greet({ name, age }) {
  return `Hello, ${name}! Age: ${age}`;
}

greet({ name: "Alice", age: 30 });
```

**With Defaults:**

```javascript
function greet({ name = "Guest", age = 0 } = {}) {
  return `Hello, ${name}! Age: ${age}`;
}

greet({ name: "Alice" }); // age defaults to 0
greet({}); // both default
greet(); // {} default, then properties default
```

**Array Destructuring:**

```javascript
function printCoords([x, y, z = 0]) {
  return `X: ${x}, Y: ${y}, Z: ${z}`;
}

printCoords([10, 20]); // Z defaults to 0
printCoords([10, 20, 30]);
```

**Nested Destructuring:**

```javascript
function processUser({ name, address: { city, country } }) {
  return `${name} from ${city}, ${country}`;
}

processUser({
  name: "Alice",
  address: { city: "NYC", country: "USA" },
});
```

---

## 4. Function Hoisting

### Basic Concept

**What it means:**
JavaScript moves function declarations to the top of their scope before code execution.

**How It Works:**

**Function Declarations - Fully Hoisted:**

```javascript
// You can do this:
greet(); // "Hello!"
function greet() {
  return "Hello!";
}

// Because JavaScript sees it as:
function greet() {
  return "Hello!";
}
greet();
```

**Function Expressions - Only Variable Hoisted:**

```javascript
// This breaks:
greet(); // TypeError: greet is not a function

var greet = function () {
  return "Hello!";
};

// Because JavaScript sees it as:
var greet; // Only declaration hoisted (undefined)
greet(); // Calling undefined()
greet = function () {}; // Assignment here
```

**With let/const - Temporal Dead Zone:**

```javascript
greet(); // ReferenceError: Cannot access before initialization

const greet = function () {
  return "Hello!";
};
```

**Key Understanding Points:**

- Only declarations are hoisted, not initializations
- Function declarations hoist completely
- Function expressions follow variable hoisting rules
- `var` hoists and initializes to `undefined`
- `let`/`const` hoist but are in TDZ until initialization

**Interview Question & Perfect Answer:**

**Q: Explain function hoisting with examples.**

**Perfect Answer:**

> "Hoisting is JavaScript's behavior of moving declarations to the top of their scope before execution. For functions, this behaves differently based on how they're defined:
>
> **Function Declarations - Fully Hoisted:**
>
> ```javascript
> greet(); // ‚úÖ Works! Outputs: "Hello"
>
> function greet() {
>   return "Hello";
> }
> ```
>
> The entire function is hoisted, so you can call it before the line where it's defined.
>
> **Function Expressions with `var` - Partially Hoisted:**
>
> ```javascript
> greet(); // ‚ùå TypeError: greet is not a function
>
> var greet = function () {
>   return "Hello";
> };
> ```
>
> Only `var greet` is hoisted (initialized to `undefined`), not the function assignment. You're essentially calling `undefined()`.
>
> **Function Expressions with `let`/`const` - TDZ:**
>
> ```javascript
> greet(); // ‚ùå ReferenceError: Cannot access before initialization
>
> const greet = function () {
>   return "Hello";
> };
> ```
>
> The variable is hoisted but in the Temporal Dead Zone. You cannot access it before the line where it's defined.
>
> **What Actually Happens (Hoisting Process):**
>
> ```javascript
> // Original code:
> console.log(typeof func1); // ?
> console.log(typeof func2); // ?
>
> function func1() {}
> var func2 = function () {};
>
> // After hoisting:
> function func1() {} // Entire function hoisted
> var func2; // Only declaration hoisted
>
> console.log(typeof func1); // "function"
> console.log(typeof func2); // "undefined"
>
> func2 = function () {}; // Assignment happens here
> ```
>
> **Why This Matters:**
>
> - Function declarations can be called anywhere in their scope
> - Function expressions must be defined before use
> - Modern code prefers `const` with function expressions for safety
> - Understanding hoisting prevents temporal ordering bugs
>
> **Best Practice:** Use `const` with function expressions to get clear errors if you accidentally call before definition, rather than subtle `undefined` bugs with `var`."

---

## üéØ Summary

### Function Types Quick Reference

| Type            | Syntax                    | Hoisted  | `this`  | `arguments` | Constructor |
| --------------- | ------------------------- | -------- | ------- | ----------- | ----------- |
| **Declaration** | `function name() {}`      | ‚úÖ Fully | Dynamic | ‚úÖ Yes      | ‚úÖ Yes      |
| **Expression**  | `const f = function() {}` | ‚ùå No    | Dynamic | ‚úÖ Yes      | ‚úÖ Yes      |
| **Arrow**       | `const f = () => {}`      | ‚ùå No    | Lexical | ‚ùå No       | ‚ùå No       |
| **Method**      | `obj = { method() {} }`   | ‚ùå No    | Dynamic | ‚úÖ Yes      | ‚ùå No       |

### When to Use What

**Use Function Declarations When:**

- Defining utility functions
- Order doesn't matter
- Traditional code style
- Need hoisting for readability

**Use Function Expressions When:**

- Modern codebase
- Conditional function creation
- Want const protection
- Consistent variable declarations

**Use Arrow Functions When:**

- Callbacks
- Array methods (map, filter)
- Preserving outer `this`
- Short, simple functions
- Functional programming

**Avoid Arrow Functions When:**

- Object methods
- Need dynamic `this`
- Need `arguments`
- Constructors
- Need function name

---

## üí° Pro Tips for Interviews

1. **Explain hoisting clearly:** "Function declarations hoist completely, expressions follow variable hoisting rules"
2. **Know `this` binding:** "Arrow functions inherit `this`, regular functions get it from how they're called"
3. **Default parameters vs `||`:** "Defaults only apply to `undefined`, `||` applies to all falsy values"
4. **Rest vs arguments:** "Rest creates real arrays and works with arrows, arguments is legacy"
5. **Connect to real work:** "I use arrow functions for callbacks to preserve `this`, but methods for object behavior"

---

## üö® Common Mistakes to Avoid

### 1. Arrow Function as Method

```javascript
// ‚ùå WRONG
const obj = {
  name: "Alice",
  greet: () => console.log(this.name), // undefined!
};

// ‚úÖ CORRECT
const obj = {
  name: "Alice",
  greet() {
    console.log(this.name);
  },
};
```

### 2. Using `||` for Defaults

```javascript
// ‚ùå WRONG - 0 becomes default
function setVolume(level) {
  return level || 50;
}

// ‚úÖ CORRECT
function setVolume(level = 50) {
  return level;
}
```

### 3. Calling Before Definition

```javascript
// ‚ùå ERROR with expression
greet();
const greet = function () {};

// ‚úÖ WORKS with declaration
greet();
function greet() {}
```

### 4. Rest Parameter Placement

```javascript
// ‚ùå WRONG - rest must be last
function wrong(...args, last) {}

// ‚úÖ CORRECT
function correct(first, ...rest) {}
```

---

**Remember:** Function basics are fundamental. Master declarations vs expressions, understand arrow functions' behavior with `this`, know how parameters work, and understand hoisting to avoid bugs and ace interviews!
