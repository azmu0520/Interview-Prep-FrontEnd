# Recursion - Theoretical Deep Dive

### JavaScript Interview Preparation for Senior Frontend Engineer

---

## ðŸŽ¯ Key Concepts

### What is Recursion?

Recursion is a programming technique where a function calls itself to solve a problem by breaking it down into smaller, similar subproblems. It's an alternative to iteration that's particularly elegant for problems with recursive structure (trees, nested data, mathematical sequences).

**Topics Covered:**

- Recursion concept and how it works
- Base case and recursive case
- Call stack and stack overflow
- Tail call optimization
- Recursion vs iteration trade-offs
- Common recursive patterns
- Memoization for recursion

---

## 1. Recursion Concept

### Basic Concept

**What it means:**
A recursive function is one that calls itself within its own definition. Each recursive call works on a smaller piece of the problem until reaching a base case that doesn't require further recursion.

**How it works:**

1. Function is called with initial input
2. If base case is met, return result directly
3. Otherwise, call function with smaller/simpler input
4. Each call waits for its nested call to return
5. Results bubble back up through call stack

**Structure:**

```javascript
function recursiveFunction(input) {
  // BASE CASE - Stop recursion
  if (baseCondition) {
    return baseValue;
  }

  // RECURSIVE CASE - Call itself with smaller input
  return recursiveFunction(smallerInput);
}
```

**Visual Example - Counting Down:**

```javascript
function countdown(n) {
  // Base case
  if (n <= 0) {
    console.log("Done!");
    return;
  }

  // Current work
  console.log(n);

  // Recursive case
  countdown(n - 1);
}

countdown(3);
// Prints: 3, 2, 1, Done!
```

**Call Stack Visualization:**

```
countdown(3)
  â”œâ”€ prints 3
  â””â”€ calls countdown(2)
      â”œâ”€ prints 2
      â””â”€ calls countdown(1)
          â”œâ”€ prints 1
          â””â”€ calls countdown(0)
              â””â”€ prints "Done!" (base case)
```

**Key Understanding Points:**

- Every recursive function MUST have a base case (termination condition)
- Each recursive call should move toward the base case
- Function calls are stored on the call stack
- Results can be computed on the way down or way up the stack
- Without proper base case, leads to infinite recursion (stack overflow)

**Why This Matters:**

- Some problems are naturally recursive (trees, graphs, nested structures)
- Can make code more readable and elegant
- Mirrors mathematical definitions (factorial, fibonacci)
- Essential for working with recursive data structures
- Common in coding interviews

**Interview Question & Perfect Answer:**

**Q: What is recursion and when should you use it?**

**Perfect Answer:**

> "Recursion is when a function calls itself to solve a problem by breaking it down into smaller instances of the same problem. It consists of two essential parts:
>
> 1. **Base case:** The condition where recursion stops (no more recursive calls)
> 2. **Recursive case:** Where the function calls itself with a simpler/smaller input
>
> **Simple example:**
>
> ```javascript
> function factorial(n) {
>   // Base case
>   if (n <= 1) return 1;
>
>   // Recursive case
>   return n * factorial(n - 1);
> }
>
> factorial(5); // 5 * 4 * 3 * 2 * 1 = 120
> ```
>
> **How it works:**
>
> ```
> factorial(5)
>   â””â”€ 5 * factorial(4)
>         â””â”€ 4 * factorial(3)
>               â””â”€ 3 * factorial(2)
>                     â””â”€ 2 * factorial(1)
>                           â””â”€ returns 1 (base case)
> ```
>
> **When to use recursion:**
>
> **Good use cases:**
>
> - Tree/graph traversal (DOM manipulation, file systems)
> - Nested data structures (deep cloning, deep comparison)
> - Divide and conquer algorithms (merge sort, quick sort)
> - Backtracking problems (permutations, maze solving)
> - Mathematical sequences (fibonacci, factorial)
> - Problems with recursive structure (fractals, Tower of Hanoi)
>
> **When NOT to use recursion:**
>
> - Simple iterations (loops are clearer and more efficient)
> - Deep recursion that risks stack overflow
> - When iteration is more readable
> - Performance-critical code without tail call optimization
>
> **Trade-offs:**
>
> - **Pros:** Elegant, readable for recursive problems, mirrors mathematical definitions
> - **Cons:** Uses more memory (call stack), slower than iteration, risk of stack overflow
>
> In practice, I use recursion when the problem naturally breaks down into smaller similar problems, like traversing a tree structure or working with nested objects. For simple counting or iteration, loops are usually better."

**Q: What happens if you forget the base case?**

**Perfect Answer:**

> "Without a base case, you get infinite recursion leading to a stack overflow error. Here's what happens:
>
> ```javascript
> function broken(n) {
>   console.log(n);
>   return broken(n - 1); // No base case!
> }
>
> broken(5);
> // Prints: 5, 4, 3, 2, 1, 0, -1, -2, -3...
> // Eventually: RangeError: Maximum call stack size exceeded
> ```
>
> **What happens internally:**
>
> 1. Each function call is added to the call stack
> 2. Stack has limited size (browser: ~10,000-50,000 calls)
> 3. Without base case, calls keep stacking up
> 4. Eventually stack memory is exhausted
> 5. JavaScript throws 'Maximum call stack size exceeded' error
>
> **The call stack:**
>
> ```
> broken(5)
>   â””â”€ broken(4)
>       â””â”€ broken(3)
>           â””â”€ broken(2)
>               â””â”€ broken(1)
>                   â””â”€ broken(0)
>                       â””â”€ broken(-1)
>                           â””â”€ broken(-2)
>                               â””â”€ ... (infinite)
> ```
>
> **Correct version with base case:**
>
> ```javascript
> function correct(n) {
>   if (n <= 0) return; // Base case!
>   console.log(n);
>   return correct(n - 1);
> }
> ```
>
> The base case is the 'emergency exit' that prevents infinite recursion. Every recursive function must have at least one base case, and every recursive call must move toward it."

---

## 2. Base Case and Recursive Case

### Base Case

**What it means:**
The condition where recursion stops. It returns a value directly without making another recursive call. This is the termination condition that prevents infinite recursion.

**Characteristics:**

- Must be reachable from any input
- Should be the simplest version of the problem
- Returns a known value without recursion
- Can have multiple base cases

**Common Patterns:**

```javascript
// Empty collection
if (array.length === 0) return defaultValue;

// Reached zero/one
if (n <= 0) return 0;
if (n === 1) return 1;

// Reached leaf node
if (node === null) return;
if (!node.children) return node.value;

// Found target
if (current === target) return current;
```

### Recursive Case

**What it means:**
The part where the function calls itself with a modified (usually smaller or simpler) input. This breaks the problem into smaller subproblems.

**Characteristics:**

- Must move toward base case
- Typically works on a subset of data
- Can make multiple recursive calls (tree recursion)
- May accumulate results

**Common Patterns:**

```javascript
// Reduce size
return func(n - 1);
return func(array.slice(1));

// Divide and conquer
return func(leftHalf) + func(rightHalf);

// Tree traversal
return func(node.left) + func(node.right);

// Accumulate
return current + func(rest);
```

**Interview Question & Perfect Answer:**

**Q: What's the difference between base case and recursive case? Why do you need both?**

**Perfect Answer:**

> "The base case and recursive case are the two essential components of every recursive function:
>
> **Base Case:**
>
> - The termination condition where recursion stops
> - Returns a result directly without further recursive calls
> - Represents the simplest instance of the problem
> - Without it, you get infinite recursion and stack overflow
>
> **Recursive Case:**
>
> - Where the function calls itself with a simpler/smaller input
> - Breaks the problem into smaller subproblems
> - Must progress toward the base case
> - Without it, you just have a regular function
>
> **Example showing both:**
>
> ```javascript
> function sum(arr) {
>   // BASE CASE: Empty array
>   if (arr.length === 0) {
>     return 0; // Simple answer, no recursion
>   }
>
>   // RECURSIVE CASE: Add first element + sum of rest
>   return arr[0] + sum(arr.slice(1));
>   // â†‘ current work   â†‘ recursive call (smaller problem)
> }
>
> sum([1, 2, 3]);
> // = 1 + sum([2, 3])
> //     = 2 + sum([3])
> //         = 3 + sum([])
> //             = 0 (base case)
> //         = 3 + 0 = 3
> //     = 2 + 3 = 5
> // = 1 + 5 = 6
> ```
>
> **Why you need both:**
>
> 1. **Base case prevents infinite recursion:** Without it, the function would call itself forever until crashing
> 2. **Recursive case enables problem-solving:** Without it, you can't break the problem down
> 3. **Together they form complete solution:** Base case handles simplest case, recursive case reduces complex cases to simple ones
>
> **Multiple base cases example:**
>
> ```javascript
> function fibonacci(n) {
>   // Two base cases
>   if (n === 0) return 0;
>   if (n === 1) return 1;
>
>   // Recursive case
>   return fibonacci(n - 1) + fibonacci(n - 2);
> }
> ```
>
> The base case is where the 'magic' of recursion meets realityâ€”it's the actual answer, while the recursive case is the mechanism for reaching that answer."

---

## 3. Call Stack and Stack Overflow

### The Call Stack

**What it means:**
The call stack is a data structure that keeps track of function calls. Each time a function is called, a new frame is pushed onto the stack. When the function returns, its frame is popped off.

**How it works with recursion:**

1. Each recursive call adds a new frame to the stack
2. Each frame stores local variables and return address
3. Stack grows with each nested call
4. When base case is hit, stack unwinds
5. Each function returns and its frame is removed

**Stack Frame Contents:**

- Function parameters
- Local variables
- Return address (where to continue after return)
- Context information

**Visual Representation:**

```javascript
function factorial(n) {
  if (n <= 1) return 1;
  return n * factorial(n - 1);
}

factorial(4);

// Call Stack Growth:
//
// Step 1: factorial(4) called
// [factorial(4): n=4]
//
// Step 2: calls factorial(3)
// [factorial(3): n=3]
// [factorial(4): n=4]
//
// Step 3: calls factorial(2)
// [factorial(2): n=2]
// [factorial(3): n=3]
// [factorial(4): n=4]
//
// Step 4: calls factorial(1)
// [factorial(1): n=1] â† BASE CASE
// [factorial(2): n=2]
// [factorial(3): n=3]
// [factorial(4): n=4]
//
// Step 5: factorial(1) returns 1
// [factorial(2): n=2] â† now can compute 2 * 1 = 2
// [factorial(3): n=3]
// [factorial(4): n=4]
//
// Step 6: factorial(2) returns 2
// [factorial(3): n=3] â† now can compute 3 * 2 = 6
// [factorial(4): n=4]
//
// Step 7: factorial(3) returns 6
// [factorial(4): n=4] â† now can compute 4 * 6 = 24
//
// Step 8: factorial(4) returns 24
// [] â† stack empty
```

### Stack Overflow

**What it means:**
A stack overflow occurs when the call stack exceeds its maximum size limit, typically from too many recursive calls without reaching a base case.

**Causes:**

1. Missing or unreachable base case
2. Recursion depth exceeds stack limit
3. Incorrect recursive logic that doesn't progress toward base case

**Stack Limits:**

- Chrome/V8: ~10,000-15,000 calls
- Firefox: ~50,000 calls
- Node.js: ~10,000-15,000 calls
- Varies by available memory and engine

**Interview Question & Perfect Answer:**

**Q: Explain how the call stack works with recursion. What causes stack overflow?**

**Perfect Answer:**

> "The call stack is a LIFO (Last In, First Out) data structure that tracks function execution. With recursion, understanding the call stack is crucial because each recursive call adds a new frame to the stack.
>
> **How it works:**
>
> ```javascript
> function countdown(n) {
>   if (n === 0) {
>     console.log("Base case!");
>     return;
>   }
>   console.log("Before:", n);
>   countdown(n - 1);
>   console.log("After:", n);
> }
>
> countdown(3);
> ```
>
> **Stack visualization:**
>
> ```
> Call:                     Stack State:
> countdown(3)             [countdown(3)]
>   prints "Before: 3"
>   calls countdown(2)     [countdown(2)]
>                          [countdown(3)]
>     prints "Before: 2"
>     calls countdown(1)   [countdown(1)]
>                          [countdown(2)]
>                          [countdown(3)]
>       prints "Before: 1"
>       calls countdown(0) [countdown(0)] â† Base case hit
>                          [countdown(1)]
>                          [countdown(2)]
>                          [countdown(3)]
>         prints "Base!"
>         returns          [countdown(1)] â† Stack unwinds
>                          [countdown(2)]
>                          [countdown(3)]
>       prints "After: 1"
>       returns            [countdown(2)]
>                          [countdown(3)]
>     prints "After: 2"
>     returns              [countdown(3)]
>   prints "After: 3"
>   returns                [] â† Empty
> ```
>
> **Stack Overflow:**
> This occurs when the call stack exceeds its maximum size. Common causes:
>
> 1. **Missing base case:**
>
> ```javascript
> function infinite(n) {
>   return infinite(n - 1); // No stop condition!
> }
> infinite(10); // Stack overflow
> ```
>
> 2. **Unreachable base case:**
>
> ```javascript
> function broken(n) {
>   if (n === 0) return;
>   return broken(n + 1); // Never reaches 0!
> }
> broken(5); // Stack overflow
> ```
>
> 3. **Too deep recursion:**
>
> ```javascript
> function fibonacci(n) {
>   if (n <= 1) return n;
>   return fibonacci(n - 1) + fibonacci(n - 2);
> }
> fibonacci(50); // Takes forever, may overflow
> ```
>
> **Stack limits vary by environment:**
>
> - Chrome: ~10,000-15,000 calls
> - Firefox: ~50,000 calls
> - Node.js: ~10,000-15,000 calls
>
> **Prevention strategies:**
>
> 1. **Ensure base case is reachable**
> 2. **Convert to iteration** for deep recursion
> 3. **Use tail recursion** (if supported)
> 4. **Implement memoization** to reduce calls
> 5. **Increase stack size** (Node.js: `--stack-size` flag)
> 6. **Use trampolining** technique
>
> **Checking recursion depth:**
>
> ```javascript
> function safeRecursion(n, depth = 0) {
>   const MAX_DEPTH = 10000;
>   if (depth > MAX_DEPTH) {
>     throw new Error("Recursion too deep");
>   }
>   if (n <= 0) return 0;
>   return n + safeRecursion(n - 1, depth + 1);
> }
> ```
>
> Understanding the call stack is essential for debugging recursive functions and knowing when to choose iteration over recursion."

---

## 4. Tail Call Optimization (TCO)

### Basic Concept

**What it means:**
Tail call optimization is a compiler/interpreter optimization where a function call in tail position (the last operation) can reuse the current stack frame instead of creating a new one. This prevents stack overflow in recursive functions.

**Tail Position:**
A function call is in tail position when it's the absolute last thing the function doesâ€”no operations on the returned value.

**Tail Call vs Non-Tail Call:**

```javascript
// NON-TAIL CALL (not optimizable)
function factorial(n) {
  if (n <= 1) return 1;
  return n * factorial(n - 1); // âŒ Must wait for return to multiply
}

// TAIL CALL (optimizable)
function factorialTail(n, accumulator = 1) {
  if (n <= 1) return accumulator;
  return factorialTail(n - 1, n * accumulator); // âœ… Direct return, no operations
}
```

**How TCO Works:**

```javascript
// Without TCO:
// Stack grows with each call
factorialTail(5, 1)
  factorialTail(4, 5)
    factorialTail(3, 20)
      factorialTail(2, 60)
        factorialTail(1, 120)
          returns 120

// With TCO:
// Stack frame reused
factorialTail(5, 1)  // Frame 1: n=5, acc=1
factorialTail(4, 5)  // Frame 1: n=4, acc=5 (reused!)
factorialTail(3, 20) // Frame 1: n=3, acc=20 (reused!)
factorialTail(2, 60) // Frame 1: n=2, acc=60 (reused!)
factorialTail(1, 120)// Frame 1: n=1, acc=120 (reused!)
returns 120          // Only one frame used!
```

**Key Understanding Points:**

- Only works in strict mode (`'use strict'`)
- Call must be in tail position (last operation)
- No operations on returned value
- Currently only Safari/JSC fully supports it
- Chrome/V8 and Firefox removed support
- Node.js doesn't support it (V8 engine)

**Current State (2024+):**

- **Safari/WebKit:** Full support
- **Chrome/V8:** Removed in 2016
- **Firefox:** Never implemented
- **Node.js:** No support

**Interview Question & Perfect Answer:**

**Q: What is tail call optimization? Does JavaScript support it?**

**Perfect Answer:**

> "Tail call optimization (TCO) is a compiler optimization where function calls in tail position can reuse the current stack frame instead of creating a new one, preventing stack overflow in deep recursion.
>
> **What makes a call 'tail':**
> A function call is in tail position when it's the very last operationâ€”the return value is used directly with no further operations.
>
> **Examples:**
>
> ```javascript
> // âŒ NOT tail call (operation after recursive call)
> function sum(n) {
>   if (n === 0) return 0;
>   return n + sum(n - 1); // Addition happens AFTER return
> }
>
> // âœ… IS tail call (direct return, no operations)
> function sumTail(n, acc = 0) {
>   if (n === 0) return acc;
>   return sumTail(n - 1, n + acc); // Direct return
> }
> ```
>
> **Key difference:**
>
> ```javascript
> // Non-tail recursive: Stack grows
> sum(4)
>   â†’ return 4 + sum(3)    [Frame 1]
>       â†’ return 3 + sum(2)    [Frame 2]
>           â†’ return 2 + sum(1)    [Frame 3]
>               â†’ return 1 + sum(0)    [Frame 4]
>                   â†’ return 0         [Frame 5]
>               â†’ return 1 + 0 = 1
>           â†’ return 2 + 1 = 3
>       â†’ return 3 + 3 = 6
>   â†’ return 4 + 6 = 10
> // 5 frames needed (must remember each n value)
>
> // Tail recursive: Stack stays constant (with TCO)
> sumTail(4, 0)  [Frame 1: n=4, acc=0]
> sumTail(3, 4)  [Frame 1: n=3, acc=4] â† Same frame reused!
> sumTail(2, 7)  [Frame 1: n=2, acc=7]
> sumTail(1, 9)  [Frame 1: n=1, acc=9]
> sumTail(0, 10) [Frame 1: n=0, acc=10]
> return 10      [Frame 1]
> // Only 1 frame needed (no values to remember)
> ```
>
> **JavaScript Support (The Bad News):**
> Unfortunately, TCO support in JavaScript is extremely limited:
>
> - **Safari/WebKit:** âœ… Full support (only major engine)
> - **Chrome/V8:** âŒ Removed in 2016 (deemed too complex)
> - **Firefox:** âŒ Never implemented
> - **Node.js:** âŒ No support (uses V8)
>
> **Practical Implications:**
> Since TCO isn't reliably available in JavaScript, you should:
>
> 1. **Don't rely on it** - assume it won't work
> 2. **Convert to loops** for deep recursion:
>
> ```javascript
> function sumIterative(n) {
>   let result = 0;
>   for (let i = n; i > 0; i--) {
>     result += i;
>   }
>   return result;
> }
> ```
>
> 3. **Use memoization** to reduce call depth
> 4. **Implement trampolining** for complex cases:
>
> ```javascript
> function trampoline(fn) {
>   let result = fn();
>   while (typeof result === "function") {
>     result = result();
>   }
>   return result;
> }
> ```
>
> 5. **Set reasonable depth limits** and throw errors
>
> **Converting to tail-recursive form:**
> The pattern is to use an accumulator parameter:
>
> ```javascript
> // Original (not tail-recursive)
> function factorial(n) {
>   if (n <= 1) return 1;
>   return n * factorial(n - 1);
> }
>
> // Tail-recursive version (with accumulator)
> function factorialTail(n, acc = 1) {
>   if (n <= 1) return acc;
>   return factorialTail(n - 1, n * acc);
> }
> ```
>
> While TCO is a beautiful concept and works in some environments, in practice for JavaScript, you should prefer iteration for deep recursion or use techniques like memoization and trampolining."

---

## 5. Recursion vs Iteration

### Comparison

**When to Use Each:**

| Aspect          | Recursion                                | Iteration                          |
| --------------- | ---------------------------------------- | ---------------------------------- |
| **Best For**    | Tree/graph traversal, divide-and-conquer | Simple counting, linear operations |
| **Readability** | Elegant for recursive problems           | Clear for sequential operations    |
| **Performance** | Slower (function call overhead)          | Faster (direct execution)          |
| **Memory**      | Uses call stack (limited)                | Uses variables (minimal)           |
| **Risk**        | Stack overflow                           | Infinite loops                     |
| **Debugging**   | Harder (trace through stack)             | Easier (step through loop)         |

**Interview Question & Perfect Answer:**

**Q: When should you use recursion vs iteration? What are the trade-offs?**

**Perfect Answer:**

> "The choice between recursion and iteration depends on the problem structure, readability requirements, and performance constraints.
>
> **Use Recursion When:**
>
> 1. **Problem has recursive structure:**
>
> ```javascript
> // Tree traversal - naturally recursive
> function findInTree(node, target) {
>   if (!node) return null;
>   if (node.value === target) return node;
>   return findInTree(node.left, target) || findInTree(node.right, target);
> }
>
> // Iterative version is much more complex (needs explicit stack)
> ```
>
> 2. **Working with nested data:**
>
> ```javascript
> // Deep clone - recursion is clearer
> function deepClone(obj) {
>   if (obj === null || typeof obj !== "object") return obj;
>   if (Array.isArray(obj)) return obj.map(deepClone);
>   return Object.fromEntries(
>     Object.entries(obj).map(([k, v]) => [k, deepClone(v)])
>   );
> }
> ```
>
> 3. **Divide and conquer algorithms:**
>
> ```javascript
> // Merge sort - recursive is natural
> function mergeSort(arr) {
>   if (arr.length <= 1) return arr;
>   const mid = Math.floor(arr.length / 2);
>   return merge(mergeSort(arr.slice(0, mid)), mergeSort(arr.slice(mid)));
> }
> ```
>
> 4. **Backtracking problems** (permutations, combinations, maze solving)
>
> **Use Iteration When:**
>
> 1. **Simple sequential operations:**
>
> ```javascript
> // Sum array - iteration is clearer
> function sum(arr) {
>   let total = 0;
>   for (let num of arr) {
>     total += num;
>   }
>   return total;
> }
>
> // Recursive is overkill
> function sumRecursive(arr) {
>   if (arr.length === 0) return 0;
>   return arr[0] + sumRecursive(arr.slice(1));
> }
> ```
>
> 2. **Deep recursion (risk of stack overflow):**
>
> ```javascript
> // Computing fibonacci(50) recursively would crash
> // Iterative is safe
> function fibonacci(n) {
>   if (n <= 1) return n;
>   let prev = 0,
>     curr = 1;
>   for (let i = 2; i <= n; i++) {
>     [prev, curr] = [curr, prev + curr];
>   }
>   return curr;
> }
> ```
>
> 3. **Performance-critical code:**
>
> ```javascript
> // Processing large arrays - iteration is faster
> function processLarge Array(arr) {
>   const result = [];
>   for (let item of arr) {
>     result.push(transform(item));
>   }
>   return result;
> }
> ```
>
> 4. **When clarity favors loops:**
>
> ```javascript
> // Simple countdown - loop is clearer
> for (let i = 10; i > 0; i--) {
>   console.log(i);
> }
> ```
>
> **Trade-offs:**
>
> **Recursion:**
>
> - âœ… Elegant for recursive problems
> - âœ… Mirrors mathematical definitions
> - âœ… Less code for complex problems
> - âŒ Function call overhead (slower)
> - âŒ Uses stack memory (limited)
> - âŒ Risk of stack overflow
> - âŒ Harder to debug
>
> **Iteration:**
>
> - âœ… Faster execution (no call overhead)
> - âœ… Uses less memory
> - âœ… No stack overflow risk
> - âœ… Easier to debug (step through)
> - âŒ More verbose for recursive problems
> - âŒ May need explicit stack/queue
> - âŒ Less elegant for trees/graphs
>
> **My Approach:**
>
> 1. If problem is naturally recursive (trees, nested structures) â†’ start with recursion
> 2. If recursion depth could be large â†’ consider iteration or memoization
> 3. If performance is critical â†’ profile first, optimize if needed
> 4. If clarity is priority â†’ choose what makes code most readable
>
> **Example - Both approaches:**
>
> ```javascript
> // Directory traversal
> // Recursive (clearer)
> function listFiles(dir) {
>   const files = [];
>   for (let item of dir.contents) {
>     if (item.isFile) files.push(item.path);
>     else files.push(...listFiles(item));
>   }
>   return files;
> }
>
> // Iterative (safer for very deep directories)
> function listFilesIterative(rootDir) {
>   const files = [];
>   const stack = [rootDir];
>
>   while (stack.length > 0) {
>     const dir = stack.pop();
>     for (let item of dir.contents) {
>       if (item.isFile) files.push(item.path);
>       else stack.push(item);
>     }
>   }
>   return files;
> }
> ```
>
> In modern JavaScript, I default to recursion for tree-like structures because it's more maintainable, but keep iteration in mind for performance-critical or deep-recursion scenarios."

---

## 6. Common Recursive Patterns

### Pattern 1: Linear Recursion

**What it is:**
Makes one recursive call per invocation, processing elements sequentially.

**Pattern:**

```javascript
function process(data) {
  if (baseCase) return baseValue;
  return currentWork + process(remainingData);
}
```

**Examples:**

```javascript
// Sum array
function sum(arr) {
  if (arr.length === 0) return 0;
  return arr[0] + sum(arr.slice(1));
}

// Count elements
function count(arr) {
  if (arr.length === 0) return 0;
  return 1 + count(arr.slice(1));
}

// Find maximum
function findMax(arr) {
  if (arr.length === 1) return arr[0];
  const maxOfRest = findMax(arr.slice(1));
  return arr[0] > maxOfRest ? arr[0] : maxOfRest;
}
```

---

### Pattern 2: Binary Recursion / Tree Recursion

**What it is:**
Makes two (or more) recursive calls per invocation, typically on divided data.

**Pattern:**

```javascript
function process(data) {
  if (baseCase) return baseValue;
  return combine(process(leftHalf), process(rightHalf));
}
```

**Examples:**

```javascript
// Fibonacci
function fibonacci(n) {
  if (n <= 1) return n;
  return fibonacci(n - 1) + fibonacci(n - 2); // Two calls!
}

// Tree traversal
function sumTree(node) {
  if (!node) return 0;
  return node.value + sumTree(node.left) + sumTree(node.right);
}

// Merge sort
function mergeSort(arr) {
  if (arr.length <= 1) return arr;
  const mid = Math.floor(arr.length / 2);
  return merge(mergeSort(arr.slice(0, mid)), mergeSort(arr.slice(mid)));
}
```

---

### Pattern 3: Tail Recursion

**What it is:**
Recursive call is the last operation (no work after return).

**Pattern:**

```javascript
function process(data, accumulator) {
  if (baseCase) return accumulator;
  return process(newData, updatedAccumulator); // Direct return
}
```

**Examples:**

```javascript
// Factorial
function factorial(n, acc = 1) {
  if (n <= 1) return acc;
  return factorial(n - 1, n * acc);
}

// Sum with accumulator
function sumTail(arr, acc = 0) {
  if (arr.length === 0) return acc;
  return sumTail(arr.slice(1), acc + arr[0]);
}

// Reverse string
function reverse(str, acc = "") {
  if (str === "") return acc;
  return reverse(str.slice(1), str[0] + acc);
}
```

---

### Pattern 4: Mutual Recursion

**What it is:**
Two or more functions call each other recursively.

**Pattern:**

```javascript
function functionA(data) {
  if (baseCase) return value;
  return functionB(transformedData);
}

function functionB(data) {
  if (baseCase) return value;
  return functionA(transformedData);
}
```

**Example:**

```javascript
// Check if number is even/odd
function isEven(n) {
  if (n === 0) return true;
  return isOdd(n - 1);
}

function isOdd(n) {
  if (n === 0) return false;
  return isEven(n - 1);
}
```

---

### Pattern 5: Backtracking

**What it is:**
Try possibilities recursively, backtrack if they don't work.

**Pattern:**

```javascript
function solve(current, options) {
  if (isSolution(current)) return current;

  for (let option of options) {
    if (isValid(option)) {
      const result = solve(applyOption(current, option), nextOptions);
      if (result) return result; // Found solution
      // Implicit backtrack: try next option
    }
  }

  return null; // No solution found
}
```

**Examples:**

```javascript
// Generate permutations
function permute(arr) {
  if (arr.length <= 1) return [arr];

  const result = [];
  for (let i = 0; i < arr.length; i++) {
    const current = arr[i];
    const remaining = arr.slice(0, i).concat(arr.slice(i + 1));
    const perms = permute(remaining);

    for (let perm of perms) {
      result.push([current, ...perm]);
    }
  }
  return result;
}

// Maze solving
function solveMaze(maze, x, y) {
  // Base cases
  if (isOutOfBounds(x, y)) return false;
  if (maze[y][x] === "wall") return false;
  if (maze[y][x] === "exit") return true;
  if (maze[y][x] === "visited") return false;

  // Mark as visited
  maze[y][x] = "visited";

  // Try all directions
  if (solveMaze(maze, x + 1, y)) return true; // Right
  if (solveMaze(maze, x - 1, y)) return true; // Left
  if (solveMaze(maze, x, y + 1)) return true; // Down
  if (solveMaze(maze, x, y - 1)) return true; // Up

  // Backtrack
  maze[y][x] = "open";
  return false;
}
```

---

## 7. Memoization for Recursion

### Basic Concept

**What it means:**
Memoization caches function results to avoid redundant calculations in recursive functions. Particularly useful for functions with overlapping subproblems.

**Why It's Needed:**

```javascript
// Without memoization - exponential time
function fib(n) {
  if (n <= 1) return n;
  return fib(n - 1) + fib(n - 2);
}

// fib(5) call tree:
//                fib(5)
//              /        \
//         fib(4)         fib(3)
//        /     \         /     \
//    fib(3)  fib(2)  fib(2)  fib(1)
//    /   \   /   \   /   \
// fib(2)fib(1)...     ...
//
// fib(3) calculated multiple times!
// Time complexity: O(2^n) - very slow
```

**With Memoization:**

```javascript
function fibMemo(n, memo = {}) {
  if (n in memo) return memo[n]; // Check cache
  if (n <= 1) return n;

  memo[n] = fibMemo(n - 1, memo) + fibMemo(n - 2, memo);
  return memo[n];
}

// Each value calculated only once
// Time complexity: O(n) - much faster!
```

**Interview Question & Perfect Answer:**

**Q: What is memoization? When and how do you use it with recursion?**

**Perfect Answer:**

> "Memoization is an optimization technique where you cache the results of expensive function calls and return the cached result when the same inputs occur again. It's especially powerful with recursive functions that have overlapping subproblems.
>
> **Classic Example - Fibonacci:**
>
> ```javascript
> // Without memoization - O(2^n) time
> function fib(n) {
>   if (n <= 1) return n;
>   return fib(n - 1) + fib(n - 2);
> }
>
> fib(40); // Takes several seconds!
>
> // With memoization - O(n) time
> function fibMemo(n, memo = {}) {
>   if (n in memo) return memo[n];
>   if (n <= 1) return n;
>
>   memo[n] = fibMemo(n - 1, memo) + fibMemo(n - 2, memo);
>   return memo[n];
> }
>
> fibMemo(40); // Instant!
> ```
>
> **Why it helps:**
> Without memoization, `fib(5)` makes these calls:
>
> ```
> fib(5)
>   fib(4) + fib(3)
>     fib(3) + fib(2) + fib(2) + fib(1)
>       fib(2) + fib(1) + fib(1) + fib(0) + ...
> ```
>
> Notice `fib(3)`, `fib(2)`, etc. are calculated multiple times. With memoization, each value is calculated once and reused.
>
> **Generic memoization wrapper:**
>
> ```javascript
> function memoize(fn) {
>   const cache = {};
>   return function (...args) {
>     const key = JSON.stringify(args);
>     if (key in cache) {
>       console.log("Cache hit:", key);
>       return cache[key];
>     }
>     console.log("Computing:", key);
>     const result = fn.apply(this, args);
>     cache[key] = result;
>     return result;
>   };
> }
>
> const fibMemoized = memoize(function fib(n) {
>   if (n <= 1) return n;
>   return fibMemoized(n - 1) + fibMemoized(n - 2);
> });
> ```
>
> **When to use memoization:**
>
> 1. **Overlapping subproblems:** Same inputs computed multiple times
> 2. **Pure functions:** Same input always produces same output
> 3. **Expensive computations:** Worth the memory cost
> 4. **Recursive functions:** Especially tree recursion
>
> **When NOT to use:**
>
> 1. **No overlapping subproblems:** Linear recursion often doesn't benefit
> 2. **Impure functions:** Results vary between calls
> 3. **Memory constraints:** Cache can grow large
> 4. **Different inputs each time:** Cache won't help
>
> **Examples that benefit:**
>
> ```javascript
> // Grid paths - many overlapping subproblems
> function gridPaths(m, n, memo = {}) {
>   const key = `${m},${n}`;
>   if (key in memo) return memo[key];
>   if (m === 1 || n === 1) return 1;
>
>   memo[key] = gridPaths(m - 1, n, memo) + gridPaths(m, n - 1, memo);
>   return memo[key];
> }
>
> // Coin change - overlapping subproblems
> function coinChange(amount, coins, memo = {}) {
>   if (amount in memo) return memo[amount];
>   if (amount === 0) return 0;
>   if (amount < 0) return Infinity;
>
>   let min = Infinity;
>   for (let coin of coins) {
>     min = Math.min(min, 1 + coinChange(amount - coin, coins, memo));
>   }
>
>   memo[amount] = min;
>   return min;
> }
> ```
>
> **Trade-offs:**
>
> - **Pro:** Dramatically improves performance (exponential â†’ polynomial)
> - **Pro:** Easy to implement (just add cache parameter)
> - **Con:** Uses extra memory for cache
> - **Con:** Only helps with repeated inputs
>
> In interviews, recognizing when to apply memoization shows strong problem-solving skills. If you see repeated recursive calls with the same parameters, memoization is likely the solution."

---

## ðŸŽ¯ Summary

### Quick Decision Tree

```
Need to solve a problem?
â”œâ”€ Is it naturally recursive? (trees, nested data, divide-and-conquer)
â”‚  â”œâ”€ Yes â†’ Use recursion
â”‚  â”‚  â”œâ”€ Has overlapping subproblems? â†’ Add memoization
â”‚  â”‚  â”œâ”€ Very deep recursion? â†’ Consider iteration or increase stack limit
â”‚  â”‚  â””â”€ Can make tail-recursive? â†’ Refactor with accumulator (limited benefit)
â”‚  â””â”€ No â†’ Use iteration
â””â”€ Simple sequential operation? â†’ Use iteration
```

### Key Takeaways

1. **Every recursive function needs:**

   - Base case (termination condition)
   - Recursive case (calls itself with simpler input)
   - Progress toward base case

2. **Call stack implications:**

   - Each call uses memory
   - Stack has limits (~10,000-50,000 calls)
   - Deep recursion risks overflow

3. **When to use:**

   - Tree/graph traversal
   - Nested structures
   - Divide and conquer
   - Backtracking
   - Matches problem structure

4. **When to avoid:**

   - Simple iteration
   - Very deep recursion
   - Performance-critical paths
   - No recursive structure

5. **Optimization techniques:**
   - Memoization for overlapping subproblems
   - Tail recursion (limited support)
   - Convert to iteration if needed
   - Set depth limits

---

**Remember:** Recursion is a powerful tool when used appropriately. Choose it when it makes the code clearer and matches the problem structure, but be mindful of stack limits and performance implications. When in doubt, profile both approaches!
