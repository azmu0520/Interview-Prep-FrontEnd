# Scope & Closures - Theoretical Deep Dive

### JavaScript Interview Preparation for Senior Frontend Engineer

---

## üéØ Key Concepts

### What is Scope & Closures?

Scope determines where variables are accessible in your code. A closure is a function that has access to variables from an outer (enclosing) function's scope, even after that outer function has finished executing. This is one of JavaScript's most powerful and frequently misunderstood features.

**Topics Covered:**

- Lexical scope
- Scope chain
- Closures concept and use cases
- Module pattern with closures
- Private variables with closures
- Memory implications of closures
- IIFE (Immediately Invoked Function Expression)

---

## 1. Lexical Scope

### Basic Concept

**What it means:**
Lexical scope (also called static scope) means that the accessibility of variables is determined by the physical location of the variable declaration in the source code. Inner functions can access variables from outer functions, but not vice versa.

**How it works:**
JavaScript uses lexical scoping, which means that scope is determined at **write-time** (when you write the code), not at **run-time** (when the code executes). When you define a function, it "remembers" where it was defined and what variables were in scope at that location.

**Structure:**

```javascript
// Global scope
let globalVar = "I'm global";

function outer() {
  // Outer function scope
  let outerVar = "I'm outer";

  function inner() {
    // Inner function scope
    let innerVar = "I'm inner";

    // Can access all three variables
    console.log(globalVar); // ‚úÖ Accessible
    console.log(outerVar); // ‚úÖ Accessible
    console.log(innerVar); // ‚úÖ Accessible
  }

  // Can only access global and outer
  console.log(globalVar); // ‚úÖ Accessible
  console.log(outerVar); // ‚úÖ Accessible
  console.log(innerVar); // ‚ùå ReferenceError
}
```

**Key Understanding Points:**

- Scope is determined by where functions and variables are **written**, not where they're **called**
- Inner scopes can access outer scopes (but not the reverse)
- Each function creates its own scope
- Variables are looked up through the scope chain
- Child scopes "shadow" parent scope variables with the same name

**Why This Matters:**
Understanding lexical scope is crucial because:

1. It's the foundation of closures
2. It determines variable accessibility
3. It affects how `this` binding works in some cases
4. It's fundamental to module patterns
5. It helps prevent variable naming conflicts

**Interview Question & Perfect Answer:**

**Q: What is lexical scope and how does it differ from dynamic scope?**

**Perfect Answer:**

> "Lexical scope means that variable scope is determined by where functions and variables are defined in the source code, not where they're executed. JavaScript uses lexical (static) scope exclusively.
>
> In lexical scoping, when a function is defined, it captures the environment (scope) in which it was created. This scope is fixed and doesn't change based on where the function is called from.
>
> Example:
>
> ```javascript
> let x = "global";
>
> function outer() {
>   let x = "outer";
>
>   function inner() {
>     console.log(x); // 'outer' - looks up where defined
>   }
>
>   return inner;
> }
>
> let x = "new global";
> const fn = outer();
> fn(); // Still logs 'outer', not 'new global'
> ```
>
> If JavaScript used dynamic scope (which it doesn't), the function would look for variables in the scope where it's **called**, not where it's **defined**. In dynamic scoping, `fn()` would log 'new global' because that's the x in the calling scope.
>
> Lexical scope makes code more predictable and easier to reason about because you can determine variable access just by reading the code, without tracing execution flow."

**Q: What happens with variable shadowing in nested scopes?**

**Perfect Answer:**

> "Variable shadowing occurs when a variable declared in an inner scope has the same name as a variable in an outer scope. The inner variable 'shadows' or 'hides' the outer one within that inner scope.
>
> ```javascript
> let name = "global";
>
> function outer() {
>   let name = "outer";
>
>   function inner() {
>     let name = "inner";
>     console.log(name); // 'inner' - shadows both outer scopes
>   }
>
>   inner();
>   console.log(name); // 'outer' - shadows global
> }
>
> outer();
> console.log(name); // 'global'
> ```
>
> Each scope level can only access its own variable with that name. The inner variable completely shadows the outer one‚Äîthere's no way to access the outer variable from the inner scope when names collide.
>
> This is different from property shadowing in prototypes, where you can still access the shadowed property via the prototype chain. With lexical scope shadowing, the outer variable is completely inaccessible.
>
> Best practice is to use different variable names to avoid confusion, though shadowing is sometimes useful for isolating concerns in different scope levels."

---

## 2. Scope Chain

### Basic Concept

**What it means:**
The scope chain is the mechanism JavaScript uses to resolve variable names. When you reference a variable, JavaScript searches for it in the current scope first, then moves up through parent scopes until it finds the variable or reaches global scope.

**How it works:**
Every execution context has a reference to its outer environment (parent scope). When a variable is referenced:

1. JavaScript checks the current scope
2. If not found, checks the outer scope
3. Continues up the chain until found or reaches global scope
4. If never found, throws `ReferenceError`

**Visual Representation:**

```
Global Scope
‚îÇ
‚îú‚îÄ Variable: globalVar
‚îÇ
‚îî‚îÄ Function: outer()
   ‚îÇ
   ‚îú‚îÄ Variable: outerVar
   ‚îÇ
   ‚îî‚îÄ Function: inner()
      ‚îÇ
      ‚îú‚îÄ Variable: innerVar
      ‚îÇ
      ‚îî‚îÄ When inner() looks for a variable:
          1. Check inner scope
          2. Check outer scope
          3. Check global scope
          4. ReferenceError if not found
```

**Key Understanding Points:**

- Scope chain is created at function **definition** time (lexical)
- Each scope has a reference to its parent scope
- Variables are looked up from innermost to outermost
- Lookup stops as soon as variable is found
- Write access only works in current scope
- Chain determines closure behavior

**Performance Consideration:**
Looking up variables through multiple scope levels can be slightly slower than using local variables. In performance-critical code, cache frequently accessed outer-scope variables in local variables.

**Interview Question & Perfect Answer:**

**Q: How does the scope chain work? Walk through variable lookup.**

**Perfect Answer:**

> "The scope chain is the linked hierarchy of scopes that JavaScript traverses when resolving variable references. It's created at function definition time based on lexical (static) scope.
>
> Let me walk through an example:
>
> ```javascript
> let global = "I am global";
>
> function outer() {
>   let outerVar = "I am outer";
>
>   function inner() {
>     let innerVar = "I am inner";
>     console.log(innerVar); // Step 1: Found in current scope
>     console.log(outerVar); // Step 2: Not in current, check parent
>     console.log(global); // Step 3: Check parent's parent
>     console.log(missing); // Step 4: Not found anywhere - ReferenceError
>   }
>
>   inner();
> }
> ```
>
> For each variable reference:
>
> 1. **innerVar:** Found immediately in inner's scope
> 2. **outerVar:** Not in inner, move up chain to outer's scope, found there
> 3. **global:** Not in inner or outer, move up to global scope, found there
> 4. **missing:** Not found in any scope, throws ReferenceError
>
> Important points:
>
> - The chain is determined by where the function is **defined**, not called
> - Lookup stops as soon as the variable is found (shadowing prevents finding outer variables)
> - Reading goes up the chain, but writing only happens in the current scope
> - This chain is what enables closures‚Äîinner functions maintain references to their outer scopes even after those outer functions have returned
>
> The scope chain is stored in an internal [[Scope]] property of functions and is consulted every time a variable is accessed."

**Q: What's the difference between the scope chain and the prototype chain?**

**Perfect Answer:**

> "Both are chains used for lookups, but they serve completely different purposes:
>
> **Scope Chain:**
>
> - Resolves **variable names** (identifiers)
> - Based on where functions are **defined** (lexical scope)
> - Hierarchical: local ‚Üí outer function ‚Üí global
> - Used when you reference a variable: `console.log(myVar)`
> - Determined at **write time** (when code is written)
> - Can't be modified at runtime
> - Example: Looking up `x` in nested functions
>
> **Prototype Chain:**
>
> - Resolves **object properties**
> - Based on object relationships set via `__proto__` or `Object.create()`
> - Hierarchical: object ‚Üí prototype ‚Üí Object.prototype ‚Üí null
> - Used when you access a property: `obj.myProperty`
> - Determined at **runtime** (can be modified)
> - Can be changed with `Object.setPrototypeOf()` (not recommended)
> - Example: Looking up methods like `array.map()` (found in Array.prototype)
>
> Quick example showing both:
>
> ```javascript
> let x = "scope chain";
>
> function demo() {
>   console.log(x); // Uses scope chain to find 'x'
>
>   let obj = { name: "Alice" };
>   console.log(obj.toString()); // Uses prototype chain to find 'toString'
> }
> ```
>
> In the first console.log, JavaScript uses the scope chain to resolve the variable `x`. In the second, it uses the prototype chain to find `toString` method (inherited from Object.prototype).
>
> They're both lookup mechanisms but for different purposes‚Äîscope chain for variables, prototype chain for object properties."

---

## 3. Closures

### Basic Concept

**What it means:**
A closure is a function that has access to variables from an outer (enclosing) function's scope, even after that outer function has finished executing. It's the combination of a function and the lexical environment in which that function was declared.

**How it works:**
When a function is created, it maintains a reference to its outer scope. Even if the outer function completes execution and its execution context is removed from the call stack, the inner function still has access to the outer function's variables because it holds a reference to them. This is closure.

**Structure:**

```javascript
function outer() {
  let count = 0; // This variable is "closed over"

  function inner() {
    count++; // Can access and modify outer variable
    return count;
  }

  return inner; // Return the inner function
}

const counter = outer(); // outer() executes and returns inner
// outer() has finished executing, but...
console.log(counter()); // 1 - still has access to 'count'!
console.log(counter()); // 2 - same 'count' variable
console.log(counter()); // 3
```

**Key Understanding Points:**

- Closures are created every time a function is created
- Inner function maintains reference to outer scope variables
- Variables are kept alive as long as closure exists
- Each closure instance has its own set of variables
- Closures "close over" variables by reference, not value
- Functions remember the environment in which they were created

**What Gets Closed Over:**

- Variables from outer function scope
- Function parameters
- Any identifiers accessible in outer scope
- NOT the values‚Äîthe actual variable references

**Why This Matters:**
Closures enable:

1. Data privacy and encapsulation
2. Function factories
3. Callbacks with persistent state
4. Event handlers with private data
5. Module pattern
6. Memoization and caching
7. Partial application and currying

**Interview Question & Perfect Answer:**

**Q: What is a closure? Explain with an example.**

**Perfect Answer:**

> "A closure is a function that retains access to variables from its outer (enclosing) scope, even after the outer function has finished executing. It's the combination of a function and its lexical environment.
>
> Here's a clear example:
>
> ```javascript
> function createCounter() {
>   let count = 0; // Private variable
>
>   return {
>     increment: function () {
>       count++;
>       return count;
>     },
>     decrement: function () {
>       count--;
>       return count;
>     },
>     getValue: function () {
>       return count;
>     },
>   };
> }
>
> const counter1 = createCounter();
> console.log(counter1.increment()); // 1
> console.log(counter1.increment()); // 2
> console.log(counter1.getValue()); // 2
>
> const counter2 = createCounter();
> console.log(counter2.increment()); // 1 - independent closure
> ```
>
> What's happening:
>
> 1. When `createCounter()` is called, it creates a local variable `count` and three functions
> 2. These three functions form closures‚Äîthey 'close over' the `count` variable
> 3. Even after `createCounter()` finishes executing, the returned functions still have access to `count`
> 4. The `count` variable is kept alive in memory because the closures reference it
> 5. Each call to `createCounter()` creates a new, independent closure with its own `count` variable
>
> This demonstrates three key features of closures:
>
> - **Data persistence:** `count` persists between function calls
> - **Data privacy:** There's no way to access `count` directly, only through the methods
> - **Independence:** Each counter has its own separate `count`
>
> Closures are fundamental to JavaScript and enable patterns like modules, private variables, and functional programming techniques."

**Q: Explain this closure gotcha with loops:**

```javascript
for (var i = 0; i < 3; i++) {
  setTimeout(function () {
    console.log(i);
  }, 1000);
}
// Outputs: 3, 3, 3 (not 0, 1, 2)
```

**Perfect Answer:**

> "This is a classic closure interview question that demonstrates how closures capture variables by **reference**, not by **value**.
>
> **What happens:**
>
> 1. The loop creates three setTimeout callbacks
> 2. Each callback forms a closure over the variable `i`
> 3. But `var` is function-scoped (or global here), so there's only ONE `i` variable
> 4. All three closures reference the SAME `i` variable
> 5. The loop completes immediately, setting `i` to 3
> 6. When the timeouts fire 1 second later, they all access the same `i`, which is now 3
>
> **Why it prints 3, 3, 3:**
>
> - By the time the callbacks execute, the loop has finished
> - The shared `i` variable has the value 3
> - All three closures reference this same variable
>
> **Solution 1: Use let (block scope):**
>
> ```javascript
> for (let i = 0; i < 3; i++) {
>   setTimeout(function () {
>     console.log(i); // 0, 1, 2
>   }, 1000);
> }
> ```
>
> With `let`, each iteration creates a NEW `i` variable scoped to that block iteration, so each closure captures a different variable.
>
> **Solution 2: IIFE (create new scope):**
>
> ```javascript
> for (var i = 0; i < 3; i++) {
>   (function (j) {
>     setTimeout(function () {
>       console.log(j); // 0, 1, 2
>     }, 1000);
>   })(i);
> }
> ```
>
> The IIFE creates a new scope with parameter `j`, which captures the current value of `i`.
>
> **Solution 3: Function factory:**
>
> ```javascript
> for (var i = 0; i < 3; i++) {
>   setTimeout(makeLogger(i), 1000);
> }
>
> function makeLogger(value) {
>   return function () {
>     console.log(value);
>   };
> }
> ```
>
> **Solution 4: Pass to setTimeout:**
>
> ```javascript
> for (var i = 0; i < 3; i++) {
>   setTimeout(
>     function (index) {
>       console.log(index);
>     },
>     1000,
>     i
>   );
> }
> ```
>
> The key insight is that closures capture variables by reference. If you need the value, you must create a new scope with a new variable that holds that value. In modern JavaScript, using `let` is the simplest and clearest solution."

---

## 4. Use Cases for Closures

### 4.1 Data Privacy / Private Variables

**What it means:**
Closures enable data encapsulation by keeping variables private to a function scope, only exposing them through returned functions (methods).

**How it works:**
Variables declared in an outer function are inaccessible from outside, but inner functions (closures) can access and manipulate them. This creates true private variables.

**Example Pattern:**

```javascript
function createBankAccount(initialBalance) {
  let balance = initialBalance; // Private variable

  return {
    deposit(amount) {
      if (amount > 0) {
        balance += amount;
        return balance;
      }
    },
    withdraw(amount) {
      if (amount > 0 && amount <= balance) {
        balance -= amount;
        return balance;
      }
    },
    getBalance() {
      return balance;
    },
  };
}

const account = createBankAccount(100);
account.deposit(50); // 150
account.withdraw(30); // 120
console.log(account.balance); // undefined - can't access directly!
```

**Why This Matters:**

- Prevents external code from corrupting internal state
- Enforces access through controlled methods
- Enables data validation in setters
- Provides clean public API

---

### 4.2 Function Factories

**What it means:**
Functions that create and return other functions, with each created function having its own closure over different data.

**Example:**

```javascript
function createMultiplier(multiplier) {
  return function (number) {
    return number * multiplier;
  };
}

const double = createMultiplier(2);
const triple = createMultiplier(3);

console.log(double(5)); // 10
console.log(triple(5)); // 15
```

**Why This Matters:**

- Creates specialized functions from generic ones
- Each returned function has independent closure
- Enables configuration at creation time
- Reduces code duplication

---

### 4.3 Event Handlers with State

**What it means:**
Event handlers that maintain private state between invocations.

**Example:**

```javascript
function setupButton(buttonId) {
  let clickCount = 0; // Private state

  document.getElementById(buttonId).addEventListener("click", function () {
    clickCount++;
    console.log(`Button clicked ${clickCount} times`);
  });
}

setupButton("myButton");
// Each click increments the same clickCount variable
```

**Why This Matters:**

- Maintains state without global variables
- Each button gets its own independent state
- State is protected from external modification

---

### 4.4 Module Pattern

**What it means:**
Using closures and IIFEs to create modules with private and public members.

**Example:**

```javascript
const Calculator = (function () {
  // Private
  let memory = 0;

  function log(operation, result) {
    console.log(`${operation} = ${result}`);
  }

  // Public API
  return {
    add(a, b) {
      const result = a + b;
      log("add", result);
      return result;
    },
    subtract(a, b) {
      const result = a - b;
      log("subtract", result);
      return result;
    },
    saveToMemory(value) {
      memory = value;
    },
    recallMemory() {
      return memory;
    },
  };
})();

Calculator.add(5, 3); // Works
Calculator.log(); // undefined - private!
Calculator.memory; // undefined - private!
```

**Why This Matters:**

- Organizes code into logical units
- Prevents namespace pollution
- Provides clear public/private boundaries
- Was standard before ES6 modules

---

### 4.5 Currying and Partial Application

**What it means:**
Creating specialized functions by pre-filling some arguments using closures.

**Example:**

```javascript
// Currying
function curry(fn) {
  return function curried(...args) {
    if (args.length >= fn.length) {
      return fn.apply(this, args);
    }
    return function (...nextArgs) {
      return curried.apply(this, args.concat(nextArgs));
    };
  };
}

function sum(a, b, c) {
  return a + b + c;
}

const curriedSum = curry(sum);
console.log(curriedSum(1)(2)(3)); // 6
console.log(curriedSum(1, 2)(3)); // 6
console.log(curriedSum(1)(2, 3)); // 6

// Partial Application
function partial(fn, ...presetArgs) {
  return function (...laterArgs) {
    return fn(...presetArgs, ...laterArgs);
  };
}

const add10 = partial(sum, 10, 0);
console.log(add10(5)); // 15
```

**Why This Matters:**

- Creates reusable function variations
- Enables functional composition
- Improves code reusability
- Common in functional programming

---

### 4.6 Memoization / Caching

**What it means:**
Using closures to cache function results for performance optimization.

**Example:**

```javascript
function memoize(fn) {
  const cache = {}; // Private cache in closure

  return function (...args) {
    const key = JSON.stringify(args);

    if (key in cache) {
      console.log("Returning cached result");
      return cache[key];
    }

    console.log("Computing result");
    const result = fn.apply(this, args);
    cache[key] = result;
    return result;
  };
}

const slowSquare = memoize(function (n) {
  // Simulate slow operation
  for (let i = 0; i < 1000000000; i++) {}
  return n * n;
});

console.log(slowSquare(5)); // Computing result: 25
console.log(slowSquare(5)); // Returning cached result: 25
```

**Why This Matters:**

- Improves performance for expensive operations
- Cache is private and protected
- Transparent to function users
- Common optimization technique

---

## 5. Memory Implications of Closures

### Basic Concept

**What it means:**
Closures keep variables in memory as long as the closure exists. This can lead to memory leaks if not managed properly.

**How it works:**
When a closure is created, JavaScript keeps all variables from the outer scope in memory, even if the closure only uses some of them. The garbage collector can't free this memory until all references to the closure are removed.

**Memory Lifecycle:**

```javascript
function createClosure() {
  let data = new Array(1000000).fill("data"); // Large array
  let smallValue = 42;

  return function () {
    return smallValue; // Only uses smallValue
    // But 'data' is also kept in memory!
  };
}

let closure = createClosure();
// Both 'data' and 'smallValue' are kept in memory
// even though closure only uses 'smallValue'

closure = null; // Now garbage collector can free memory
```

**Key Understanding Points:**

- Closures keep ALL outer scope variables in memory
- Variables stay in memory as long as ANY closure references them
- Multiple closures can share the same outer scope
- Memory is only freed when all closures are gone
- This can cause memory leaks if closures are never released

**Common Memory Leak Scenarios:**

1. Event listeners that aren't removed
2. Timers (setInterval) that keep running
3. Large data structures closed over but not needed
4. Circular references with closures

**Interview Question & Perfect Answer:**

**Q: Can closures cause memory leaks? How do you prevent them?**

**Perfect Answer:**

> "Yes, closures can cause memory leaks if not managed properly. The issue is that closures keep their entire outer scope in memory, even if they only use a small part of it.
>
> **How memory leaks happen:**
>
> ```javascript
> function setupButton() {
>   let largeData = new Array(1000000).fill("data");
>
>   document.getElementById("btn").addEventListener("click", function () {
>     console.log("Clicked"); // Doesn't use largeData
>     // But largeData is kept in memory!
>   });
> }
>
> setupButton(); // largeData stays in memory forever
> ```
>
> Even though the event handler doesn't use `largeData`, the closure keeps it in memory because it's part of the outer scope.
>
> **Common scenarios:**
>
> 1. **Event listeners not removed:**
>
>    - Each listener is a closure
>    - If elements are removed but listeners aren't, memory leaks
>    - Old DOM nodes stay in memory
>
> 2. **Timers that never stop:**
>
>    ```javascript
>    function start() {
>      let data = getData(); // Potentially large
>      setInterval(function () {
>        doSomething(); // Keeps 'data' in memory
>      }, 1000);
>      // Timer never cleared, data never freed
>    }
>    ```
>
> 3. **Circular references:**
>    ```javascript
>    function setup() {
>      let element = document.getElementById("div");
>      element.onclick = function () {
>        console.log(element.id); // Circular reference
>      };
>    }
>    ```
>
> **Prevention strategies:**
>
> 1. **Clean up event listeners:**
>
>    ```javascript
>    const handler = function () {
>      /* ... */
>    };
>    element.addEventListener("click", handler);
>    // Later:
>    element.removeEventListener("click", handler);
>    ```
>
> 2. **Clear timers:**
>
>    ```javascript
>    const timer = setInterval(fn, 1000);
>    // Later:
>    clearInterval(timer);
>    ```
>
> 3. **Limit closure scope:**
>
>    ```javascript
>    function setup() {
>      let largeData = getData();
>      let smallPart = largeData.needed; // Extract what you need
>      largeData = null; // Release large object
>
>      return function () {
>        use(smallPart); // Closure only keeps smallPart
>      };
>    }
>    ```
>
> 4. **Use WeakMap for private data:**
>
>    ```javascript
>    const privateData = new WeakMap();
>
>    class MyClass {
>      constructor() {
>        privateData.set(this, { data: "private" });
>      }
>      // When instance is gone, WeakMap automatically cleans up
>    }
>    ```
>
> 5. **Nullify references:**
>    ```javascript
>    let closure = createClosure();
>    // Use closure...
>    closure = null; // Allow garbage collection
>    ```
>
> In modern frameworks like React, this is managed for you (useEffect cleanup functions, component unmounting), but understanding the underlying mechanism is crucial for debugging memory issues and writing efficient code."

---

## 6. IIFE (Immediately Invoked Function Expression)

### Basic Concept

**What it means:**
An IIFE is a function that runs immediately after it's defined. It creates a new scope and is commonly used with closures to create private variables and avoid polluting the global scope.

**How it works:**
By wrapping a function in parentheses and immediately invoking it, you create and execute a function in one statement. The parentheses make the function an expression (not a declaration), allowing immediate invocation.

**Syntax:**

```javascript
// Pattern 1: Grouping operator around entire expression
(function () {
  // Code here
})();

// Pattern 2: Grouping operator around function only
(function () {
  // Code here
})();

// With arrow function (ES6+)
(() => {
  // Code here
})();

// Named IIFE (useful for recursion/debugging)
(function myIIFE() {
  // Can call myIIFE recursively
})();

// With parameters
(function (global, undefined) {
  // global refers to window
  // undefined is truly undefined
})(window);
```

**Key Understanding Points:**

- Creates immediately executed function scope
- Variables inside are private (not global)
- Returns a value if needed
- Was essential before ES6 modules
- Can take parameters
- Creates closure over its own scope

**Why This Matters:**
Before ES6 modules:

- Prevented global namespace pollution
- Created module-like structures
- Provided private scope for variables
- Was the standard module pattern

**Interview Question & Perfect Answer:**

**Q: What is an IIFE and why would you use it?**

**Perfect Answer:**

> "An IIFE (Immediately Invoked Function Expression) is a function that's executed immediately after it's defined. The syntax is:
>
> ```javascript
> (function () {
>   // Code here
> })();
> ```
>
> **How it works:**
>
> 1. The parentheses around the function make it an expression (not a declaration)
> 2. The final `()` immediately invokes that function expression
> 3. This creates a new function scope that executes right away
>
> **Why use IIFEs:**
>
> **1. Avoid global scope pollution:**
>
> ```javascript
> // Without IIFE - global pollution
> var temp = "temp";
> var x = compute(temp);
> // 'temp' is now global!
>
> // With IIFE - no globals
> var x = (function () {
>   var temp = "temp"; // Private
>   return compute(temp);
> })();
> // 'temp' doesn't exist outside
> ```
>
> **2. Create private variables:**
>
> ```javascript
> const counter = (function () {
>   let count = 0; // Private
>
>   return {
>     increment() {
>       return ++count;
>     },
>     decrement() {
>       return --count;
>     },
>   };
> })();
>
> counter.increment(); // 1
> console.log(counter.count); // undefined - private!
> ```
>
> **3. Module pattern (pre-ES6):**
>
> ```javascript
> const myModule = (function () {
>   // Private
>   let privateVar = "secret";
>
>   function privateMethod() {
>     return privateVar;
>   }
>
>   // Public API
>   return {
>     publicMethod() {
>       return privateMethod();
>     },
>   };
> })();
> ```
>
> **4. Capture variable values in loops:**
>
> ```javascript
> for (var i = 0; i < 3; i++) {
>   (function (j) {
>     setTimeout(function () {
>       console.log(j); // 0, 1, 2
>     }, 1000);
>   })(i); // Pass current i value
> }
> ```
>
> **5. Safe use of globals:**
>
> ```javascript
> (function (window, undefined) {
>   // window is parameter name
>   // undefined is truly undefined
>   // Can't be overridden from outside
> })(window);
> ```
>
> **Modern Context:**
> With ES6+ modules and `let`/`const`, IIFEs are less necessary:
>
> - ES6 modules provide scope isolation
> - `let`/`const` provide block scope
> - Classes provide better encapsulation
>
> However, IIFEs are still useful for:
>
> - One-time initialization code
> - Creating isolated scopes in non-module scripts
> - Legacy code maintenance
> - Understanding closure patterns
>
> In interviews, showing you understand both the historical importance and modern alternatives demonstrates depth of knowledge."

---

## 7. Scope & Closures: Common Patterns

### Pattern 1: Counter with Private State

```javascript
function createCounter(initialValue = 0) {
  let count = initialValue;

  return {
    increment() {
      return ++count;
    },
    decrement() {
      return --count;
    },
    reset() {
      count = initialValue;
      return count;
    },
    getValue() {
      return count;
    },
  };
}

const counter = createCounter(10);
counter.increment(); // 11
counter.getValue(); // 11
counter.reset(); // 10
```

**Use Case:** Maintaining stateful data without exposing it directly.

---

### Pattern 2: Once Function

```javascript
function once(fn) {
  let called = false;
  let result;

  return function (...args) {
    if (!called) {
      called = true;
      result = fn.apply(this, args);
    }
    return result;
  };
}

const initializeOnce = once(function () {
  console.log("Initializing...");
  return "Initialized";
});

initializeOnce(); // Logs and returns "Initialized"
initializeOnce(); // Returns "Initialized" without logging
```

**Use Case:** Ensuring initialization functions run only once.

---

### Pattern 3: Debounce Function

```javascript
function debounce(fn, delay) {
  let timeoutId;

  return function (...args) {
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => {
      fn.apply(this, args);
    }, delay);
  };
}

const debouncedSearch = debounce(function (query) {
  console.log("Searching for:", query);
}, 300);

// Only last call within 300ms executes
debouncedSearch("a");
debouncedSearch("ab");
debouncedSearch("abc"); // Only this one runs
```

**Use Case:** Rate-limiting function calls (search inputs, resize handlers).

---

### Pattern 4: Private Methods

```javascript
function createPerson(name, age) {
  // Private method
  function validateAge(age) {
    return age >= 0 && age <= 120;
  }

  // Private variable
  let _age = validateAge(age) ? age : 0;

  return {
    getName() {
      return name;
    },
    getAge() {
      return _age;
    },
    setAge(newAge) {
      if (validateAge(newAge)) {
        _age = newAge;
        return true;
      }
      return false;
    },
  };
}

const person = createPerson("Alice", 30);
person.setAge(-5); // false - validation fails
person.validateAge; // undefined - private
```

**Use Case:** Encapsulation with validation logic.

---

## üéØ Summary of Key Differences

### Scope Types

| Scope Type   | Created By                  | Accessible From                    | Lifetime              |
| ------------ | --------------------------- | ---------------------------------- | --------------------- |
| **Global**   | Variables outside functions | Everywhere                         | Program lifetime      |
| **Function** | Function declarations       | Inside function & nested functions | Function execution    |
| **Block**    | let/const in {}             | Inside block only                  | Block execution       |
| **Lexical**  | Where code is written       | Determined by nesting              | Depends on references |

### Scope vs Closure

| Aspect           | Scope                          | Closure                              |
| ---------------- | ------------------------------ | ------------------------------------ |
| **What**         | Where variables are accessible | Function + its lexical environment   |
| **When Created** | When code is written/executed  | When function is created             |
| **Purpose**      | Variable accessibility rules   | Persistent access to outer variables |
| **Memory**       | Released after execution       | Kept alive by closure reference      |

---

## üé§ Common Interview Scenarios

### Scenario 1: Explain This Code

```javascript
for (var i = 0; i < 3; i++) {
  setTimeout(function () {
    console.log(i);
  }, 1000);
}
// Output: 3, 3, 3 (Why not 0, 1, 2?)
```

**Perfect Explanation:**
All three timeouts share the same closure over the same `i` variable (var is function-scoped). By the time they execute, the loop has finished and `i` is 3.

**Solution with let:**

```javascript
for (let i = 0; i < 3; i++) {
  setTimeout(function () {
    console.log(i); // 0, 1, 2
  }, 1000);
}
```

---

### Scenario 2: Create a Module

**Question:** Create a module with private state and public methods.

**Answer:**

```javascript
const TodoList = (function () {
  let todos = []; // Private
  let nextId = 1; // Private

  function find(id) {
    // Private method
    return todos.find((todo) => todo.id === id);
  }

  return {
    add(text) {
      const todo = { id: nextId++, text, done: false };
      todos.push(todo);
      return todo;
    },

    complete(id) {
      const todo = find(id);
      if (todo) todo.done = true;
      return todo;
    },

    getAll() {
      return [...todos]; // Return copy
    },
  };
})();
```

---

## üö® Common Mistakes

### 1. Expecting Values Instead of References

```javascript
// ‚ùå WRONG expectation
function createFunctions() {
  const funcs = [];
  for (var i = 0; i < 3; i++) {
    funcs.push(function () {
      return i;
    });
  }
  return funcs;
}

const funcs = createFunctions();
console.log(funcs[0]()); // 3, not 0!

// ‚úÖ CORRECT with let
function createFunctions() {
  const funcs = [];
  for (let i = 0; i < 3; i++) {
    funcs.push(function () {
      return i;
    });
  }
  return funcs;
}
```

### 2. Memory Leaks from Closures

```javascript
// ‚ùå BAD: Creates memory leak
function createHandler() {
  let largeArray = new Array(1000000);

  document.getElementById("btn").onclick = function () {
    console.log("clicked");
    // largeArray stays in memory even though not used!
  };
}

// ‚úÖ GOOD: Limit scope
function createHandler() {
  let largeArray = new Array(1000000);
  let needed = largeArray[0]; // Extract what you need
  largeArray = null; // Free memory

  document.getElementById("btn").onclick = function () {
    console.log(needed);
  };
}
```

### 3. Forgetting to Return from IIFE

```javascript
// ‚ùå WRONG: No return value
const value = (function () {
  const data = compute();
  // Forgot to return!
})();
console.log(value); // undefined

// ‚úÖ CORRECT
const value = (function () {
  const data = compute();
  return data;
})();
```

---

## üí° Pro Tips for Interviews

1. **Draw diagrams:** Visual representation of scope chains helps explain concepts
2. **Use precise terminology:** "Lexical environment," "closure over variables," "scope chain"
3. **Explain the 'why':** Don't just say what closures do, explain why they're useful
4. **Know the trade-offs:** Memory implications, when to use vs not use
5. **Connect to real work:** Module patterns, React hooks, event handlers
6. **Show modern alternatives:** ES6 modules vs IIFE, WeakMap for private data
7. **Debug step-by-step:** When explaining bugs, trace through execution

---

## üìö Quick Reference

### Creating Closures

```javascript
// Function factory
function outer(x) {
  return function inner(y) {
    return x + y; // Closure over x
  };
}

// Module pattern
const module = (function () {
  let private = "data";
  return {
    getPrivate() {
      return private;
    },
  };
})();

// Event handler with state
function setup() {
  let count = 0;
  element.onclick = function () {
    console.log(++count);
  };
}
```

### Debugging Closures

```javascript
// Check what's in closure scope
function outer() {
  let x = 1;
  let y = 2;
  return function inner() {
    debugger; // Inspect closure scope in DevTools
    return x + y;
  };
}
```

---

**Remember:** Closures are one of JavaScript's most powerful features. They enable data privacy, functional programming patterns, and are fundamental to how JavaScript works. Master them, and you'll understand most of JavaScript's "magic."
