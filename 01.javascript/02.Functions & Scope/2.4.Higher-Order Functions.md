# Higher-Order Functions

## üéØ Key Concepts

### 1. Functions as First-Class Citizens (CRITICAL!)

**What it means:**

- Functions are treated like any other value in JavaScript
- Can be assigned to variables, passed as arguments, returned from functions
- This is the foundation of functional programming in JavaScript
- Enables powerful patterns like callbacks, closures, and composition

**Functions as Values:**

```javascript
// Assign to variable
const greet = function (name) {
  return `Hello, ${name}`;
};

// Store in object
const operations = {
  add: function (a, b) {
    return a + b;
  },
  subtract: (a, b) => a - b,
};

// Store in array
const functions = [() => console.log("First"), () => console.log("Second")];
```

**Pass as Arguments:**

```javascript
// Function accepts function as parameter
function executeOperation(operation, a, b) {
  return operation(a, b);
}

const add = (x, y) => x + y;
const multiply = (x, y) => x * y;

executeOperation(add, 5, 3); // 8
executeOperation(multiply, 5, 3); // 15
```

**Return from Functions:**

```javascript
// Function returns function
function createMultiplier(factor) {
  return function (number) {
    return number * factor;
  };
}

const double = createMultiplier(2);
const triple = createMultiplier(3);

double(5); // 10
triple(5); // 15
```

**Why This Matters:**

- Enables abstraction and code reuse
- Foundation for callbacks and promises
- Powers Array methods (map, filter, reduce)
- Essential for React hooks and functional components
- Enables dependency injection and testing

**Interview Gold:** "JavaScript treats functions as first-class citizens, meaning they can be assigned to variables, passed as arguments, and returned from other functions, just like any other value."

---

### 2. Higher-Order Functions Definition (CRITICAL!)

**What it means:**

- A function that takes a function as argument OR returns a function
- Both input and output don't have to be functions simultaneously
- Core concept in functional programming
- Built-in Array methods are higher-order functions

**Higher-Order Function Patterns:**

**Pattern 1: Takes Function as Argument**

```javascript
// Array.map is a higher-order function
const numbers = [1, 2, 3];
const doubled = numbers.map(function (n) {
  return n * 2;
});

// Custom higher-order function
function repeat(n, action) {
  for (let i = 0; i < n; i++) {
    action(i);
  }
}

repeat(3, console.log); // Logs: 0, 1, 2
```

**Pattern 2: Returns Function**

```javascript
function createGreeter(greeting) {
  return function (name) {
    return `${greeting}, ${name}!`;
  };
}

const sayHello = createGreeter("Hello");
const sayHi = createGreeter("Hi");

sayHello("Alice"); // "Hello, Alice!"
sayHi("Bob"); // "Hi, Bob!"
```

**Pattern 3: Both (Takes and Returns Function)**

```javascript
function withLogging(fn) {
  return function (...args) {
    console.log(`Calling with:`, args);
    const result = fn(...args);
    console.log(`Result:`, result);
    return result;
  };
}

const add = (a, b) => a + b;
const loggedAdd = withLogging(add);

loggedAdd(2, 3);
// Logs: Calling with: [2, 3]
// Logs: Result: 5
// Returns: 5
```

**Common Higher-Order Functions:**

**Built-in Array Methods:**

```javascript
// map - transform each element
[1, 2, 3].map((x) => x * 2); // [2, 4, 6]

// filter - select elements
[1, 2, 3, 4].filter((x) => x > 2); // [3, 4]

// reduce - accumulate value
[1, 2, 3].reduce((sum, x) => sum + x, 0); // 6

// forEach - execute for each
[1, 2, 3].forEach((x) => console.log(x));

// find - find first match
[1, 2, 3].find((x) => x > 1); // 2

// some - check if any match
[1, 2, 3].some((x) => x > 2); // true

// every - check if all match
[1, 2, 3].every((x) => x > 0); // true
```

**Why They're Powerful:**

- Abstract common patterns
- Promote code reuse
- Make code more declarative
- Enable composition and chaining
- Reduce bugs through immutability

**Interview Pattern:**

```javascript
// Instead of imperative
const results = [];
for (let i = 0; i < numbers.length; i++) {
  if (numbers[i] > 10) {
    results.push(numbers[i] * 2);
  }
}

// Use declarative higher-order functions
const results = numbers.filter((n) => n > 10).map((n) => n * 2);
```

---

### 3. Callback Functions (CRITICAL!)

**What it means:**

- A function passed as an argument to be called later
- Core pattern for asynchronous operations
- Used extensively in event handling, timers, HTTP requests
- Foundation for understanding Promises and async/await

**Synchronous Callbacks:**

```javascript
// Immediate execution
function processArray(arr, callback) {
  const results = [];
  for (let item of arr) {
    results.push(callback(item));
  }
  return results;
}

const numbers = [1, 2, 3];
const doubled = processArray(numbers, (x) => x * 2);
```

**Asynchronous Callbacks:**

```javascript
// Deferred execution
setTimeout(() => {
  console.log("Executed after 1 second");
}, 1000);

// Event handlers
button.addEventListener("click", () => {
  console.log("Button clicked");
});

// HTTP requests (old style)
fetch("/api/data")
  .then((response) => response.json())
  .then((data) => console.log(data));
```

**Callback Convention (Node.js):**

```javascript
// Error-first callback pattern
function readFile(path, callback) {
  // Async operation
  if (error) {
    callback(error, null);
  } else {
    callback(null, data);
  }
}

readFile("file.txt", (error, data) => {
  if (error) {
    console.error(error);
    return;
  }
  console.log(data);
});
```

**Callback Hell (Pyramid of Doom):**

```javascript
// ‚ùå BAD: Nested callbacks (hard to read)
getData(function (a) {
  getMoreData(a, function (b) {
    getMoreData(b, function (c) {
      getMoreData(c, function (d) {
        // So many levels...
      });
    });
  });
});

// ‚úÖ GOOD: Use Promises or async/await
async function fetchData() {
  const a = await getData();
  const b = await getMoreData(a);
  const c = await getMoreData(b);
  const d = await getMoreData(c);
  return d;
}
```

**Modern Alternatives:**

- Promises for async operations
- async/await for sequential async code
- Array methods for data transformation
- Custom higher-order functions for reusable patterns

---

### 4. Function Composition (Important!)

**What it means:**

- Combining simple functions to build complex ones
- Each function takes the output of the previous one
- Promotes code reuse and modularity
- Think of it as a pipeline of transformations

**Basic Composition:**

```javascript
// Simple functions
const add10 = (x) => x + 10;
const multiply2 = (x) => x * 2;
const subtract5 = (x) => x - 5;

// Manual composition (right to left)
const result = subtract5(multiply2(add10(5)));
// 5 -> 15 -> 30 -> 25

// Compose helper (right to left)
const compose =
  (...fns) =>
  (x) =>
    fns.reduceRight((acc, fn) => fn(acc), x);

const calculate = compose(subtract5, multiply2, add10);
calculate(5); // 25

// Pipe helper (left to right - more intuitive)
const pipe =
  (...fns) =>
  (x) =>
    fns.reduce((acc, fn) => fn(acc), x);

const calculatePipe = pipe(add10, multiply2, subtract5);
calculatePipe(5); // 25
```

**Real-World Example:**

```javascript
// Data transformation pipeline
const users = [
  { name: "Alice", age: 25, active: true },
  { name: "Bob", age: 30, active: false },
  { name: "Charlie", age: 35, active: true },
];

// Individual transformations
const getActive = (users) => users.filter((u) => u.active);
const getNames = (users) => users.map((u) => u.name);
const toUpperCase = (names) => names.map((n) => n.toUpperCase());

// Compose the pipeline
const getActiveNames = pipe(getActive, getNames, toUpperCase);

getActiveNames(users); // ["ALICE", "CHARLIE"]
```

**Why It Matters:**

- DRY principle (Don't Repeat Yourself)
- Single Responsibility Principle
- Easy to test individual functions
- Easy to add/remove steps
- More maintainable code

**Point-Free Style:**

```javascript
// Not point-free (mentions parameter)
const double = (x) => x * 2;
const numbers = [1, 2, 3].map((x) => double(x));

// Point-free (no mention of parameter)
const numbers = [1, 2, 3].map(double);

// Compose without mentioning data
const processUsers = pipe(filterActive, sortByAge, mapToNames);
// Usage: processUsers(users)
```

---

### 5. Currying (Important!)

**What it means:**

- Transform a function with multiple arguments into nested functions
- Each function takes one argument and returns another function
- Enables partial application and function specialization
- Named after mathematician Haskell Curry

**Basic Currying:**

```javascript
// Regular function
function add(a, b) {
  return a + b;
}
add(2, 3); // 5

// Curried version
function addCurried(a) {
  return function (b) {
    return a + b;
  };
}
addCurried(2)(3); // 5

// Arrow function syntax (cleaner)
const addCurried = (a) => (b) => a + b;
addCurried(2)(3); // 5
```

**Partial Application:**

```javascript
// Create specialized functions
const add5 = addCurried(5);
add5(3); // 8
add5(10); // 15

const add10 = addCurried(10);
add10(5); // 15
```

**Curry Helper:**

```javascript
function curry(fn) {
  return function curried(...args) {
    if (args.length >= fn.length) {
      return fn.apply(this, args);
    }
    return function (...nextArgs) {
      return curried.apply(this, args.concat(nextArgs));
    };
  };
}

// Usage
function multiply(a, b, c) {
  return a * b * c;
}

const curriedMultiply = curry(multiply);

curriedMultiply(2)(3)(4); // 24
curriedMultiply(2, 3)(4); // 24
curriedMultiply(2)(3, 4); // 24
curriedMultiply(2, 3, 4); // 24
```

**Real-World Use Cases:**

**Event Handlers:**

```javascript
const handleClick = (id) => (event) => {
  event.preventDefault();
  console.log(`Clicked item ${id}`);
};

// Reuse for different items
button1.addEventListener("click", handleClick(1));
button2.addEventListener("click", handleClick(2));
```

**Configuration:**

```javascript
const log = (level) => (message) => {
  console.log(`[${level}] ${message}`);
};

const info = log("INFO");
const error = log("ERROR");

info("User logged in"); // [INFO] User logged in
error("Connection failed"); // [ERROR] Connection failed
```

**Data Filtering:**

```javascript
const filterBy = (property) => (value) => (obj) => obj[property] === value;

const isActive = filterBy("active")(true);
const isPremium = filterBy("plan")("premium");

users.filter(isActive);
users.filter(isPremium);
```

**Currying vs Partial Application:**

- **Currying**: Always returns single-argument functions
- **Partial Application**: Can take multiple arguments at once
- Both enable function specialization

---

### 6. Partial Application (Important!)

**What it means:**

- Create new function by fixing some arguments of existing function
- Less strict than currying (can fix multiple arguments at once)
- Useful for creating specialized versions of generic functions

**Manual Partial Application:**

```javascript
function add(a, b, c) {
  return a + b + c;
}

// Partial application
function addPartial(a) {
  return function (b, c) {
    return add(a, b, c);
  };
}

const add5 = addPartial(5);
add5(3, 2); // 10
```

**Using bind():**

```javascript
function multiply(a, b, c) {
  return a * b * c;
}

// bind creates partially applied function
const multiplyBy2 = multiply.bind(null, 2);
multiplyBy2(3, 4); // 24 (2 * 3 * 4)

const multiplyBy2And3 = multiply.bind(null, 2, 3);
multiplyBy2And3(4); // 24 (2 * 3 * 4)
```

**Partial Helper:**

```javascript
function partial(fn, ...fixedArgs) {
  return function (...remainingArgs) {
    return fn(...fixedArgs, ...remainingArgs);
  };
}

// Usage
function greet(greeting, name, punctuation) {
  return `${greeting}, ${name}${punctuation}`;
}

const greetHello = partial(greet, "Hello");
greetHello("Alice", "!"); // "Hello, Alice!"

const greetAlice = partial(greet, "Hello", "Alice");
greetAlice("!"); // "Hello, Alice!"
```

**Real-World Examples:**

**API Calls:**

```javascript
function makeRequest(method, url, data) {
  return fetch(url, { method, body: JSON.stringify(data) });
}

const get = partial(makeRequest, "GET");
const post = partial(makeRequest, "POST");

get("/api/users");
post("/api/users", userData);
```

**Validation:**

```javascript
function validate(minLength, maxLength, value) {
  return value.length >= minLength && value.length <= maxLength;
}

const validatePassword = partial(validate, 8, 20);
const validateUsername = partial(validate, 3, 15);

validatePassword("abc123xyz"); // true
validateUsername("bob"); // true
```

---

### 7. Pure Functions (CRITICAL!)

**What it means:**

- Returns same output for same input (deterministic)
- No side effects (doesn't modify external state)
- Easier to test, debug, and reason about
- Foundation of functional programming

**Pure Function Characteristics:**

**1. Same Input ‚Üí Same Output:**

```javascript
// ‚úÖ PURE: Always returns same result
function add(a, b) {
  return a + b;
}
add(2, 3); // Always 5

// ‚ùå IMPURE: Result depends on external state
let factor = 2;
function multiply(a) {
  return a * factor; // Depends on 'factor'
}
```

**2. No Side Effects:**

```javascript
// ‚úÖ PURE: No external changes
function double(arr) {
  return arr.map((x) => x * 2);
}

// ‚ùå IMPURE: Modifies original array
function doubleImpure(arr) {
  for (let i = 0; i < arr.length; i++) {
    arr[i] *= 2;
  }
  return arr;
}
```

**Side Effects Include:**

- Modifying external variables
- Modifying input arguments
- I/O operations (console.log, file writes)
- HTTP requests
- DOM manipulation
- Random number generation
- Current time/date access

**Pure Function Examples:**

```javascript
// ‚úÖ PURE
const add = (a, b) => a + b;
const multiply = (a, b) => a * b;
const capitalize = (str) => str.toUpperCase();
const filter = (arr, fn) => arr.filter(fn);

// ‚ùå IMPURE
const addRandom = (a) => a + Math.random();
const logAndReturn = (x) => {
  console.log(x);
  return x;
};
const pushItem = (arr, item) => {
  arr.push(item);
  return arr;
};
```

**Benefits of Pure Functions:**

**Testability:**

```javascript
// Easy to test - no setup/teardown needed
test("add function", () => {
  expect(add(2, 3)).toBe(5);
  expect(add(0, 0)).toBe(0);
  expect(add(-1, 1)).toBe(0);
});
```

**Predictability:**

```javascript
// Same input always gives same output
const result1 = add(2, 3); // 5
const result2 = add(2, 3); // 5 (guaranteed)
```

**Memoization:**

```javascript
// Can cache results for same inputs
function memoize(fn) {
  const cache = {};
  return function (...args) {
    const key = JSON.stringify(args);
    if (key in cache) return cache[key];
    const result = fn(...args);
    cache[key] = result;
    return result;
  };
}

const expensivePure = memoize(expensiveCalculation);
```

**Parallel Execution:**

```javascript
// Safe to run in parallel (no shared state)
const results = await Promise.all([
  process(data1),
  process(data2),
  process(data3),
]);
```

**Making Functions Pure:**

```javascript
// ‚ùå IMPURE: Modifies input
function addItem(arr, item) {
  arr.push(item);
  return arr;
}

// ‚úÖ PURE: Returns new array
function addItem(arr, item) {
  return [...arr, item];
}

// ‚ùå IMPURE: Uses external state
let count = 0;
function increment() {
  return ++count;
}

// ‚úÖ PURE: Takes state as parameter
function increment(count) {
  return count + 1;
}
```

**When Impurity is Necessary:**

- I/O operations (necessary side effects)
- Isolate at boundaries of application
- Keep core logic pure
- Clearly mark impure functions

---

## üé§ Top Interview Questions & Model Answers

### Q1: What are higher-order functions?

**Perfect Answer:**

> "Higher-order functions are functions that either take other functions as arguments, return functions, or both. They're a fundamental concept in JavaScript because functions are first-class citizens.
>
> Common examples are the built-in Array methods like `map`, `filter`, and `reduce` - they all take functions as arguments to define their behavior. You can also create higher-order functions that return functions, like a function factory that generates specialized versions.
>
> The power of higher-order functions is abstraction - they let you extract common patterns and make your code more declarative and reusable. Instead of writing loops everywhere, you use `map` to transform data, `filter` to select items, and `reduce` to aggregate.
>
> In modern JavaScript, higher-order functions are everywhere - event handlers, promises, React hooks. Understanding them is essential for writing clean, functional code."

### Q2: Explain function composition

**Perfect Answer:**

> "Function composition is the process of combining simple functions to create more complex ones, where the output of one function becomes the input of the next. It's like building a pipeline of transformations.
>
> For example, if you have `add10`, `multiply2`, and `subtract5`, you can compose them: `compose(subtract5, multiply2, add10)(5)` would give you 25, flowing right-to-left. There's also `pipe` which flows left-to-right, which many find more intuitive.
>
> The benefit is each function can be simple and single-purpose, making them easy to test and reuse. You can then combine them in different ways to create various behaviors. It follows the Unix philosophy of small, composable tools.
>
> In practice, I use composition for data transformation pipelines - like filtering, mapping, and reducing data in a clear sequence. It makes the code more declarative and easier to modify - you can add or remove steps without affecting others."

### Q3: What is currying and when would you use it?

**Perfect Answer:**

> "Currying transforms a function that takes multiple arguments into a sequence of functions, each taking a single argument. So `add(a, b)` becomes `add(a)(b)`.
>
> The main use case is creating specialized versions of generic functions through partial application. For example, if you have a curried `multiply` function, you can create `double = multiply(2)` and `triple = multiply(3)`, which are reusable specialized functions.
>
> I use currying for things like event handlers where I want to pass data: `handleClick(id)(event)` lets me create handlers for different items. Also for configuration - creating loggers with fixed log levels, or API functions with fixed methods or endpoints.
>
> The difference from regular partial application is currying always returns single-argument functions, while partial application can take multiple arguments at once. In practice, a flexible curry helper that handles both is most useful."

### Q4: What are pure functions and why are they important?

**Perfect Answer:**

> "Pure functions have two key properties: they always return the same output for the same input, and they have no side effects - they don't modify external state or perform I/O operations.
>
> They're important because they're predictable and easy to test. You don't need complex setup or teardown, and you can test them in isolation. They're also safe for parallel execution since they don't share state, and you can memoize them to cache results for expensive calculations.
>
> In practice, pure functions make code more maintainable and easier to reason about. In React, keeping components pure helps with predictable rendering and enables optimizations. In Redux, reducers must be pure to ensure state updates are predictable.
>
> That said, side effects are sometimes necessary - I/O, API calls, logging. The key is to isolate them at the boundaries of your application and keep your core business logic pure. This makes the bulk of your code easy to test while still handling the impure operations you need."

### Q5: Explain callback hell and how to avoid it

**Perfect Answer:**

> "Callback hell, also called the pyramid of doom, happens when you have multiple nested callbacks, making code hard to read and maintain. It looks like a pyramid of closing braces, and it's difficult to handle errors or follow the logic flow.
>
> The classic example is chaining async operations where each depends on the previous: you fetch data, then process it, then fetch more data, and so on. With callbacks, each step nests inside the previous one.
>
> The modern solution is Promises and async/await. Promises let you chain operations with `.then()` instead of nesting, and async/await makes async code look synchronous and sequential. Error handling is also much cleaner with try/catch blocks.
>
> Another approach is modularizing - breaking large nested callbacks into named functions. Even with callbacks, extracting each step into its own named function makes the code more readable and testable. But for new code, I always use async/await as the standard approach."

### Q6: What's the difference between map, filter, and reduce?

**Perfect Answer:**

> "`map`, `filter`, and `reduce` are the three fundamental higher-order functions for array transformation, and they each serve different purposes.
>
> `map` transforms each element and returns a new array of the same length. You use it when you want to convert data, like mapping an array of numbers to their squares, or extracting properties from objects.
>
> `filter` selects elements that meet a condition and returns a new array with only those elements. The length can be different. You use it to subset data, like getting only active users or numbers above a threshold.
>
> `reduce` is the most flexible - it accumulates values into a single result. You can sum numbers, build objects, flatten arrays, or even implement `map` and `filter` with `reduce`. It takes an accumulator and processes each element to build up the final value.
>
> In practice, I often chain them: filter to select items, map to transform them, and reduce to aggregate a result. They're essential for functional, declarative programming and avoiding mutation."

---

## üîë Must Know Checklist

### ‚úÖ Critical (Always asked)

- ‚úÖ Functions as first-class citizens
- ‚úÖ Higher-order functions definition and examples
- ‚úÖ Callback functions and callback hell
- ‚úÖ Pure functions - definition and benefits
- ‚úÖ map, filter, reduce - usage and differences

### ‚úÖ Should Know (Frequently asked)

- ‚úÖ Function composition patterns
- ‚úÖ Currying and partial application
- ‚úÖ Side effects and how to manage them
- ‚úÖ Function factories (functions returning functions)
- ‚úÖ Method chaining

### ‚úÖ Nice to Know (Senior level)

- [ ] Point-free style
- [ ] Memoization implementation
- [ ] Functional programming principles
- [ ] Transducers
- [ ] Function combinators

---

## üö® Common Mistakes to Avoid

### 1. Mutating Data in Higher-Order Functions

```javascript
// ‚ùå BAD: Mutates original array
const doubled = arr.map((item) => {
  item.value *= 2; // Mutating!
  return item;
});

// ‚úÖ GOOD: Returns new objects
const doubled = arr.map((item) => ({
  ...item,
  value: item.value * 2,
}));
```

### 2. Not Understanding map Returns New Array

```javascript
// ‚ùå BAD: Using map for side effects
arr.map((item) => console.log(item)); // Use forEach!

// ‚úÖ GOOD: Use forEach for side effects
arr.forEach((item) => console.log(item));

// ‚úÖ GOOD: Use map for transformation
const transformed = arr.map((item) => item * 2);
```

### 3. Confusing Currying with Partial Application

```javascript
// Currying (always single argument)
const curried = (a) => (b) => (c) => a + b + c;
curried(1)(2)(3);

// Partial application (can take multiple)
const partial = (a, b) => (c) => a + b + c;
partial(1, 2)(3);
```

### 4. Creating Impure Functions Unintentionally

```javascript
// ‚ùå IMPURE: Depends on external state
let multiplier = 2;
const multiply = (x) => x * multiplier;

// ‚úÖ PURE: All inputs as parameters
const multiply = (x, multiplier) => x * multiplier;
```

### 5. Callback Hell

```javascript
// ‚ùå BAD: Nested callbacks
getData((a) => {
  processData(a, (b) => {
    saveData(b, (c) => {
      // Too nested!
    });
  });
});

// ‚úÖ GOOD: Use async/await
async function process() {
  const a = await getData();
  const b = await processData(a);
  const c = await saveData(b);
  return c;
}
```

---

## üí° Pro Tips for Interviews

1. **Mention Array methods** - show you know built-in higher-order functions
2. **Explain pure functions** - demonstrates understanding of FP principles
3. **Draw data flow** - visualize composition and transformations
4. **Compare imperative vs declarative** - show you prefer modern patterns
5. **Discuss testability** - connect to real-world benefits
6. **Use arrow functions correctly** - show modern JavaScript knowledge
7. **Mention React/Redux** - connect to framework patterns

---

## üìö Quick Reference

### Array Higher-Order Functions

```javascript
map(); // Transform each element
filter(); // Select elements by condition
reduce(); // Accumulate to single value
forEach(); // Execute for each (side effects)
find(); // Find first matching element
some(); // Check if any match
every(); // Check if all match
sort(); // Sort elements (mutable!)
```

### Creating Higher-Order Functions

```javascript
// Takes function
function repeat(n, fn) {
  for (let i = 0; i < n; i++) fn(i);
}

// Returns function
function multiplier(factor) {
  return (x) => x * factor;
}

// Both
function withLogging(fn) {
  return (...args) => {
    console.log("Called");
    return fn(...args);
  };
}
```

### Composition Helpers

```javascript
// Right to left
const compose =
  (...fns) =>
  (x) =>
    fns.reduceRight((v, f) => f(v), x);

// Left to right
const pipe =
  (...fns) =>
  (x) =>
    fns.reduce((v, f) => f(v), x);
```

---

**Remember:** Higher-order functions are about abstraction and reuse. Master them to write cleaner, more maintainable JavaScript!
