# keyof and typeof Operators - Quick Guide

## üéØ Overview

These are type operators that help you extract and manipulate types. They're essential for creating type-safe, dynamic code.

---

## 1. keyof Operator (CRITICAL!)

### What is keyof?

**Definition:** Gets a union of an object type's keys

```typescript
interface User {
  name: string;
  age: number;
  email: string;
}

type UserKeys = keyof User;
// "name" | "age" | "email"

// Use it
function getProperty(user: User, key: UserKeys) {
  return user[key]; // Type-safe!
}

getProperty(user, "name"); // ‚úÖ
getProperty(user, "age"); // ‚úÖ
// getProperty(user, "invalid");  // ‚ùå Error
```

### keyof with Generic Functions

```typescript
// Most common pattern!
function getValue<T, K extends keyof T>(obj: T, key: K): T[K] {
  return obj[key];
}

const user = { name: "Alice", age: 30 };

const name = getValue(user, "name"); // string
const age = getValue(user, "age"); // number
// getValue(user, "invalid");          // ‚ùå Error
```

### keyof with Index Signatures

```typescript
interface StringMap {
  [key: string]: string;
}

type Keys = keyof StringMap;
// string | number
// (number keys get coerced to strings in JS)

interface NumberMap {
  [key: number]: string;
}

type NumKeys = keyof NumberMap;
// number
```

### keyof with Classes

```typescript
class Person {
  name: string = "";
  age: number = 0;

  greet() {
    return `Hello, ${this.name}`;
  }
}

type PersonKeys = keyof Person;
// "name" | "age" | "greet"
```

### keyof Practical Patterns

```typescript
// Pick specific keys
function pick<T, K extends keyof T>(obj: T, keys: K[]): Pick<T, K> {
  const result = {} as Pick<T, K>;
  keys.forEach((key) => {
    result[key] = obj[key];
  });
  return result;
}

const user = { name: "Alice", age: 30, email: "alice@example.com" };
const subset = pick(user, ["name", "email"]);
// { name: string; email: string }

// Update function
function update<T>(obj: T, key: keyof T, value: T[keyof T]): T {
  return { ...obj, [key]: value };
}

// Type-safe event emitter
type EventMap = {
  login: { userId: string };
  logout: void;
};

function emit<K extends keyof EventMap>(event: K, data: EventMap[K]) {
  console.log(event, data);
}

emit("login", { userId: "123" }); // ‚úÖ
emit("logout", undefined); // ‚úÖ
// emit("login", { wrong: "data" });  // ‚ùå Error
```

---

## 2. typeof Operator (CRITICAL!)

### What is typeof?

**Definition:** Extracts the type of a value/variable

**Note:** Different from JavaScript's runtime `typeof`!

```typescript
// Value space (runtime)
const user = {
  name: "Alice",
  age: 30,
};

// Type space (compile-time)
type User = typeof user;
// { name: string; age: number }

function createUser(): User {
  return { name: "Bob", age: 25 };
}
```

### typeof with Functions

```typescript
function add(a: number, b: number): number {
  return a + b;
}

type AddFunction = typeof add;
// (a: number, b: number) => number

// Use with ReturnType
type AddReturn = ReturnType<typeof add>;
// number

// Use with Parameters
type AddParams = Parameters<typeof add>;
// [a: number, b: number]
```

### typeof with const

```typescript
const config = {
  apiUrl: "https://api.example.com",
  timeout: 5000,
  retries: 3,
};

type Config = typeof config;
// {
//   apiUrl: string;
//   timeout: number;
//   retries: number;
// }

// Use as function parameter type
function initApp(config: typeof config) {
  console.log(config.apiUrl);
}
```

### typeof with as const

```typescript
// Without as const
const colors1 = {
  primary: "#007bff",
  secondary: "#6c757d",
};

type Colors1 = typeof colors1;
// { primary: string; secondary: string }

// With as const
const colors2 = {
  primary: "#007bff",
  secondary: "#6c757d",
} as const;

type Colors2 = typeof colors2;
// {
//   readonly primary: "#007bff";
//   readonly secondary: "#6c757d";
// }
```

### typeof with Enums

```typescript
enum Status {
  Active = "ACTIVE",
  Inactive = "INACTIVE",
  Pending = "PENDING",
}

// Get the enum object type
type StatusEnum = typeof Status;
// {
//   Active: Status.Active;
//   Inactive: Status.Inactive;
//   Pending: Status.Pending;
// }

// Get keys
type StatusKeys = keyof typeof Status;
// "Active" | "Inactive" | "Pending"

// Get values
type StatusValues = `${Status}`;
// "ACTIVE" | "INACTIVE" | "PENDING"
```

### typeof with Classes

```typescript
class User {
  constructor(public name: string, public age: number) {}

  greet() {
    return `Hello, ${this.name}`;
  }
}

// Type of the class constructor
type UserConstructor = typeof User;

// Type of an instance
type UserInstance = InstanceType<typeof User>;

// Use constructor type
function createUser(ctor: typeof User, name: string, age: number) {
  return new ctor(name, age);
}
```

---

## 3. Combining keyof and typeof (CRITICAL!)

### Get Keys from Value

```typescript
const person = {
  name: "Alice",
  age: 30,
  email: "alice@example.com",
};

// Get keys from the value
type PersonKeys = keyof typeof person;
// "name" | "age" | "email"

// Use in function
function getPersonProp(key: keyof typeof person) {
  return person[key];
}

getPersonProp("name"); // ‚úÖ
// getPersonProp("invalid");  // ‚ùå Error
```

### Type-Safe Configuration

```typescript
const API_ENDPOINTS = {
  users: "/api/users",
  posts: "/api/posts",
  comments: "/api/comments",
} as const;

type Endpoint = keyof typeof API_ENDPOINTS;
// "users" | "posts" | "comments"

function fetchData(endpoint: Endpoint) {
  const url = API_ENDPOINTS[endpoint];
  return fetch(url);
}

fetchData("users"); // ‚úÖ
// fetchData("invalid");  // ‚ùå Error
```

### Status Constants Pattern

```typescript
const STATUS = {
  IDLE: "idle",
  LOADING: "loading",
  SUCCESS: "success",
  ERROR: "error",
} as const;

type Status = (typeof STATUS)[keyof typeof STATUS];
// "idle" | "loading" | "success" | "error"

function updateStatus(status: Status) {
  console.log(status);
}

updateStatus(STATUS.IDLE); // ‚úÖ
updateStatus("idle"); // ‚úÖ
// updateStatus("invalid");     // ‚ùå Error
```

### Action Creators Pattern

```typescript
const actions = {
  increment: () => ({ type: "INCREMENT" as const }),
  decrement: () => ({ type: "DECREMENT" as const }),
  setValue: (value: number) => ({ type: "SET_VALUE" as const, payload: value }),
};

type Actions = ReturnType<(typeof actions)[keyof typeof actions]>;
// { type: "INCREMENT" } | { type: "DECREMENT" } | { type: "SET_VALUE"; payload: number }
```

---

## 4. Real-World Patterns

### Type-Safe Event System

```typescript
const EVENTS = {
  USER_LOGIN: "user:login",
  USER_LOGOUT: "user:logout",
  DATA_LOADED: "data:loaded",
} as const;

type EventName = (typeof EVENTS)[keyof typeof EVENTS];

interface EventPayloads {
  "user:login": { userId: string; timestamp: Date };
  "user:logout": void;
  "data:loaded": { data: unknown };
}

function emit<K extends EventName>(event: K, payload: EventPayloads[K]) {
  console.log(event, payload);
}

emit(EVENTS.USER_LOGIN, { userId: "123", timestamp: new Date() });
```

### Type-Safe Form Fields

```typescript
const FORM_FIELDS = {
  username: { type: "text", required: true },
  email: { type: "email", required: true },
  age: { type: "number", required: false },
} as const;

type FieldName = keyof typeof FORM_FIELDS;
// "username" | "email" | "age"

type FormData = {
  [K in FieldName]: string;
};

function validateField(field: FieldName, value: string): boolean {
  const config = FORM_FIELDS[field];
  if (config.required && !value) return false;
  return true;
}
```

### Deep Property Access

```typescript
type PathsToStringProps<T> = T extends string
  ? []
  : {
      [K in Extract<keyof T, string>]: [K, ...PathsToStringProps<T[K]>];
    }[Extract<keyof T, string>];

const obj = {
  user: {
    profile: {
      name: "Alice",
    },
  },
};

type Paths = PathsToStringProps<typeof obj>;
// ["user", "profile", "name"]
```

---

## üé§ Top Interview Questions

### Q1: What does keyof do and when would you use it?

**Answer:**

> "keyof takes an object type and returns a union of its keys as string literals. For example, `keyof { name: string; age: number }` gives `'name' | 'age'`. I use it constantly with generics for type-safe property access: `function get<T, K extends keyof T>(obj: T, key: K): T[K]`. This ensures you can only access properties that actually exist on the object. It's essential for creating reusable utility functions, type-safe APIs, and preventing typos in property names. Combined with mapped types, it powers most utility types like Pick and Omit."

### Q2: What's the difference between typeof in TypeScript and JavaScript?

**Answer:**

> "JavaScript's `typeof` is a runtime operator that returns a string like 'string' or 'object'. TypeScript's `typeof` is a compile-time type operator that extracts the type of a value. For example, `const user = { name: 'Alice' }; type User = typeof user;` gives you the type `{ name: string }`. You use it when you have a value and want to derive a type from it, especially useful with const objects, enums, or when you don't want to manually write out the type. Common with `ReturnType<typeof fn>` to get a function's return type."

### Q3: How do you combine keyof and typeof?

**Answer:**

> "You use `keyof typeof value` to get the keys of an object value. The `typeof` extracts the type from the value, then `keyof` gets the keys. Classic example: `const config = { api: 'url', timeout: 5000 }; type ConfigKey = keyof typeof config;` gives `'api' | 'timeout'`. This pattern is everywhere in real code - type-safe constants, enum-like objects, configuration objects. It lets you keep single source of truth as a value while still getting compile-time type checking on the keys."

### Q4: Explain the pattern: typeof STATUS[keyof typeof STATUS]

**Answer:**

> "This extracts all value types from an object. Let's break it down: `typeof STATUS` gets the object type, `keyof typeof STATUS` gets all keys, then `[keyof typeof STATUS]` indexes into it to get all values. For example: `const STATUS = { IDLE: 'idle', LOADING: 'loading' } as const; type Status = typeof STATUS[keyof typeof STATUS];` gives `'idle' | 'loading'`. The `as const` is crucial - without it, values would be just `string`. This pattern creates type-safe enums using plain objects, which is more modern than TypeScript enums."

### Q5: When would you use as const with typeof?

**Answer:**

> "Use `as const` when you want literal types instead of widened types. Without it, `const obj = { color: 'blue' }` gives `{ color: string }`. With `as const`, you get `{ readonly color: 'blue' }` - the exact literal. This is critical for type-safe constants, discriminated unions, and any time you want precise types. For example, action type constants: `const ACTIONS = { ADD: 'ADD' } as const;` ensures the type is exactly `'ADD'` not just `string`. Combined with `typeof`, it's how you create robust, type-safe configurations and constants without enums."

---

## üîë Quick Reference

### keyof Patterns

```typescript
// Get keys
type Keys = keyof MyType;

// Generic constraint
function fn<K extends keyof T>(obj: T, key: K) {}

// Map over keys
type Mapped = { [K in keyof T]: NewType };

// With index access
type Values = T[keyof T];
```

### typeof Patterns

```typescript
// Get type from value
type MyType = typeof myValue;

// With function
type FnType = typeof myFunction;
type Return = ReturnType<typeof myFunction>;

// With as const
const obj = { x: 1 } as const;
type ObjType = typeof obj; // { readonly x: 1 }

// With class
type CtorType = typeof MyClass;
type Instance = InstanceType<typeof MyClass>;
```

### Combined Patterns

```typescript
// Keys from value
type Keys = keyof typeof value;

// Values from const object
type Values = (typeof OBJ)[keyof typeof OBJ];

// Type-safe accessor
function get(key: keyof typeof obj) {
  return obj[key];
}
```

---

## üö® Common Mistakes

### 1. Forgetting typeof before keyof on values

```typescript
const obj = { x: 1, y: 2 };

// ‚ùå keyof on value
type Bad = keyof obj; // Error!

// ‚úÖ typeof first
type Good = keyof typeof obj; // "x" | "y"
```

### 2. Missing as const for literals

```typescript
const STATUS = {
  IDLE: "idle",
};

// ‚ùå Gets widened to string
type Bad = typeof STATUS.IDLE; // string

// ‚úÖ Preserves literal
const STATUS2 = {
  IDLE: "idle",
} as const;
type Good = typeof STATUS2.IDLE; // "idle"
```

### 3. Confusing type typeof with runtime typeof

```typescript
// ‚ùå Mixing concerns
if (typeof x === typeof SomeType) {
} // Error!

// ‚úÖ Correct runtime check
if (typeof x === "string") {
}

// ‚úÖ Correct type usage
type T = typeof x;
```

---

## üí° Quick Tips

1. **keyof** for keys, **typeof** for extracting types from values
2. **keyof typeof** for keys from a value object
3. **as const** for literal types
4. **Use with generics** for type-safe property access
5. **Replaces enums** - use const objects with `as const`
6. **Essential for utility types** - power many built-in types
7. **Type-safe configs** - single source of truth pattern
