# Generics - Complete Guide

## üéØ What Are Generics?

**Core Concept:**

- Create reusable, type-safe code that works with multiple types
- Like function parameters, but for types
- Preserve type information through operations
- Foundation of most TypeScript utilities and libraries

**Why Generics Matter:**

- Avoid code duplication
- Maintain type safety
- Enable flexible, reusable APIs
- Essential for libraries and frameworks

**Interview Gold:** "Generics are type parameters that create reusable, type-safe code. They're like variables for types - you define a placeholder that gets filled in when the code is used. This lets you write one function that works with many types while maintaining full type safety."

---

## 1. Generic Functions (CRITICAL!)

### Basic Syntax

```typescript
// Without generics - need multiple functions
function identityString(value: string): string {
  return value;
}

function identityNumber(value: number): number {
  return value;
}

// With generics - one function for all types!
function identity<T>(value: T): T {
  return value;
}

// TypeScript infers the type
const str = identity("hello"); // T is string
const num = identity(42); // T is number
const bool = identity(true); // T is boolean

// Or explicitly specify
const str2 = identity<string>("hello");
```

### Multiple Type Parameters

```typescript
function pair<T, U>(first: T, second: U): [T, U] {
  return [first, second];
}

const result1 = pair("hello", 42); // [string, number]
const result2 = pair(true, "world"); // [boolean, string]
const result3 = pair<string, number>("age", 30);
```

### Generic Array Operations

```typescript
function firstElement<T>(arr: T[]): T | undefined {
  return arr[0];
}

const first1 = firstElement([1, 2, 3]); // number | undefined
const first2 = firstElement(["a", "b"]); // string | undefined

function map<T, U>(arr: T[], fn: (item: T) => U): U[] {
  return arr.map(fn);
}

const numbers = [1, 2, 3];
const strings = map(numbers, (n) => n.toString()); // string[]
const doubled = map(numbers, (n) => n * 2); // number[]
```

### Generic Promise Functions

```typescript
async function fetchData<T>(url: string): Promise<T> {
  const response = await fetch(url);
  return response.json();
}

// Usage
interface User {
  id: number;
  name: string;
}

const user = await fetchData<User>("/api/user/1");
// user is typed as User
console.log(user.name);
```

### Default Type Parameters

```typescript
function createArray<T = string>(length: number, value: T): T[] {
  return Array(length).fill(value);
}

const strings = createArray(3, "hello"); // T is string (inferred)
const numbers = createArray(3, 42); // T is number (inferred)
const defaults = createArray(3); // Error: value required

// With optional parameter
function create<T = string>(value?: T): T | undefined {
  return value;
}
```

---

## 2. Generic Constraints (CRITICAL!)

### Extends Keyword

```typescript
// Constrain to types with length property
function logLength<T extends { length: number }>(value: T): void {
  console.log(value.length);
}

logLength("hello"); // ‚úÖ string has length
logLength([1, 2, 3]); // ‚úÖ array has length
logLength({ length: 10 }); // ‚úÖ object with length
// logLength(123);            // ‚ùå number doesn't have length
```

### Constraining to Object Keys

```typescript
function getProperty<T, K extends keyof T>(obj: T, key: K): T[K] {
  return obj[key];
}

const person = {
  name: "Alice",
  age: 30,
  email: "alice@example.com",
};

const name = getProperty(person, "name"); // string
const age = getProperty(person, "age"); // number
// const invalid = getProperty(person, "invalid");  // ‚ùå Error
```

### Multiple Constraints

```typescript
interface Named {
  name: string;
}

interface Aged {
  age: number;
}

// T must satisfy both interfaces
function greet<T extends Named & Aged>(person: T): string {
  return `${person.name} is ${person.age} years old`;
}

const person = { name: "Bob", age: 25, city: "NYC" };
greet(person); // ‚úÖ Has both name and age
```

### Constraint Using Another Type Parameter

```typescript
function copyFields<T, K extends keyof T>(source: T, keys: K[]): Pick<T, K> {
  const result = {} as Pick<T, K>;
  keys.forEach((key) => {
    result[key] = source[key];
  });
  return result;
}

const user = { id: 1, name: "Alice", email: "alice@example.com" };
const subset = copyFields(user, ["name", "email"]);
// subset: { name: string; email: string }
```

---

## 3. Generic Interfaces (CRITICAL!)

### Basic Generic Interface

```typescript
interface Box<T> {
  value: T;
  getValue: () => T;
  setValue: (value: T) => void;
}

const stringBox: Box<string> = {
  value: "hello",
  getValue: () => "hello",
  setValue: (v) => console.log(v),
};

const numberBox: Box<number> = {
  value: 42,
  getValue: () => 42,
  setValue: (v) => console.log(v),
};
```

### Generic Interface with Methods

```typescript
interface Repository<T> {
  items: T[];
  add(item: T): void;
  find(predicate: (item: T) => boolean): T | undefined;
  getAll(): T[];
}

class UserRepository implements Repository<User> {
  items: User[] = [];

  add(user: User): void {
    this.items.push(user);
  }

  find(predicate: (user: User) => boolean): User | undefined {
    return this.items.find(predicate);
  }

  getAll(): User[] {
    return [...this.items];
  }
}
```

### Generic Interface with Constraints

```typescript
interface Comparable<T> {
  compareTo(other: T): number;
}

interface Sortable<T extends Comparable<T>> {
  items: T[];
  sort(): void;
}

class NumberWrapper implements Comparable<NumberWrapper> {
  constructor(public value: number) {}

  compareTo(other: NumberWrapper): number {
    return this.value - other.value;
  }
}
```

### Multiple Type Parameters in Interface

```typescript
interface KeyValuePair<K, V> {
  key: K;
  value: V;
}

interface Map<K, V> {
  set(key: K, value: V): void;
  get(key: K): V | undefined;
  has(key: K): boolean;
  delete(key: K): boolean;
}

const stringNumberMap: Map<string, number> = new Map();
```

---

## 4. Generic Classes (CRITICAL!)

### Basic Generic Class

```typescript
class Stack<T> {
  private items: T[] = [];

  push(item: T): void {
    this.items.push(item);
  }

  pop(): T | undefined {
    return this.items.pop();
  }

  peek(): T | undefined {
    return this.items[this.items.length - 1];
  }

  isEmpty(): boolean {
    return this.items.length === 0;
  }
}

const numberStack = new Stack<number>();
numberStack.push(1);
numberStack.push(2);
console.log(numberStack.pop()); // 2

const stringStack = new Stack<string>();
stringStack.push("hello");
```

### Generic Class with Constraints

```typescript
interface Identifiable {
  id: string | number;
}

class EntityStore<T extends Identifiable> {
  private entities: Map<string | number, T> = new Map();

  add(entity: T): void {
    this.entities.set(entity.id, entity);
  }

  get(id: string | number): T | undefined {
    return this.entities.get(id);
  }

  remove(id: string | number): boolean {
    return this.entities.delete(id);
  }

  getAll(): T[] {
    return Array.from(this.entities.values());
  }
}

interface Product extends Identifiable {
  id: number;
  name: string;
  price: number;
}

const productStore = new EntityStore<Product>();
productStore.add({ id: 1, name: "Laptop", price: 999 });
```

### Static Members and Generics

```typescript
class Container<T> {
  private value: T;

  // ‚ùå Static members can't use class type parameters
  // static defaultValue: T;  // Error!

  // ‚úÖ Static methods can have their own type parameters
  static create<U>(value: U): Container<U> {
    return new Container(value);
  }

  constructor(value: T) {
    this.value = value;
  }

  getValue(): T {
    return this.value;
  }
}

const container = Container.create("hello"); // Container<string>
```

### Generic Class Inheritance

```typescript
class Animal {
  constructor(public name: string) {}
}

class Dog extends Animal {
  bark() {
    console.log("Woof!");
  }
}

class AnimalShelter<T extends Animal> {
  private animals: T[] = [];

  addAnimal(animal: T): void {
    this.animals.push(animal);
  }

  getAnimals(): T[] {
    return this.animals;
  }
}

// DogShelter only accepts dogs
class DogShelter extends AnimalShelter<Dog> {
  makeAllBark(): void {
    this.getAnimals().forEach((dog) => dog.bark());
  }
}
```

---

## 5. Advanced Generic Patterns

### Generic Factory Pattern

```typescript
interface Constructor<T> {
  new (...args: any[]): T;
}

function createInstance<T>(ctor: Constructor<T>, ...args: any[]): T {
  return new ctor(...args);
}

class User {
  constructor(public name: string, public age: number) {}
}

const user = createInstance(User, "Alice", 30);
// user is typed as User
```

### Generic Builder Pattern

```typescript
class QueryBuilder<T> {
  private filters: Array<(item: T) => boolean> = [];
  private sortFn?: (a: T, b: T) => number;

  where(predicate: (item: T) => boolean): this {
    this.filters.push(predicate);
    return this;
  }

  sortBy(compareFn: (a: T, b: T) => number): this {
    this.sortFn = compareFn;
    return this;
  }

  execute(items: T[]): T[] {
    let result = items.filter((item) =>
      this.filters.every((filter) => filter(item))
    );

    if (this.sortFn) {
      result = result.sort(this.sortFn);
    }

    return result;
  }
}

const users = [
  { name: "Alice", age: 30 },
  { name: "Bob", age: 25 },
  { name: "Charlie", age: 35 },
];

const result = new QueryBuilder<(typeof users)[0]>()
  .where((u) => u.age > 26)
  .sortBy((a, b) => a.name.localeCompare(b.name))
  .execute(users);
```

### Generic Type Guards

```typescript
function isArray<T>(value: T | T[]): value is T[] {
  return Array.isArray(value);
}

function ensureArray<T>(value: T | T[]): T[] {
  return isArray(value) ? value : [value];
}

const single = ensureArray(5); // number[]
const multiple = ensureArray([1, 2]); // number[]
```

### Generic Promise Utilities

```typescript
async function retry<T>(
  fn: () => Promise<T>,
  maxAttempts: number = 3
): Promise<T> {
  let lastError: Error;

  for (let i = 0; i < maxAttempts; i++) {
    try {
      return await fn();
    } catch (error) {
      lastError = error as Error;
      if (i === maxAttempts - 1) throw lastError;
    }
  }

  throw lastError!;
}

// Usage
const data = await retry(() => fetchData<User>("/api/user"));
```

### Generic Event Emitter

```typescript
type EventMap = {
  [key: string]: any;
};

type EventHandler<T> = (data: T) => void;

class TypedEventEmitter<Events extends EventMap> {
  private handlers: { [K in keyof Events]?: EventHandler<Events[K]>[] } = {};

  on<K extends keyof Events>(event: K, handler: EventHandler<Events[K]>): void {
    if (!this.handlers[event]) {
      this.handlers[event] = [];
    }
    this.handlers[event]!.push(handler);
  }

  emit<K extends keyof Events>(event: K, data: Events[K]): void {
    const handlers = this.handlers[event];
    if (handlers) {
      handlers.forEach((handler) => handler(data));
    }
  }
}

// Usage
interface MyEvents {
  login: { userId: string; timestamp: Date };
  logout: void;
  message: { from: string; text: string };
}

const emitter = new TypedEventEmitter<MyEvents>();

emitter.on("login", (data) => {
  console.log(data.userId); // TypeScript knows the shape!
});

emitter.emit("login", { userId: "123", timestamp: new Date() });
```

---

## 6. Generic Type Inference

### Inference from Arguments

```typescript
// TypeScript infers T from the argument
function toArray<T>(value: T): T[] {
  return [value];
}

const arr1 = toArray(5); // number[]
const arr2 = toArray("hello"); // string[]
const arr3 = toArray({ x: 1 }); // { x: number }[]
```

### Inference with Constraints

```typescript
function merge<T extends object, U extends object>(obj1: T, obj2: U): T & U {
  return { ...obj1, ...obj2 };
}

const merged = merge({ name: "Alice" }, { age: 30 });
// merged: { name: string } & { age: number }
console.log(merged.name, merged.age);
```

### Contextual Typing

```typescript
function map<T, U>(arr: T[], fn: (item: T) => U): U[] {
  return arr.map(fn);
}

// TypeScript infers item is number
const result = map([1, 2, 3], (item) => item * 2);

// No need to annotate item!
const strings = map([1, 2, 3], (item) => item.toString());
```

### Partial Inference

```typescript
// Can specify some types, infer others
function call<T, R>(value: T, fn: (arg: T) => R): R {
  return fn(value);
}

// Specify T, infer R
const result = call<string, number>("5", parseInt);

// Infer both
const result2 = call("hello", (s) => s.length);
```

---

## 7. Common Generic Patterns

### Generic Response Wrapper

```typescript
interface ApiResponse<T> {
  success: boolean;
  data?: T;
  error?: string;
  timestamp: Date;
}

async function fetchApi<T>(url: string): Promise<ApiResponse<T>> {
  try {
    const response = await fetch(url);
    const data = await response.json();
    return {
      success: true,
      data,
      timestamp: new Date(),
    };
  } catch (error) {
    return {
      success: false,
      error: (error as Error).message,
      timestamp: new Date(),
    };
  }
}

// Usage
const userResponse = await fetchApi<User>("/api/user");
if (userResponse.success) {
  console.log(userResponse.data?.name);
}
```

### Generic State Management

```typescript
type Action<T extends string, P = void> = P extends void
  ? { type: T }
  : { type: T; payload: P };

type Reducer<S, A> = (state: S, action: A) => S;

function createStore<S, A>(reducer: Reducer<S, A>, initialState: S) {
  let state = initialState;
  const listeners: Array<(state: S) => void> = [];

  return {
    getState: () => state,
    dispatch: (action: A) => {
      state = reducer(state, action);
      listeners.forEach((listener) => listener(state));
    },
    subscribe: (listener: (state: S) => void) => {
      listeners.push(listener);
      return () => {
        const index = listeners.indexOf(listener);
        if (index > -1) listeners.splice(index, 1);
      };
    },
  };
}
```

### Generic Data Fetching Hook Pattern

```typescript
interface UseAsyncState<T> {
  loading: boolean;
  data: T | null;
  error: Error | null;
}

type UseAsyncReturn<T> = [
  UseAsyncState<T>,
  (promise: Promise<T>) => Promise<void>
];

// This pattern commonly used in React hooks
function useAsync<T>(): UseAsyncReturn<T> {
  const state: UseAsyncState<T> = {
    loading: false,
    data: null,
    error: null,
  };

  const execute = async (promise: Promise<T>) => {
    state.loading = true;
    state.error = null;

    try {
      state.data = await promise;
    } catch (error) {
      state.error = error as Error;
    } finally {
      state.loading = false;
    }
  };

  return [state, execute];
}
```

---

## üé§ Top Interview Questions

### Q1: What are generics and why are they important?

**Answer:**

> "Generics are type parameters that let you write reusable, type-safe code. They're like function parameters but for types. Instead of writing separate functions for each type or using `any` and losing type safety, generics let you define a placeholder type that gets filled in when the code is used. They're essential because they enable type-safe reusability - you write the code once, it works with any type, but TypeScript still checks types at compile time. Every TypeScript utility type and most library APIs use generics extensively."

### Q2: Explain generic constraints with an example.

**Answer:**

> "Generic constraints limit what types can be used with a generic. You use the `extends` keyword. For example, `function getLength<T extends { length: number }>(value: T)` means T must have a length property. This is crucial because without constraints, you can't safely access properties on generic types. Another common pattern is `keyof` constraints: `function getProp<T, K extends keyof T>(obj: T, key: K)` ensures K is a valid key of T, preventing runtime errors from accessing non-existent properties."

### Q3: How do you create a generic class and what are the limitations with static members?

**Answer:**

> "Generic classes are declared with type parameters in angle brackets: `class Box<T> { value: T; }`. The key limitation is that static members can't use the class's type parameters because static members belong to the class itself, not instances. Each instance can have a different type, but there's only one static context. However, static methods can have their own separate type parameters: `static create<U>(value: U): Box<U>`. This is a common factory pattern."

### Q4: What's the difference between type inference and explicit type arguments in generics?

**Answer:**

> "Type inference means TypeScript figures out the generic type from usage, while explicit type arguments means you specify it. For example, `identity(5)` infers T as number, while `identity<string>('hi')` explicitly sets T. TypeScript's inference is very good - it looks at arguments, return types, and context. Use explicit types when inference is ambiguous, when you want to be explicit for clarity, or when TypeScript infers a type that's too specific. Most of the time, let TypeScript infer - it makes code cleaner."

### Q5: How would you implement a type-safe dictionary/map using generics?

**Answer:**

> "I'd create a generic class with two type parameters for keys and values: `class Dictionary<K extends string | number, V> { private items: Map<K, V>; set(key: K, value: V): void; get(key: K): V | undefined; }`. The key constraint ensures keys are serializable. I'd add methods like `has()`, `delete()`, `keys()`, `values()`. For better type safety, I might use `K extends keyof any` to allow symbol keys too. You could also make it implement `Iterable<[K, V]>` for iterator support. This pattern ensures compile-time type checking for both keys and values."

---

## üîë Must Know Checklist

### ‚úÖ Critical (Always asked)

- ‚úÖ Generic function syntax
- ‚úÖ Generic constraints (extends)
- ‚úÖ keyof constraints
- ‚úÖ Generic interfaces
- ‚úÖ Generic classes
- ‚úÖ Type inference with generics

### ‚úÖ Should Know (Often asked)

- ‚úÖ Multiple type parameters
- ‚úÖ Default type parameters
- ‚úÖ Generic utility patterns
- ‚úÖ Constraints with keyof
- ‚úÖ Static methods and generics

### ‚úÖ Nice to Know (Senior level)

- [ ] Generic type guards
- [ ] Complex constraint combinations
- [ ] Conditional types with generics
- [ ] Variance in generics

---

## üö® Common Mistakes

### 1. Forgetting constraints when accessing properties

```typescript
// ‚ùå Error: T might not have length
function bad<T>(value: T): number {
  return value.length; // Error!
}

// ‚úÖ Correct
function good<T extends { length: number }>(value: T): number {
  return value.length;
}
```

### 2. Using any instead of generics

```typescript
// ‚ùå Loses type safety
function bad(value: any): any {
  return value;
}

// ‚úÖ Type safe
function good<T>(value: T): T {
  return value;
}
```

### 3. Not constraining keyof access

```typescript
// ‚ùå K might not be a key of T
function bad<T, K>(obj: T, key: K): any {
  return obj[key]; // Error!
}

// ‚úÖ Correct
function good<T, K extends keyof T>(obj: T, key: K): T[K] {
  return obj[key];
}
```

### 4. Using static class type parameters

```typescript
class Bad<T> {
  // ‚ùå Static can't use T
  static value: T; // Error!

  // ‚úÖ Static can have own type parameters
  static create<U>(value: U): Bad<U> {
    return new Bad();
  }
}
```

---

## üí° Quick Tips

1. **Let TypeScript infer** when possible - cleaner code
2. **Use constraints** to safely access properties
3. **keyof is your friend** for object property access
4. **Generic != any** - generics preserve type information
5. **Multiple type parameters** for complex relationships
6. **Default types** reduce boilerplate in common cases
7. **Generic classes** for data structures and containers
8. **Type inference** reduces need for explicit types
