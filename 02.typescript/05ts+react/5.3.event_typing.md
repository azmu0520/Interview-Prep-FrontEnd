# 5.3 Event Typing

## üéØ Key Concepts

### 1. React Synthetic Events - Foundation

**What are Synthetic Events?**

- React wraps native DOM events in a cross-browser wrapper
- Provides consistent API across all browsers
- Events are pooled for performance (pre-React 17)
- Use React event types, NOT native DOM types

**Why React Events?**

```typescript
// ‚ùå WRONG - Using native DOM event
const handleClick = (e: MouseEvent) => {
  // This is the NATIVE browser MouseEvent
  console.log(e.target); // Type issues with React
};

// ‚úÖ CORRECT - Using React synthetic event
const handleClick = (e: React.MouseEvent<HTMLButtonElement>) => {
  // This is React's SyntheticEvent wrapper
  console.log(e.currentTarget); // Type-safe!
};
```

**Key Differences:**

- Native: `MouseEvent`, `KeyboardEvent`, `Event`
- React: `React.MouseEvent`, `React.KeyboardEvent`, `React.SyntheticEvent`
- React events are generic: `React.MouseEvent<ElementType>`

---

### 2. Common Event Types - The Essential Set

**Mouse Events:**

```typescript
// Click events
const handleClick = (e: React.MouseEvent<HTMLButtonElement>) => {
  console.log(e.button); // Which mouse button
  console.log(e.clientX, e.clientY); // Coordinates
  console.log(e.currentTarget); // The button element (type-safe!)
};

const handleDoubleClick = (e: React.MouseEvent<HTMLDivElement>) => {
  console.log("Double clicked!");
};

const handleContextMenu = (e: React.MouseEvent<HTMLElement>) => {
  e.preventDefault(); // Prevent right-click menu
};

// Mouse movement
const handleMouseMove = (e: React.MouseEvent<HTMLDivElement>) => {
  console.log(e.movementX, e.movementY);
};

const handleMouseEnter = (e: React.MouseEvent<HTMLDivElement>) => {
  // No bubbling (different from mouseover)
};
```

**Keyboard Events:**

```typescript
// Key press events
const handleKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {
  console.log(e.key); // The key value: 'Enter', 'a', 'Escape'
  console.log(e.code); // Physical key: 'KeyA', 'Enter'
  console.log(e.ctrlKey, e.shiftKey, e.altKey); // Modifiers

  if (e.key === "Enter") {
    e.preventDefault();
    // Submit form
  }
};

const handleKeyUp = (e: React.KeyboardEvent<HTMLTextAreaElement>) => {
  // Fired when key is released
};

const handleKeyPress = (e: React.KeyboardEvent<HTMLInputElement>) => {
  // DEPRECATED - use keyDown instead
};
```

**Form Events:**

```typescript
// Input change
const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
  console.log(e.target.value); // Current input value
  console.log(e.target.checked); // For checkboxes
};

// Textarea change
const handleTextAreaChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
  console.log(e.target.value);
};

// Select change
const handleSelectChange = (e: React.ChangeEvent<HTMLSelectElement>) => {
  console.log(e.target.value); // Selected option value
};

// Form submission
const handleSubmit = (e: React.FormEvent<HTMLFormElement>) => {
  e.preventDefault(); // ALWAYS prevent default for forms
  const formData = new FormData(e.currentTarget);
  console.log(formData.get("username"));
};

// Input focus
const handleFocus = (e: React.FocusEvent<HTMLInputElement>) => {
  console.log("Input focused");
};

const handleBlur = (e: React.FocusEvent<HTMLInputElement>) => {
  console.log("Input lost focus");
};
```

**Other Common Events:**

```typescript
// Scroll
const handleScroll = (e: React.UIEvent<HTMLDivElement>) => {
  console.log(e.currentTarget.scrollTop);
};

// Wheel (mouse wheel)
const handleWheel = (e: React.WheelEvent<HTMLDivElement>) => {
  console.log(e.deltaY); // Scroll amount
};

// Drag and drop
const handleDragStart = (e: React.DragEvent<HTMLDivElement>) => {
  e.dataTransfer.setData("text", "data");
};

const handleDrop = (e: React.DragEvent<HTMLDivElement>) => {
  e.preventDefault();
  const data = e.dataTransfer.getData("text");
};

// Clipboard
const handleCopy = (e: React.ClipboardEvent<HTMLDivElement>) => {
  console.log("Content copied");
};

const handlePaste = (e: React.ClipboardEvent<HTMLInputElement>) => {
  e.preventDefault();
  const pastedData = e.clipboardData.getData("text");
};
```

---

### 3. Generic Event Handlers - Element Type Matters

**Why Generic?**

```typescript
// Generic over element type
React.MouseEvent<T>; // T is the HTML element type

// This matters because:
const handleClick = (e: React.MouseEvent<HTMLButtonElement>) => {
  e.currentTarget; // Type: HTMLButtonElement (not just HTMLElement)
  e.currentTarget.disabled = true; // Type-safe! disabled exists on button
};
```

**Common Element Types:**

```typescript
// Button events
React.MouseEvent<HTMLButtonElement>;
React.KeyboardEvent<HTMLButtonElement>;

// Input events
React.ChangeEvent<HTMLInputElement>;
React.FocusEvent<HTMLInputElement>;
React.KeyboardEvent<HTMLInputElement>;

// Textarea events
React.ChangeEvent<HTMLTextAreaElement>;
React.KeyboardEvent<HTMLTextAreaElement>;

// Select events
React.ChangeEvent<HTMLSelectElement>;

// Div events (generic container)
React.MouseEvent<HTMLDivElement>;
React.DragEvent<HTMLDivElement>;
React.TouchEvent<HTMLDivElement>;

// Form events
React.FormEvent<HTMLFormElement>;
React.SubmitEvent<HTMLFormElement>;

// Anchor events
React.MouseEvent<HTMLAnchorElement>;

// Image events
React.MouseEvent<HTMLImageElement>;
```

**Generic Element (Flexible):**

```typescript
// When element type doesn't matter
const handleClick = (e: React.MouseEvent<HTMLElement>) => {
  // Works with any HTML element
};

// For custom components that forward events
const handleClick = (e: React.MouseEvent) => {
  // No specific element type
};
```

---

### 4. Event Handler Prop Types

**Typing Event Handler Props:**

```typescript
interface ButtonProps {
  // Simple event handler
  onClick: () => void;

  // Event handler with event object
  onMouseEnter: (e: React.MouseEvent<HTMLButtonElement>) => void;

  // Optional event handler
  onDoubleClick?: (e: React.MouseEvent<HTMLButtonElement>) => void;

  // Event handler with additional parameters
  onSelect: (id: string, e: React.MouseEvent<HTMLButtonElement>) => void;

  // Event handler returning boolean
  onValidate: (e: React.ChangeEvent<HTMLInputElement>) => boolean;
}

function Button({
  onClick,
  onMouseEnter,
  onDoubleClick,
  onSelect,
}: ButtonProps) {
  return (
    <button
      onClick={onClick}
      onMouseEnter={onMouseEnter}
      onDoubleClick={onDoubleClick}
      // Curry pattern for additional params
      onClickCapture={(e) => onSelect("btn-1", e)}
    >
      Click Me
    </button>
  );
}
```

**React.EventHandler Type:**

```typescript
// React provides a helper type
type ClickHandler = React.MouseEventHandler<HTMLButtonElement>;
type ChangeHandler = React.ChangeEventHandler<HTMLInputElement>;
type FormHandler = React.FormEventHandler<HTMLFormElement>;

interface Props {
  onClick: React.MouseEventHandler<HTMLButtonElement>;
  onChange: React.ChangeEventHandler<HTMLInputElement>;
  onSubmit: React.FormEventHandler<HTMLFormElement>;
}

// These are equivalent to:
interface PropsEquivalent {
  onClick: (e: React.MouseEvent<HTMLButtonElement>) => void;
  onChange: (e: React.ChangeEvent<HTMLInputElement>) => void;
  onSubmit: (e: React.FormEvent<HTMLFormElement>) => void;
}
```

---

### 5. currentTarget vs target - Critical Distinction

**The Difference:**

```typescript
const handleClick = (e: React.MouseEvent<HTMLDivElement>) => {
  // currentTarget: Element that the handler is attached to (type-safe)
  e.currentTarget; // Type: HTMLDivElement (guaranteed)

  // target: Element that triggered the event (type: EventTarget)
  e.target; // Type: EventTarget (could be any nested element)
};
```

**Real Example:**

```tsx
<div onClick={handleClick}>
  <button>Click me</button>
  <span>Or me</span>
</div>;

const handleClick = (e: React.MouseEvent<HTMLDivElement>) => {
  // If you click the button:
  console.log(e.target); // The <button> element
  console.log(e.currentTarget); // The <div> element (where handler is)

  // Type safety difference:
  e.currentTarget.className; // ‚úÖ Works - HTMLDivElement has className
  e.target.className; // ‚ùå Error - EventTarget doesn't have className

  // To use target properties, you need type guard:
  if (e.target instanceof HTMLButtonElement) {
    e.target.disabled = true; // ‚úÖ Now type-safe
  }
};
```

**When to Use What:**

- **currentTarget**: Use this 99% of the time - it's the element you attached the handler to
- **target**: Use when you need to know which specific child element was clicked

**Type Assertion Pattern:**

```typescript
const handleClick = (e: React.MouseEvent<HTMLDivElement>) => {
  // Type assertion (use carefully!)
  const button = e.target as HTMLButtonElement;
  button.disabled = true;

  // Better: Type guard
  if (e.target instanceof HTMLButtonElement) {
    e.target.disabled = true;
  }
};
```

---

### 6. Event Propagation and Phases

**Event Flow:**

```typescript
// Capture phase (top to bottom)
const handleClickCapture = (e: React.MouseEvent<HTMLDivElement>) => {
  console.log("Capture phase");
};

// Bubble phase (bottom to top - default)
const handleClick = (e: React.MouseEvent<HTMLDivElement>) => {
  console.log("Bubble phase");
};

<div onClick={handleClick} onClickCapture={handleClickCapture}>
  <button>Click</button>
</div>;

// Order: Capture (div) ‚Üí Target (button) ‚Üí Bubble (button ‚Üí div)
```

**Stopping Propagation:**

```typescript
const handleClick = (e: React.MouseEvent<HTMLButtonElement>) => {
  // Stop event from bubbling up
  e.stopPropagation();

  // Prevent default browser behavior
  e.preventDefault();

  // Both at once
  e.stopPropagation();
  e.preventDefault();
  // Or: return false (not recommended in React)
};
```

**Common Use Cases:**

```typescript
// Prevent link navigation
const handleLinkClick = (e: React.MouseEvent<HTMLAnchorElement>) => {
  e.preventDefault();
  // Custom navigation logic
};

// Prevent form submission reload
const handleSubmit = (e: React.FormEvent<HTMLFormElement>) => {
  e.preventDefault();
  // Handle submission with JavaScript
};

// Stop event from reaching parent
const handleButtonClick = (e: React.MouseEvent<HTMLButtonElement>) => {
  e.stopPropagation(); // Parent's onClick won't fire
  // Handle button logic
};
```

---

### 7. Form Handling Patterns

**Complete Form Example:**

```typescript
interface FormData {
  username: string;
  email: string;
  age: number;
  subscribe: boolean;
  country: string;
}

function Form() {
  const [formData, setFormData] = useState<FormData>({
    username: "",
    email: "",
    age: 0,
    subscribe: false,
    country: "US",
  });

  // Text input
  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const { name, value, type, checked } = e.target;

    setFormData((prev) => ({
      ...prev,
      [name]: type === "checkbox" ? checked : value,
    }));
  };

  // Textarea
  const handleTextAreaChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    setFormData((prev) => ({
      ...prev,
      [e.target.name]: e.target.value,
    }));
  };

  // Select dropdown
  const handleSelectChange = (e: React.ChangeEvent<HTMLSelectElement>) => {
    setFormData((prev) => ({
      ...prev,
      [e.target.name]: e.target.value,
    }));
  };

  // Form submission
  const handleSubmit = (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    console.log("Form data:", formData);
  };

  return (
    <form onSubmit={handleSubmit}>
      <input
        type="text"
        name="username"
        value={formData.username}
        onChange={handleInputChange}
      />
      <input
        type="email"
        name="email"
        value={formData.email}
        onChange={handleInputChange}
      />
      <input
        type="number"
        name="age"
        value={formData.age}
        onChange={handleInputChange}
      />
      <input
        type="checkbox"
        name="subscribe"
        checked={formData.subscribe}
        onChange={handleInputChange}
      />
      <select
        name="country"
        value={formData.country}
        onChange={handleSelectChange}
      >
        <option value="US">USA</option>
        <option value="UK">UK</option>
      </select>
      <button type="submit">Submit</button>
    </form>
  );
}
```

**Generic Form Handler:**

```typescript
// Reusable change handler for all form elements
const handleFormChange = (
  e: React.ChangeEvent<
    HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement
  >
) => {
  const target = e.target;
  const value =
    target.type === "checkbox"
      ? (target as HTMLInputElement).checked
      : target.value;
  const name = target.name;

  setFormData((prev) => ({
    ...prev,
    [name]: value,
  }));
};
```

---

### 8. Custom Event Handlers

**Wrapper Components:**

```typescript
interface CustomInputProps {
  value: string;
  onChange: (value: string) => void; // Simplified API
  onEnter?: () => void; // Custom event
}

function CustomInput({ value, onChange, onEnter }: CustomInputProps) {
  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    onChange(e.target.value); // Extract value for consumer
  };

  const handleKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {
    if (e.key === "Enter" && onEnter) {
      e.preventDefault();
      onEnter();
    }
  };

  return (
    <input value={value} onChange={handleChange} onKeyDown={handleKeyDown} />
  );
}

// Usage - simpler API for consumer
<CustomInput
  value={text}
  onChange={(val) => setText(val)} // Just string, not event
  onEnter={() => console.log("Enter pressed")}
/>;
```

**Event Handler Factories:**

```typescript
// Create handlers dynamically
const createClickHandler = (id: string) => {
  return (e: React.MouseEvent<HTMLButtonElement>) => {
    console.log(`Button ${id} clicked`);
  };
};

// Usage
{
  items.map((item) => (
    <button key={item.id} onClick={createClickHandler(item.id)}>
      {item.label}
    </button>
  ));
}
```

---

## üé§ Top Interview Questions & Model Answers

### Q1: What's the difference between React events and native DOM events?

**Answer:**

> "React uses a Synthetic Event system that wraps native browser events for cross-browser consistency. The key differences are: React events are pooled for performance in older versions, they use camelCase naming (onClick not onclick), and they're typed as `React.MouseEvent` not `MouseEvent`. When typing event handlers, you should always use React's event types because they're generic over the element type, giving you better type safety. For example, `React.MouseEvent<HTMLButtonElement>` ensures `currentTarget` is properly typed as a button element."

---

### Q2: What's the difference between target and currentTarget in React events?

**Answer:**

> "`currentTarget` is the element where the event handler is attached - it's always the same and type-safe. `target` is the element that actually triggered the event, which could be any child element. For example, if you have a div with a button inside, clicking the button will make `target` the button but `currentTarget` the div. In TypeScript, `currentTarget` is properly typed based on the generic parameter, while `target` is just `EventTarget` and needs type guards or assertions to access specific properties. I almost always use `currentTarget` because it's type-safe and predictable."

---

### Q3: How do you type a generic event handler that works with multiple element types?

**Answer:**

> "You can use a union type in the generic parameter. For example: `React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>` for a form handler that works with different input types. When you need to access specific properties of different element types, you use type guards: `if (e.target instanceof HTMLInputElement)` to narrow the type. For very generic handlers where the element type doesn't matter, you can omit the generic or use `HTMLElement` as the base type."

---

### Q4: How do you handle form submissions in React with TypeScript?

**Answer:**

> "Form submissions use `React.FormEvent<HTMLFormElement>`. The first thing is always `e.preventDefault()` to stop the browser's default submission. Then you can either use controlled components with state, or extract form data using `FormData` API with `e.currentTarget`. For example: `const formData = new FormData(e.currentTarget)` then `formData.get('fieldName')`. For better type safety, I create an interface for the form data shape and validate the extracted values before using them."

---

### Q5: When should you use stopPropagation() vs preventDefault()?

**Answer:**

> "`preventDefault()` stops the browser's default behavior - like preventing a link from navigating or a form from submitting. `stopPropagation()` stops the event from bubbling up to parent elements - useful when you have nested click handlers and don't want parent handlers to fire. They serve completely different purposes. A common mistake is using `stopPropagation()` when you actually need `preventDefault()`. For example, in form submissions, you need `preventDefault()` to stop the page reload, not `stopPropagation()`."

---

### Q6: How do you type custom event handler props?

**Answer:**

> "Custom event handler props should be typed based on what information they need. If they need the full event object, use the React event type: `onClick: (e: React.MouseEvent<HTMLButtonElement>) => void`. If they only need extracted data, simplify the API: `onChange: (value: string) => void` instead of passing the whole event. For handlers with additional parameters, add them before the event: `onSelect: (id: string, e: React.MouseEvent) => void`. Always use `void` as the return type unless the handler specifically needs to return a value."

---

### Q7: What's React.MouseEventHandler and when would you use it?

**Answer:**

> "`React.MouseEventHandler<T>` is a type alias for `(e: React.MouseEvent<T>) => void`. It's just a shorthand that makes prop types more concise. For example, `onClick: React.MouseEventHandler<HTMLButtonElement>` is equivalent to `onClick: (e: React.MouseEvent<HTMLButtonElement>) => void`. I use it when defining props interfaces to keep them cleaner, but for inline functions or local handlers, I usually type the event parameter directly because it's clearer what's happening."

---

## ‚úÖ Interview Preparation Checklist

### Must Know (Asked in 90% of interviews)

- ‚úÖ React.MouseEvent vs native MouseEvent
- ‚úÖ Common event types (click, change, submit)
- ‚úÖ currentTarget vs target
- ‚úÖ Typing form events and handlers
- ‚úÖ preventDefault() usage

### Should Know (Mid-Senior Level)

- ‚úÖ Generic event handlers
- ‚úÖ Event propagation and stopPropagation()
- ‚úÖ Event handler prop types
- ‚úÖ Keyboard event handling
- ‚úÖ React.EventHandler type aliases

### Advanced (Senior/Staff Level)

- [ ] Event pooling (React 16 and earlier)
- [ ] Custom synthetic events
- [ ] Event delegation patterns
- [ ] Optimizing event handlers
- [ ] Touch and pointer events
- [ ] Drag and drop typing

---

## üö® Common Mistakes to Avoid

### 1. Using Native DOM Event Types

```typescript
// ‚ùå WRONG - Native DOM type
const handleClick = (e: MouseEvent) => {
  console.log(e.currentTarget); // Type issues!
};

// ‚úÖ CORRECT - React synthetic event
const handleClick = (e: React.MouseEvent<HTMLButtonElement>) => {
  console.log(e.currentTarget); // Type-safe!
};
```

### 2. Forgetting to Prevent Default

```typescript
// ‚ùå WRONG - Form will cause page reload
const handleSubmit = (e: React.FormEvent) => {
  console.log("Submitting...");
  // Page reloads!
};

// ‚úÖ CORRECT - Prevent default behavior
const handleSubmit = (e: React.FormEvent<HTMLFormElement>) => {
  e.preventDefault();
  console.log("Submitting...");
};
```

### 3. Misusing target vs currentTarget

```typescript
// ‚ùå WRONG - target is not type-safe
const handleClick = (e: React.MouseEvent<HTMLDivElement>) => {
  e.target.className = "active"; // Error! EventTarget doesn't have className
};

// ‚úÖ CORRECT - Use currentTarget
const handleClick = (e: React.MouseEvent<HTMLDivElement>) => {
  e.currentTarget.className = "active"; // Works!
};
```

### 4. Incorrect Generic Type

```typescript
// ‚ùå WRONG - Generic type doesn't match element
<input
  onChange={(e: React.ChangeEvent<HTMLButtonElement>) => {}}
  // Input is not a button!
/>

// ‚úÖ CORRECT - Match the actual element
<input
  onChange={(e: React.ChangeEvent<HTMLInputElement>) => {}}
/>
```

### 5. Not Handling Checkbox Correctly

```typescript
// ‚ùå WRONG - Checkboxes use 'checked', not 'value'
const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
  setValue(e.target.value); // Wrong for checkbox
};

// ‚úÖ CORRECT - Check input type
const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
  const value =
    e.target.type === "checkbox" ? e.target.checked : e.target.value;
  setValue(value);
};
```

### 6. Creating New Handler on Every Render

```typescript
// ‚ùå WRONG - New function every render
{
  items.map((item) => (
    <button onClick={(e) => handleClick(item.id, e)}>{item.name}</button>
  ));
}

// ‚úÖ CORRECT - Use data attributes or callback
{
  items.map((item) => (
    <button data-id={item.id} onClick={handleClick}>
      {item.name}
    </button>
  ));
}

const handleClick = (e: React.MouseEvent<HTMLButtonElement>) => {
  const id = e.currentTarget.dataset.id;
};
```

---

## üí° Pro Tips

1. **Default to currentTarget**: It's type-safe and usually what you want
2. **Extract Values Early**: In custom components, extract `e.target.value` before passing to parent
3. **Use Capture Phase Sparingly**: Only when you need to intercept events before children
4. **Type Guard for target**: If you must use `target`, always use type guards
5. **Name Handlers Clearly**: `handleInputChange`, `handleButtonClick` - be specific
6. **Prevent Default First**: Put `e.preventDefault()` at the top of form handlers
7. **Avoid Inline Handlers**: For complex logic, extract to named functions
8. **Data Attributes**: Use `data-*` attributes to pass data to event handlers instead of creating new functions

---

## üìö Related Topics to Study Next

- Form handling patterns
- Controlled vs uncontrolled components
- Event handler performance optimization
- Touch and gesture events
- File input handling
- Drag and drop implementation
- Debouncing and throttling events
- React Hook Form (library)

---

## üéØ Quick Reference Table

| Event Type | React Type             | Common Elements         | Use Case             |
| ---------- | ---------------------- | ----------------------- | -------------------- |
| Click      | `React.MouseEvent`     | button, div, a          | User interactions    |
| Change     | `React.ChangeEvent`    | input, textarea, select | Form inputs          |
| Submit     | `React.FormEvent`      | form                    | Form submission      |
| KeyDown    | `React.KeyboardEvent`  | input, textarea         | Keyboard shortcuts   |
| Focus      | `React.FocusEvent`     | input, textarea         | Input focus          |
| Blur       | `React.FocusEvent`     | input, textarea         | Input blur           |
| MouseEnter | `React.MouseEvent`     | div, img                | Hover effects        |
| Scroll     | `React.UIEvent`        | div                     | Scroll detection     |
| DragStart  | `React.DragEvent`      | div                     | Drag and drop        |
| Paste      | `React.ClipboardEvent` | input, textarea         | Clipboard operations |

---

## üî• Interview Power Moves

1. **Mention Synthetic Events**: Show you understand React's abstraction layer
2. **Explain currentTarget First**: Shows you understand the type safety implications
3. **Discuss Performance**: Event handler optimization (useCallback, data attributes)
4. **Type Safety Focus**: Emphasize why React types are better than native types
5. **Real-World Examples**: Form validation, keyboard shortcuts, drag-and-drop
6. **Common Gotchas**: Checkbox handling, event pooling (legacy), preventDefault timing
