# 5.1 Component Typing

## üéØ Key Concepts

### 1. Props Interface/Type - Foundation of Type Safety

**What it means:**

- Define the shape of component props using `interface` or `type`
- TypeScript validates prop types at compile time
- Enables autocomplete and catches errors before runtime

**Basic Pattern:**

```typescript
interface ButtonProps {
  label: string;
  onClick: () => void;
  disabled?: boolean;
}

function Button({ label, onClick, disabled = false }: ButtonProps) {
  return (
    <button onClick={onClick} disabled={disabled}>
      {label}
    </button>
  );
}
```

**Interface vs Type:**

```typescript
// ‚úÖ Interface - preferred for props (extendable)
interface UserProps {
  name: string;
  age: number;
}

// ‚úÖ Type - use for unions, intersections
type Status = "idle" | "loading" | "success" | "error";
type UserWithStatus = UserProps & { status: Status };
```

**When to use what:**

- **Interface**: Component props, extendable object shapes
- **Type**: Unions, intersections, primitive aliases, tuples

---

### 2. React.FC vs Function Components (CRITICAL DEBATE!)

**React.FC (Functional Component):**

```typescript
// Using React.FC
const Button: React.FC<ButtonProps> = ({ label, onClick }) => {
  return <button onClick={onClick}>{label}</button>;
};
```

**‚ùå Problems with React.FC:**

- Implicitly includes `children` prop (often not wanted)
- Can't use generics easily
- Breaks type inference for default props
- Community consensus: avoid it

**‚úÖ Preferred Pattern - Plain Function:**

```typescript
// ‚úÖ RECOMMENDED - Plain function component
function Button({ label, onClick }: ButtonProps) {
  return <button onClick={onClick}>{label}</button>;
}

// Or arrow function
const Button = ({ label, onClick }: ButtonProps) => {
  return <button onClick={onClick}>{label}</button>;
};
```

**Why plain functions are better:**

- Explicit about children prop
- Works with generics
- Simpler, less magic
- Better default props support
- Official React docs use this pattern

---

### 3. Children Prop Typing

**The Problem:**

```typescript
// ‚ùå What type should children be?
interface CardProps {
  children: ???; // string? JSX? array?
}
```

**Solutions:**

```typescript
// ‚úÖ Option 1: React.ReactNode (most common)
interface CardProps {
  children: React.ReactNode;
}
// Accepts: string, number, JSX, arrays, fragments, null, undefined

// ‚úÖ Option 2: PropsWithChildren helper
import { PropsWithChildren } from "react";

interface CardProps {
  title: string;
}
function Card({ title, children }: PropsWithChildren<CardProps>) {
  return (
    <div>
      <h3>{title}</h3>
      {children}
    </div>
  );
}

// ‚úÖ Option 3: Specific type when needed
interface ListProps {
  children: React.ReactElement<ItemProps>[];
}
// Only accepts array of specific React elements

// ‚úÖ Option 4: Render prop pattern
interface DropdownProps {
  renderItem: (item: string) => React.ReactNode;
}
```

**Best Practices:**

- Use `React.ReactNode` for general children
- Use `PropsWithChildren<T>` utility for cleaner code
- Be specific only when necessary (validation needed)

---

### 4. Optional Props and Default Values

**Optional Props:**

```typescript
interface ButtonProps {
  label: string;
  onClick: () => void;
  variant?: "primary" | "secondary"; // Optional
  disabled?: boolean; // Optional
}

// ‚úÖ Method 1: Default in destructuring
function Button({
  label,
  onClick,
  variant = "primary",
  disabled = false,
}: ButtonProps) {
  return (
    <button className={variant} onClick={onClick} disabled={disabled}>
      {label}
    </button>
  );
}

// ‚úÖ Method 2: Separate defaults object
const defaultProps = {
  variant: "primary" as const,
  disabled: false,
};

function Button({ label, onClick, ...props }: ButtonProps) {
  const { variant, disabled } = { ...defaultProps, ...props };
  return (
    <button className={variant} onClick={onClick} disabled={disabled}>
      {label}
    </button>
  );
}
```

**Important TypeScript Quirks:**

```typescript
// ‚ùå WRONG - TypeScript doesn't narrow type from defaults
function Button({ variant = "primary" }: ButtonProps) {
  // variant is still 'string | undefined' in type system
}

// ‚úÖ CORRECT - Use type assertion or make required
interface ButtonProps {
  variant: "primary" | "secondary"; // Required, handle outside
}
```

---

### 5. Props with Callbacks - Event Handlers

**Typing Callback Props:**

```typescript
interface FormProps {
  // Simple callback
  onSubmit: () => void;

  // Callback with parameters
  onChange: (value: string) => void;

  // Callback with event
  onButtonClick: (event: React.MouseEvent<HTMLButtonElement>) => void;

  // Optional callback
  onSuccess?: (data: User) => void;

  // Callback returning value
  validate: (input: string) => boolean;

  // Async callback
  fetchData: () => Promise<User[]>;
}

// ‚úÖ Usage example
interface SearchProps {
  onSearch: (query: string) => void;
  onResultClick: (id: number) => void;
}

function Search({ onSearch, onResultClick }: SearchProps) {
  const [query, setQuery] = useState("");

  return (
    <div>
      <input value={query} onChange={(e) => setQuery(e.target.value)} />
      <button onClick={() => onSearch(query)}>Search</button>
    </div>
  );
}
```

**Best Practices:**

- Name callbacks with `on` prefix (onSubmit, onChange)
- Be explicit about parameter types
- Use `void` when return value is ignored
- Consider making callbacks optional with `?` if appropriate

---

### 6. Generic Components - Advanced Pattern

**What are Generic Components?**

- Components that work with multiple types
- Type parameter passed like generic functions
- Maintains type safety across the component

**Basic Generic Component:**

```typescript
interface ListProps<T> {
  items: T[];
  renderItem: (item: T) => React.ReactNode;
}

function List<T>({ items, renderItem }: ListProps<T>) {
  return (
    <ul>
      {items.map((item, index) => (
        <li key={index}>{renderItem(item)}</li>
      ))}
    </ul>
  );
}

// ‚úÖ Usage - Type is inferred!
<List items={users} renderItem={(user) => <div>{user.name}</div>} />;
// TypeScript knows 'user' is type User
```

**Generic with Constraints:**

```typescript
// Constrain T to objects with 'id' property
interface TableProps<T extends { id: string | number }> {
  data: T[];
  onRowClick: (item: T) => void;
}

function Table<T extends { id: string | number }>({
  data,
  onRowClick,
}: TableProps<T>) {
  return (
    <table>
      {data.map((item) => (
        <tr key={item.id} onClick={() => onRowClick(item)}>
          {/* item has 'id' guaranteed */}
        </tr>
      ))}
    </table>
  );
}
```

**Multiple Type Parameters:**

```typescript
interface SelectProps<T, K extends keyof T> {
  items: T[];
  valueKey: K;
  labelKey: K;
  onChange: (value: T[K]) => void;
}

function Select<T, K extends keyof T>({
  items,
  valueKey,
  labelKey,
  onChange,
}: SelectProps<T, K>) {
  return (
    <select
      onChange={(e) => {
        const item = items.find((i) => String(i[valueKey]) === e.target.value);
        if (item) onChange(item[valueKey]);
      }}
    >
      {items.map((item, idx) => (
        <option key={idx} value={String(item[valueKey])}>
          {String(item[labelKey])}
        </option>
      ))}
    </select>
  );
}
```

**When to Use Generics:**

- List/Table components
- Form field components
- Data containers
- Reusable UI patterns
- Any component that works with various data types

---

## üé§ Top Interview Questions & Model Answers

### Q1: Should you use React.FC? Why or why not?

**Answer:**

> "No, I avoid `React.FC`. While it was popular initially, the React community and official docs now recommend plain function components. React.FC has several issues: it implicitly includes the `children` prop which often isn't wanted, it makes working with generics difficult, and it breaks type inference for default props. Plain function components are more explicit, work better with modern React patterns, and give you full control over your prop types."

---

### Q2: How do you type the children prop?

**Answer:**

> "The most common approach is to use `React.ReactNode`, which accepts anything that React can render: strings, numbers, JSX elements, arrays, fragments, or null. For convenience, you can also use the `PropsWithChildren<T>` utility type which automatically adds `children: React.ReactNode` to your props. If you need more specific typing, like only accepting certain component types, you can use `React.ReactElement<SpecificProps>`, but that's rarely necessary."

---

### Q3: What's the difference between interface and type for component props?

**Answer:**

> "For component props, I prefer `interface` because it's extendable - you can use `extends` to build on existing interfaces, and you can declare the same interface multiple times to merge declarations. However, `type` is necessary for unions, intersections, and mapped types. In practice, I use `interface` for prop objects and `type` for unions like status strings or complex type combinations. Both work for simple cases, but `interface` is the conventional choice for React props."

---

### Q4: How do you create a generic React component?

**Answer:**

> "Generic components use TypeScript's generic syntax at the function level. For example, a List component that works with any data type would be: `function List<T>({ items, renderItem }: ListProps<T>)`. The type parameter `T` flows through the component - TypeScript knows `items` is an array of `T` and `renderItem` receives `T` as its parameter. This maintains type safety while making the component reusable. You can also add constraints like `T extends { id: string }` to require certain properties."

---

### Q5: How do you handle optional props with default values in TypeScript?

**Answer:**

> "I mark optional props with `?` in the interface and provide defaults through destructuring: `function Button({ variant = 'primary' }: ButtonProps)`. One important gotcha is that TypeScript doesn't automatically narrow the type based on the default value - it still treats the prop as potentially undefined in the type system. For stricter typing, I sometimes make the prop required in the interface and handle defaults outside the component, or use type assertions where appropriate."

---

### Q6: What's the correct way to type callback props?

**Answer:**

> "Callback props should clearly specify their parameters and return type. For example: `onChange: (value: string) => void` for a callback that receives a string and returns nothing. For event handlers, use React's event types like `onClick: (e: React.MouseEvent<HTMLButtonElement>) => void`. I name callbacks with an 'on' prefix, use `void` when the return value isn't used, and mark them optional with `?` only if they're truly optional. For async callbacks, use `Promise<T>` as the return type."

---

## ‚úÖ Interview Preparation Checklist

### Must Know (Asked in 90% of interviews)

- ‚úÖ How to define props with interface/type
- ‚úÖ React.FC vs plain function components (and why to avoid React.FC)
- ‚úÖ Typing children prop with React.ReactNode
- ‚úÖ Optional props and default values
- ‚úÖ Typing event handler props

### Should Know (Mid-Senior Level)

- ‚úÖ Generic components and when to use them
- ‚úÖ PropsWithChildren utility
- ‚úÖ Interface vs type for props
- ‚úÖ Callback prop patterns
- ‚úÖ Props with union types

### Advanced (Senior/Staff Level)

- [ ] Generic constraints (extends)
- [ ] Multiple type parameters
- [ ] Conditional prop types
- [ ] Props extraction patterns
- [ ] ForwardRef typing
- [ ] Higher-order component typing

---

## üö® Common Mistakes to Avoid

### 1. Using React.FC Unnecessarily

```typescript
// ‚ùå Outdated pattern
const Button: React.FC<ButtonProps> = ({ label }) => {
  return <button>{label}</button>;
};

// ‚úÖ Modern pattern
function Button({ label }: ButtonProps) {
  return <button>{label}</button>;
}
```

### 2. Wrong Children Type

```typescript
// ‚ùå Too restrictive
interface Props {
  children: JSX.Element; // Only accepts single element
}

// ‚úÖ Accepts anything renderable
interface Props {
  children: React.ReactNode;
}
```

### 3. Not Using Optional Props

```typescript
// ‚ùå Forces users to pass undefined
interface Props {
  onClose: (() => void) | undefined;
}

// ‚úÖ Makes it truly optional
interface Props {
  onClose?: () => void;
}
```

### 4. Forgetting Generic Constraints

```typescript
// ‚ùå Too loose - T could be anything
function Table<T>({ items }: { items: T[] }) {
  return items.map((item) => <tr key={item.id} />); // Error! No 'id'
}

// ‚úÖ Constrain T to have 'id'
function Table<T extends { id: string }>({ items }: { items: T[] }) {
  return items.map((item) => <tr key={item.id} />);
}
```

### 5. Over-typing Simple Components

```typescript
// ‚ùå Overkill for simple component
interface DivProps {
  children: React.ReactNode;
  className?: string;
  style?: React.CSSProperties;
  onClick?: React.MouseEventHandler<HTMLDivElement>;
  // ... 20 more props
}

// ‚úÖ Use native HTML props when possible
type DivProps = React.ComponentProps<"div">;
```

---

## üí° Pro Tips

1. **Start Simple**: Begin with basic interfaces, add complexity only when needed
2. **Leverage Inference**: TypeScript is smart - let it infer types when possible
3. **Use Utility Types**: `PropsWithChildren`, `ComponentProps`, `Omit`, `Pick`
4. **Think in Contracts**: Props are the API contract of your component
5. **Generic Sparingly**: Only use generics when component truly needs to work with multiple types
6. **Read Library Types**: Look at how popular libraries type their components
7. **Test Edge Cases**: Check optional props, undefined, null handling in types

---

## üìö Related Topics to Study Next

- Event typing (React.MouseEvent, etc.)
- Hooks typing (useState, useRef, etc.)
- React type utilities (ComponentProps, etc.)
- ForwardRef and ref typing
- Higher-order component typing
