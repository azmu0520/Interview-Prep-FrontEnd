# 5.2 Hooks Typing

## üéØ Key Concepts

### 1. useState - Type Inference and Explicit Typing

**What it means:**

- TypeScript can often infer useState types automatically
- Explicit typing needed for complex types or null/undefined unions
- Initial value determines the inferred type

**Basic Patterns:**

```typescript
// ‚úÖ Type inferred from initial value
const [count, setCount] = useState(0); // number
const [name, setName] = useState(""); // string
const [isOpen, setIsOpen] = useState(false); // boolean

// ‚úÖ Explicit type needed for complex types
const [user, setUser] = useState<User | null>(null);
// Without <User | null>, TypeScript infers type as 'null' only!

// ‚úÖ Array types
const [items, setItems] = useState<string[]>([]);
const [users, setUsers] = useState<User[]>([]);

// ‚úÖ Object with optional properties
interface FormData {
  email: string;
  password: string;
  rememberMe?: boolean;
}
const [form, setForm] = useState<FormData>({
  email: "",
  password: "",
});
```

**Common Pitfall - Union Types:**

```typescript
// ‚ùå WRONG - Infers as 'null', can't assign User later
const [user, setUser] = useState(null);
setUser({ name: "John" }); // Type error!

// ‚úÖ CORRECT - Explicit union type
const [user, setUser] = useState<User | null>(null);
setUser({ name: "John" }); // Works!

// ‚úÖ Alternative - Undefined instead of null
const [user, setUser] = useState<User | undefined>(undefined);
```

**When to Use Explicit Types:**

- ‚úÖ Initial value is null or undefined
- ‚úÖ Type can't be inferred (empty arrays/objects)
- ‚úÖ Union types (string | number, data | null)
- ‚úÖ Complex interfaces
- ‚ùå NOT needed when type is obvious from initial value

---

### 2. useRef - The Two Faces of Refs (CRITICAL!)

**The Problem:**
`useRef` has TWO completely different use cases with different typing patterns!

**Use Case 1: DOM References**

```typescript
// ‚úÖ For accessing DOM elements
const inputRef = useRef<HTMLInputElement>(null);
const divRef = useRef<HTMLDivElement>(null);
const buttonRef = useRef<HTMLButtonElement>(null);

// Usage
useEffect(() => {
  inputRef.current?.focus(); // Note: current might be null
}, []);

return <input ref={inputRef} />;
```

**Use Case 2: Mutable Values (Instance Variables)**

```typescript
// ‚úÖ For storing mutable values that persist across renders
const timerRef = useRef<number>();
const countRef = useRef<number>(0);
const prevValueRef = useRef<string>();

// Usage - No null check needed!
useEffect(() => {
  timerRef.current = window.setTimeout(() => {
    console.log("Delayed action");
  }, 1000);

  return () => {
    if (timerRef.current) {
      clearTimeout(timerRef.current);
    }
  };
}, []);
```

**Key Differences:**

| Aspect            | DOM Refs                        | Mutable Values                            |
| ----------------- | ------------------------------- | ----------------------------------------- |
| **Initial value** | `null`                          | Any value or `undefined`                  |
| **Type**          | `RefObject<T>`                  | `MutableRefObject<T>`                     |
| **Nullable**      | Always (`.current` can be null) | Only if you make it                       |
| **Type syntax**   | `useRef<HTMLElement>(null)`     | `useRef<number>(0)` or `useRef<number>()` |
| **Usage**         | Attached to JSX elements        | Direct manipulation                       |

**Interview Gold Pattern:**

```typescript
// DOM ref - MUST be initialized with null
const elementRef = useRef<HTMLDivElement>(null);
// Type: RefObject<HTMLDivElement>
// current is readonly and can be null

// Mutable value - initialized with value or undefined
const valueRef = useRef<number>(0);
// Type: MutableRefObject<number>
// current is writable and never null (if initialized with value)

const optionalRef = useRef<number>();
// Type: MutableRefObject<number | undefined>
// current is writable but can be undefined
```

---

### 3. useEffect and useLayoutEffect - Typing Return Functions

**What it means:**

- useEffect/useLayoutEffect callbacks are typed for cleanup functions
- TypeScript enforces correct return type
- No parameters needed on effect callbacks

**Basic Pattern:**

```typescript
// ‚úÖ No cleanup needed
useEffect(() => {
  console.log("Effect ran");
}, [dependency]);

// ‚úÖ With cleanup function
useEffect(() => {
  const timer = setTimeout(() => {}, 1000);

  return () => {
    clearTimeout(timer); // Cleanup
  };
}, []);

// ‚ùå WRONG - Can't return anything but cleanup function
useEffect(() => {
  return 123; // Type error!
}, []);

// ‚ùå WRONG - Can't be async (returns Promise)
useEffect(async () => {
  await fetchData(); // Type error!
}, []);

// ‚úÖ CORRECT - Use async inside
useEffect(() => {
  const fetchData = async () => {
    const result = await fetch("/api");
  };
  fetchData();
}, []);
```

**Dependency Array Typing:**

```typescript
// TypeScript checks dependency types automatically
const [count, setCount] = useState(0);
const [name, setName] = useState("");

useEffect(() => {
  // TypeScript knows count is number, name is string
  console.log(count, name);
}, [count, name]); // Dependency array type-checked

// ‚ö†Ô∏è TypeScript warns about missing dependencies (with ESLint)
useEffect(() => {
  console.log(count); // count used but not in deps
}, []); // Warning!
```

---

### 4. useReducer - Typed Actions and State (ESSENTIAL PATTERN!)

**What it means:**

- useReducer requires carefully typed actions
- Discriminated unions are the gold standard
- State and action types flow through reducer

**The Gold Standard Pattern:**

```typescript
// ‚úÖ Step 1: Define state type
interface State {
  count: number;
  error: string | null;
  isLoading: boolean;
}

// ‚úÖ Step 2: Define action types with discriminated union
type Action =
  | { type: "increment" }
  | { type: "decrement" }
  | { type: "set"; payload: number }
  | { type: "reset" }
  | { type: "error"; payload: string };

// ‚úÖ Step 3: Type the reducer
function reducer(state: State, action: Action): State {
  switch (action.type) {
    case "increment":
      return { ...state, count: state.count + 1 };
    case "decrement":
      return { ...state, count: state.count - 1 };
    case "set":
      // TypeScript knows action.payload exists and is number!
      return { ...state, count: action.payload };
    case "reset":
      return { ...state, count: 0, error: null };
    case "error":
      return { ...state, error: action.payload };
    default:
      // Exhaustive check - TypeScript ensures all cases handled
      const _exhaustive: never = action;
      return state;
  }
}

// ‚úÖ Step 4: Use with useReducer
const [state, dispatch] = useReducer(reducer, {
  count: 0,
  error: null,
  isLoading: false,
});

// ‚úÖ Dispatch is fully type-safe
dispatch({ type: "increment" }); // ‚úì
dispatch({ type: "set", payload: 10 }); // ‚úì
dispatch({ type: "set" }); // ‚ùå Error: payload required
dispatch({ type: "invalid" }); // ‚ùå Error: invalid type
```

**Why Discriminated Unions?**

```typescript
// ‚ùå BAD - Payload always exists, type-unsafe
type BadAction = {
  type: string;
  payload?: any;
};

// ‚úÖ GOOD - Each action shape is explicit
type GoodAction =
  | { type: "login"; payload: { username: string; password: string } }
  | { type: "logout" }
  | { type: "updateProfile"; payload: { name: string } };

// TypeScript enforces correct payload per action type!
```

**Exhaustive Checking:**

```typescript
function reducer(state: State, action: Action): State {
  switch (action.type) {
    case "increment":
      return { ...state, count: state.count + 1 };
    // ... other cases
    default:
      // This ensures all action types are handled
      const _exhaustive: never = action;
      return state;
  }
}
// If you add a new action type but forget the case,
// TypeScript will error on the default branch!
```

---

### 5. useContext - Typed Context Values

**What it means:**

- Context requires explicit typing
- Default value must match context type
- Consumer components get full type safety

**Complete Pattern:**

```typescript
// ‚úÖ Step 1: Define context value type
interface ThemeContextType {
  theme: "light" | "dark";
  toggleTheme: () => void;
}

// ‚úÖ Step 2: Create context with type and default
const ThemeContext = createContext<ThemeContextType | undefined>(undefined);
// Note: undefined means "no provider"

// ‚úÖ Step 3: Create custom hook with type guard
function useTheme() {
  const context = useContext(ThemeContext);
  if (context === undefined) {
    throw new Error("useTheme must be used within ThemeProvider");
  }
  return context;
}

// ‚úÖ Step 4: Create provider component
function ThemeProvider({ children }: { children: React.ReactNode }) {
  const [theme, setTheme] = useState<"light" | "dark">("light");

  const toggleTheme = () => {
    setTheme((prev) => (prev === "light" ? "dark" : "light"));
  };

  const value: ThemeContextType = { theme, toggleTheme };

  return (
    <ThemeContext.Provider value={value}>{children}</ThemeContext.Provider>
  );
}

// ‚úÖ Step 5: Use in components (fully typed!)
function ThemedButton() {
  const { theme, toggleTheme } = useTheme();
  // theme and toggleTheme are fully typed!
  return <button onClick={toggleTheme}>{theme}</button>;
}
```

**Alternative Pattern (Non-nullable):**

```typescript
// Create context with real default value (not undefined)
const ThemeContext = createContext<ThemeContextType>({
  theme: "light",
  toggleTheme: () => {
    console.warn("toggleTheme called outside provider");
  },
});

// Simpler hook (no undefined check needed)
function useTheme() {
  return useContext(ThemeContext);
}
```

**Which Pattern to Use?**

- **undefined + type guard**: Safer, catches missing provider at runtime
- **Default value**: Simpler, but might hide provider mistakes

---

### 6. useMemo and useCallback - Type Inference

**What it means:**

- Both hooks usually infer return types automatically
- Explicit typing rarely needed
- Dependency array type-checked

**useMemo Pattern:**

```typescript
// ‚úÖ Type inferred from returned value
const expensiveValue = useMemo(() => {
  return computeExpensiveValue(a, b);
}, [a, b]);
// Type: number (if computeExpensiveValue returns number)

// ‚úÖ Explicit type when needed
const memoizedUser = useMemo<User | null>(() => {
  if (!data) return null;
  return transformData(data);
}, [data]);

// ‚úÖ Complex computed values
interface ComputedData {
  total: number;
  average: number;
}

const stats = useMemo<ComputedData>(() => {
  return {
    total: items.reduce((sum, item) => sum + item.value, 0),
    average: items.length > 0 ? total / items.length : 0,
  };
}, [items]);
```

**useCallback Pattern:**

```typescript
// ‚úÖ Type inferred from function signature
const handleClick = useCallback(() => {
  console.log("clicked");
}, []);
// Type: () => void

// ‚úÖ With parameters
const handleSubmit = useCallback(
  (data: FormData) => {
    submitForm(data);
  },
  [submitForm]
);
// Type: (data: FormData) => void

// ‚úÖ Explicit typing when needed
const handleChange = useCallback<
  (e: React.ChangeEvent<HTMLInputElement>) => void
>((e) => {
  setValue(e.target.value);
}, []);

// ‚ö†Ô∏è Common mistake - forgetting dependencies
const handleClick = useCallback(() => {
  console.log(count); // Using count
}, []); // ‚ùå Missing count in dependencies!

// ‚úÖ Correct
const handleClick = useCallback(() => {
  console.log(count);
}, [count]); // ‚úì count in dependencies
```

---

### 7. Custom Hooks - Typing Patterns

**What it means:**

- Custom hooks are just functions that use hooks
- Return type usually inferred
- Explicit typing for complex return values

**Basic Custom Hook:**

```typescript
// ‚úÖ Simple custom hook
function useToggle(initialValue = false) {
  const [value, setValue] = useState(initialValue);

  const toggle = useCallback(() => {
    setValue((v) => !v);
  }, []);

  return [value, toggle] as const;
  // 'as const' makes it readonly tuple: [boolean, () => void]
}

// Usage
const [isOpen, toggleOpen] = useToggle();
```

**Generic Custom Hook:**

```typescript
// ‚úÖ Generic hook for local storage
function useLocalStorage<T>(key: string, initialValue: T) {
  const [storedValue, setStoredValue] = useState<T>(() => {
    try {
      const item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      return initialValue;
    }
  });

  const setValue = (value: T | ((val: T) => T)) => {
    try {
      const valueToStore =
        value instanceof Function ? value(storedValue) : value;
      setStoredValue(valueToStore);
      window.localStorage.setItem(key, JSON.stringify(valueToStore));
    } catch (error) {
      console.error(error);
    }
  };

  return [storedValue, setValue] as const;
}

// Usage - Type inferred from initial value
const [user, setUser] = useLocalStorage<User>("user", { name: "" });
```

**Object Return Pattern:**

```typescript
// ‚úÖ Return object instead of array for clarity
interface UseCounterReturn {
  count: number;
  increment: () => void;
  decrement: () => void;
  reset: () => void;
}

function useCounter(initialValue = 0): UseCounterReturn {
  const [count, setCount] = useState(initialValue);

  return {
    count,
    increment: useCallback(() => setCount((c) => c + 1), []),
    decrement: useCallback(() => setCount((c) => c - 1), []),
    reset: useCallback(() => setCount(initialValue), [initialValue]),
  };
}

// Usage - destructure what you need
const { count, increment } = useCounter(10);
```

**Async Custom Hook:**

```typescript
interface UseFetchReturn<T> {
  data: T | null;
  loading: boolean;
  error: Error | null;
}

function useFetch<T>(url: string): UseFetchReturn<T> {
  const [data, setData] = useState<T | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);

  useEffect(() => {
    const fetchData = async () => {
      try {
        const response = await fetch(url);
        const json = await response.json();
        setData(json);
      } catch (err) {
        setError(err as Error);
      } finally {
        setLoading(false);
      }
    };

    fetchData();
  }, [url]);

  return { data, loading, error };
}

// Usage
const { data, loading, error } = useFetch<User[]>("/api/users");
```

---

## üé§ Top Interview Questions & Model Answers

### Q1: When do you need to explicitly type useState?

**Answer:**

> "TypeScript can infer the type from the initial value, so explicit typing is usually not needed for primitives. However, you must provide explicit types when: (1) the initial value is null or undefined and you'll assign a different type later, like `useState<User | null>(null)`, (2) you're working with empty arrays or objects where the type can't be inferred, like `useState<string[]>([])`, or (3) you need union types where the initial value doesn't represent all possible types. The rule of thumb is: if TypeScript can figure it out from the initial value, let it; otherwise, be explicit."

---

### Q2: What's the difference between useRef for DOM elements vs mutable values?

**Answer:**

> "This is a critical distinction. For DOM elements, you use `useRef<HTMLElement>(null)` which creates a `RefObject<T>` where `.current` is readonly and can be null. For mutable values like timers or counters, you use `useRef<number>(0)` or `useRef<number>()` which creates a `MutableRefObject<T>` where `.current` is writable. The key difference is the initial value: `null` for DOM refs, and an actual value or undefined for mutable values. DOM refs are attached to JSX elements via the ref prop, while mutable values are directly manipulated in code."

---

### Q3: How do you type useReducer actions properly?

**Answer:**

> "The best practice is using discriminated unions for action types. You define a type that's a union of object types, each with a unique 'type' string literal and its own payload shape. For example: `type Action = { type: 'increment' } | { type: 'set'; payload: number }`. This gives you full type safety‚ÄîTypeScript knows exactly which payload is available for each action type in your switch statement. I also use exhaustive checking with `const _exhaustive: never = action` in the default case to ensure all action types are handled. This pattern prevents runtime errors and catches mistakes at compile time."

---

### Q4: How do you create a typed context with TypeScript?

**Answer:**

> "I follow a four-step pattern: First, define the context value interface. Second, create the context with `createContext<MyType | undefined>(undefined)` where undefined signals no provider. Third, create a custom hook that calls useContext and throws an error if the value is undefined‚Äîthis acts as a type guard and catches missing provider errors at runtime. Fourth, create the provider component that supplies the actual value. This pattern is safer than providing a default value because it catches the mistake of using the context outside its provider."

---

### Q5: Do useMemo and useCallback need explicit types?

**Answer:**

> "Usually no‚ÄîTypeScript infers the return type from the callback function you pass in. For useMemo, it infers from what you return; for useCallback, it infers from the function signature. Explicit typing is only needed in complex scenarios where inference fails or when you want to enforce a specific return type. The more important thing with these hooks is making sure your dependency arrays are correct, which TypeScript and ESLint can help validate."

---

### Q6: How do you type custom hooks?

**Answer:**

> "Custom hooks are just functions, so standard function typing applies. The return type is usually inferred, but I explicitly type it for complex hooks. For hooks that return multiple values, I use 'as const' with array returns to create a readonly tuple, like `[value, setValue] as const`, which preserves the specific types instead of widening to a union. For hooks with many return values, I prefer returning an object instead of an array for better clarity. Generic custom hooks use standard generic syntax, and the type is usually inferred from usage, like `useLocalStorage<User>('key', defaultUser)`."

---

## ‚úÖ Interview Preparation Checklist

### Must Know (Asked in 90% of interviews)

- ‚úÖ When to explicitly type useState vs letting TypeScript infer
- ‚úÖ useRef difference: DOM refs vs mutable values
- ‚úÖ useReducer with discriminated unions
- ‚úÖ Basic useContext typing
- ‚úÖ useEffect return function (cleanup) typing

### Should Know (Mid-Senior Level)

- ‚úÖ Custom hooks return type patterns ('as const' for tuples)
- ‚úÖ Generic custom hooks
- ‚úÖ useContext with type guards
- ‚úÖ useMemo/useCallback type inference
- ‚úÖ Async effects pattern (can't be async directly)

### Advanced (Senior/Staff Level)

- [ ] Exhaustive checking in reducers
- [ ] Complex generic hooks with constraints
- [ ] Hook composition patterns
- [ ] Performance optimization hook typing
- [ ] Custom hook testing strategies

---

## üö® Common Mistakes to Avoid

### 1. Wrong useState for Null/Undefined Union

```typescript
// ‚ùå Type inferred as 'null' only
const [user, setUser] = useState(null);

// ‚úÖ Explicit union type
const [user, setUser] = useState<User | null>(null);
```

### 2. Confusing useRef Types

```typescript
// ‚ùå Wrong - will have null issues
const timerRef = useRef<number>(null);

// ‚úÖ Correct for mutable value
const timerRef = useRef<number>();
```

### 3. Async useEffect

```typescript
// ‚ùå Can't make effect async
useEffect(async () => {
  await fetchData();
}, []);

// ‚úÖ Async function inside effect
useEffect(() => {
  const fetch = async () => {
    await fetchData();
  };
  fetch();
}, []);
```

### 4. Loose Reducer Actions

```typescript
// ‚ùå Any action type allowed
type Action = {
  type: string;
  payload?: any;
};

// ‚úÖ Discriminated union
type Action =
  | { type: "add"; payload: Item }
  | { type: "remove"; payload: string };
```

### 5. Missing Context Type Guard

```typescript
// ‚ùå Context could be undefined
const value = useContext(MyContext);
value.someMethod(); // Might crash!

// ‚úÖ Custom hook with type guard
function useMyContext() {
  const ctx = useContext(MyContext);
  if (!ctx) throw new Error("Missing provider");
  return ctx;
}
```

---

## üí° Pro Tips

1. **Let TypeScript Infer**: Don't over-type; inference works great for most hooks
2. **'as const' for Tuples**: Custom hooks returning arrays need this for proper typing
3. **Discriminated Unions**: Always use for reducer actions‚Äîit's the gold standard
4. **Type Guards in Context**: Protect against missing providers with custom hooks
5. **Generic Hooks**: Make them reusable but constrain types when needed
6. **Dependency Arrays**: Trust ESLint's exhaustive-deps rule
7. **Ref Initial Values**: `null` for DOM, actual value for mutable refs
