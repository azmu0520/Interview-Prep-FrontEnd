# Type Guards and Narrowing - Deep Dive

## üéØ Key Concepts

### 1. What is Type Narrowing? (CRITICAL!)

**What it means:**

- Refining a broad type to a more specific type
- TypeScript analyzes control flow to understand types
- Happens automatically in if/switch statements
- Makes working with union types safe and practical

**Why it's important:**

- Union types are common (string | number, User | null)
- Need to safely access properties specific to one type
- TypeScript tracks which type is possible in each branch
- Essential for type-safe code

**Basic example:**

```typescript
function padLeft(value: string, padding: string | number) {
  if (typeof padding === "number") {
    // TypeScript knows: padding is number here
    return " ".repeat(padding) + value;
  }
  // TypeScript knows: padding is string here
  return padding + value;
}
```

**Interview Gold:** "Type narrowing is TypeScript's ability to refine types within conditional branches. Using type guards like typeof, instanceof, or custom checks, TypeScript tracks which type is possible in each code path, allowing safe property access without type assertions."

---

### 2. typeof Type Guards (CRITICAL!)

**What it means:**

- Use JavaScript's `typeof` operator for type checking
- Works with primitives: string, number, boolean, symbol, undefined, function
- TypeScript recognizes it and narrows types automatically

**How it works:**

```typescript
function print(value: string | number | boolean) {
  if (typeof value === "string") {
    // value is string
    console.log(value.toUpperCase());
  } else if (typeof value === "number") {
    // value is number
    console.log(value.toFixed(2));
  } else {
    // value is boolean
    console.log(value ? "Yes" : "No");
  }
}
```

**Important notes:**

- `typeof null === "object"` (JavaScript quirk!)
- `typeof array === "object"` (need different check)
- `typeof function === "function"` ‚úÖ works

**Practical pattern:**

```typescript
function processInput(input: string | number) {
  // Check for number first
  if (typeof input === "number") {
    return input * 2;
  }
  // TypeScript knows it must be string now
  return input.trim();
}
```

---

### 3. Truthiness Narrowing

**What it means:**

- Use JavaScript truthiness to narrow types
- Falsy values: false, 0, -0, "", null, undefined, NaN
- Everything else is truthy

**How it works:**

```typescript
function printName(name: string | null | undefined) {
  if (name) {
    // name is string (null/undefined eliminated)
    console.log(name.toUpperCase());
  } else {
    // name is null or undefined
    console.log("No name provided");
  }
}
```

**Array/object checks:**

```typescript
function processArray(arr: string[] | null) {
  if (arr && arr.length > 0) {
    // arr is definitely string[] with items
    arr.forEach((item) => console.log(item));
  }
}
```

**Watch out for:**

```typescript
function multiply(a: number | undefined, b: number | undefined) {
  if (a && b) {
    // ‚ö†Ô∏è Excludes 0! Use a !== undefined instead
    return a * b;
  }
}
```

---

### 4. Equality Narrowing

**What it means:**

- Use === or !== to narrow types
- Works with literal types and unions
- Can compare variables to each other

**Basic equality:**

```typescript
function compare(x: string | number, y: string | boolean) {
  if (x === y) {
    // Both must be string (only common type)
    console.log(x.toUpperCase());
  }
}
```

**Null checking:**

```typescript
function process(value: string | null) {
  if (value !== null) {
    // value is string
    console.log(value.length);
  }
}
```

**Multiple checks:**

```typescript
function handle(status: "success" | "error" | "loading") {
  if (status === "success" || status === "error") {
    // status is "success" | "error"
  } else {
    // status is "loading"
  }
}
```

---

### 5. instanceof Type Guards

**What it means:**

- Check if value is instance of a class
- Works with JavaScript built-ins and custom classes
- Narrows to the class type

**Basic usage:**

```typescript
function processInput(input: Date | string) {
  if (input instanceof Date) {
    // input is Date
    console.log(input.getFullYear());
  } else {
    // input is string
    console.log(input.toLowerCase());
  }
}
```

**With custom classes:**

```typescript
class Dog {
  bark() {
    console.log("Woof!");
  }
}

class Cat {
  meow() {
    console.log("Meow!");
  }
}

function makeSound(animal: Dog | Cat) {
  if (animal instanceof Dog) {
    animal.bark();
  } else {
    animal.meow();
  }
}
```

**Built-in types:**

```typescript
function process(value: unknown) {
  if (value instanceof Array) {
    value.forEach((item) => console.log(item));
  } else if (value instanceof Error) {
    console.error(value.message);
  }
}
```

---

### 6. in Operator Narrowing (CRITICAL!)

**What it means:**

- Check if property exists in object
- JavaScript's `in` operator
- Great for discriminating between object types

**Basic usage:**

```typescript
type Fish = { swim: () => void };
type Bird = { fly: () => void };

function move(animal: Fish | Bird) {
  if ("swim" in animal) {
    // animal is Fish
    animal.swim();
  } else {
    // animal is Bird
    animal.fly();
  }
}
```

**With interfaces:**

```typescript
interface Circle {
  kind: "circle";
  radius: number;
}

interface Square {
  kind: "square";
  sideLength: number;
}

type Shape = Circle | Square;

function getArea(shape: Shape) {
  if ("radius" in shape) {
    // shape is Circle
    return Math.PI * shape.radius ** 2;
  }
  // shape is Square
  return shape.sideLength ** 2;
}
```

---

### 7. Discriminated Unions (CRITICAL!)

**What it means:**

- Union types with a common literal property (discriminant)
- Most powerful pattern for narrowing
- TypeScript narrows based on discriminant value

**Basic pattern:**

```typescript
interface Success {
  status: "success";
  data: string;
}

interface Error {
  status: "error";
  error: string;
}

type Result = Success | Error;

function handleResult(result: Result) {
  if (result.status === "success") {
    // result is Success
    console.log(result.data);
  } else {
    // result is Error
    console.log(result.error);
  }
}
```

**With switch:**

```typescript
interface Circle {
  kind: "circle";
  radius: number;
}

interface Square {
  kind: "square";
  sideLength: number;
}

interface Triangle {
  kind: "triangle";
  base: number;
  height: number;
}

type Shape = Circle | Square | Triangle;

function getArea(shape: Shape): number {
  switch (shape.kind) {
    case "circle":
      return Math.PI * shape.radius ** 2;
    case "square":
      return shape.sideLength ** 2;
    case "triangle":
      return (shape.base * shape.height) / 2;
  }
}
```

**Real-world pattern (API state):**

```typescript
type RequestState<T> =
  | { status: "idle" }
  | { status: "loading" }
  | { status: "success"; data: T }
  | { status: "error"; error: string };

function handleRequest<T>(state: RequestState<T>) {
  switch (state.status) {
    case "idle":
      return "Not started";
    case "loading":
      return "Loading...";
    case "success":
      return `Data: ${state.data}`;
    case "error":
      return `Error: ${state.error}`;
  }
}
```

---

### 8. Custom Type Guards (CRITICAL!)

**What it means:**

- Create your own type checking functions
- Use `value is Type` return type (type predicate)
- Most flexible narrowing mechanism

**Basic syntax:**

```typescript
function isString(value: unknown): value is string {
  return typeof value === "string";
}

function process(value: unknown) {
  if (isString(value)) {
    // value is string
    console.log(value.toUpperCase());
  }
}
```

**Type guard for interface:**

```typescript
interface User {
  name: string;
  email: string;
}

function isUser(value: unknown): value is User {
  return (
    typeof value === "object" &&
    value !== null &&
    "name" in value &&
    "email" in value &&
    typeof (value as User).name === "string" &&
    typeof (value as User).email === "string"
  );
}

function greetUser(data: unknown) {
  if (isUser(data)) {
    console.log(`Hello, ${data.name}!`);
  }
}
```

**Array type guard:**

```typescript
function isStringArray(value: unknown): value is string[] {
  return (
    Array.isArray(value) && value.every((item) => typeof item === "string")
  );
}
```

**Nullable type guard:**

```typescript
function isNotNull<T>(value: T | null): value is T {
  return value !== null;
}

function processUser(user: User | null) {
  if (isNotNull(user)) {
    // user is User
    console.log(user.name);
  }
}
```

---

### 9. Assignment Narrowing

**What it means:**

- TypeScript narrows based on assignments
- Tracks variable type through reassignments

**How it works:**

```typescript
let value: string | number;

value = "hello";
// value is string here
console.log(value.toUpperCase());

value = 42;
// value is number here
console.log(value.toFixed(2));
```

**With let vs const:**

```typescript
let x = "hello"; // Type: string (widened)
const y = "hello"; // Type: "hello" (literal)
```

---

### 10. Control Flow Analysis

**What it means:**

- TypeScript follows code execution paths
- Tracks type narrowing through all branches
- Unreachable code is detected

**How it works:**

```typescript
function process(value: string | number) {
  if (typeof value === "string") {
    return value.length;
  }
  // TypeScript knows value is number here
  return value * 2;
}
```

**With early returns:**

```typescript
function greet(name: string | null) {
  if (!name) {
    return "Hello, guest!";
  }
  // name is definitely string here
  return `Hello, ${name}!`;
}
```

**Exhaustiveness checking:**

```typescript
type Status = "idle" | "loading" | "success";

function handleStatus(status: Status): string {
  if (status === "idle") return "Idle";
  if (status === "loading") return "Loading";
  if (status === "success") return "Success";

  // This ensures all cases handled
  const _exhaustive: never = status;
  return _exhaustive;
}
```

---

## üé§ Top Interview Questions

### Q1: What is type narrowing and why is it important?

**Answer:**

> "Type narrowing is TypeScript's ability to refine a broad type to a more specific type within conditional blocks. It's crucial for working safely with union types - the most common scenario being handling values that could be null, undefined, or different types. TypeScript's control flow analysis tracks which type is possible in each branch, allowing us to access type-specific properties without type assertions. For example, after checking `typeof x === 'string'`, TypeScript knows x is a string in that block and allows string methods."

---

### Q2: Explain discriminated unions and when to use them.

**Answer:**

> "Discriminated unions are union types where each member has a common literal property - called the discriminant. For example, a Result type with Success having `status: 'success'` and Error having `status: 'error'`. This pattern is incredibly powerful because TypeScript can narrow the entire type based on just checking the discriminant property. I use them extensively for state management (idle/loading/success/error states), API responses, and any situation where I need exhaustive type checking. They work perfectly with switch statements and ensure compile-time safety that all cases are handled."

---

### Q3: How do you create a custom type guard?

**Answer:**

> "A custom type guard is a function that returns a type predicate using the `value is Type` syntax. For example: `function isUser(value: unknown): value is User { return typeof value === 'object' && value !== null && 'name' in value && typeof value.name === 'string'; }`. The type predicate tells TypeScript that if the function returns true, the value can be treated as that type in the calling code. This is essential when TypeScript's built-in narrowing isn't enough, like validating complex objects, checking array contents, or working with unknown types from external APIs."

---

### Q4: What's the difference between typeof and instanceof?

**Answer:**

> "`typeof` is a JavaScript operator that works with primitive types - returning strings like 'string', 'number', 'boolean', 'function'. It's great for narrowing primitives but limited for objects (returns 'object' for everything including arrays and null). `instanceof` checks if an object is an instance of a class or constructor function - it walks the prototype chain. Use `typeof` for primitives and `instanceof` for class instances. For plain objects with interfaces, neither works directly - that's where the `in` operator or custom type guards come in."

---

### Q5: How does the 'in' operator help with type narrowing?

**Answer:**

> "The `in` operator checks if a property exists in an object, and TypeScript uses this for narrowing. It's particularly useful for discriminating between object types that don't have a discriminant property. For example, `if ('swim' in animal)` narrows `Fish | Bird` to just `Fish`. It's safer than accessing properties directly because it checks existence first. I use it when different types have different properties, when working with optional properties, or when I can't use discriminated unions. It's especially valuable with third-party types where I can't add discriminants."

---

## üîë Must Know Checklist

### ‚úÖ Critical (Always asked)

- ‚úÖ typeof type guards
- ‚úÖ Discriminated unions pattern
- ‚úÖ Custom type guards (value is Type)
- ‚úÖ Truthiness narrowing
- ‚úÖ in operator narrowing

### ‚úÖ Should Know (Often asked)

- ‚úÖ instanceof type guards
- ‚úÖ Equality narrowing
- ‚úÖ Control flow analysis
- ‚úÖ Assignment narrowing

### ‚úÖ Nice to Know (Senior level)

- [ ] Exhaustiveness checking
- [ ] Never type in narrowing
- [ ] Complex union narrowing

---

## üö® Common Mistakes

### 1. Forgetting null in typeof check

```typescript
// ‚ùå typeof null === "object"
function bad(value: string | null) {
  if (typeof value === "object") {
    // null enters this branch!
  }
}

// ‚úÖ Explicit null check
function good(value: string | null) {
  if (value === null) {
    return;
  }
  // value is string
  console.log(value.toUpperCase());
}
```

### 2. Using truthiness with numbers

```typescript
// ‚ùå Excludes 0
function bad(count: number | undefined) {
  if (count) {
    // 0 is falsy!
  }
}

// ‚úÖ Explicit undefined check
function good(count: number | undefined) {
  if (count !== undefined) {
    // 0 is included
  }
}
```

### 3. Not using type predicates

```typescript
// ‚ùå Return boolean
function bad(value: unknown): boolean {
  return typeof value === "string";
}

// TypeScript doesn't narrow after this

// ‚úÖ Use type predicate
function good(value: unknown): value is string {
  return typeof value === "string";
}

// Now TypeScript narrows!
```

### 4. Missing discriminant

```typescript
// ‚ùå No way to narrow
type Bad = { data: string } | { error: string };

// ‚úÖ Add discriminant
type Good =
  | { type: "success"; data: string }
  | { type: "error"; error: string };
```
