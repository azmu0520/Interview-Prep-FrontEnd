# Conditional Types - Deep Dive

## üéØ Key Concepts

### 1. Conditional Type Syntax (CRITICAL!)

**What it means:**

- Types that choose between two types based on a condition
- Syntax: `T extends U ? X : Y`
- Like a ternary operator but for types
- The foundation for many advanced TypeScript patterns

**Basic syntax:**

```typescript
type IsString<T> = T extends string ? true : false;

type A = IsString<string>; // true
type B = IsString<number>; // false
type C = IsString<"hello">; // true (string literal extends string)
```

**How it works:**

- `T extends U` checks if T is assignable to U
- If yes, resolves to X (true branch)
- If no, resolves to Y (false branch)
- The condition is checked at compile time

**Real-world example:**

```typescript
type MessageType<T> = T extends Error
  ? "error"
  : T extends string
  ? "text"
  : "data";

type A = MessageType<Error>; // "error"
type B = MessageType<string>; // "text"
type C = MessageType<number>; // "data"
```

**Why conditional types are powerful:**

- ‚úÖ Create types that adapt based on input
- ‚úÖ Build sophisticated type transformations
- ‚úÖ Enable type-level programming
- ‚úÖ Foundation for utility types (Exclude, Extract, etc.)
- ‚úÖ Make libraries more flexible and type-safe

**Interview Gold:** "Conditional types use `T extends U ? X : Y` syntax to create types that change based on conditions. They're like ternary operators but at the type level. They're essential for advanced TypeScript because they enable type-level logic, power many utility types, and allow creating flexible, adaptive APIs."

---

### 2. Extends Keyword in Conditional Types

**What it means:**

- `extends` checks if one type is assignable to another
- NOT the same as class inheritance!
- Think "is assignable to" or "is compatible with"

**Type compatibility:**

```typescript
// Primitive types
type A = string extends any ? true : false; // true
type B = string extends string | number ? true : false; // true
type C = "hello" extends string ? true : false; // true
type D = string extends "hello" ? true : false; // false

// Object types
type E = { a: string } extends { a: string; b: number } ? true : false; // false
type F = { a: string; b: number } extends { a: string } ? true : false; // true
```

**Understanding assignability:**

```typescript
// More specific extends more general ‚úÖ
type Cat = { meow: () => void };
type Animal = {};

type IsCatAnimal = Cat extends Animal ? true : false; // true
type IsAnimalCat = Animal extends Cat ? true : false; // false

// Union types
type G = "a" extends "a" | "b" ? true : false; // true
type H = "a" | "b" extends "a" ? true : false; // false

// Never
type I = never extends string ? true : false; // true (never extends everything)
type J = string extends never ? true : false; // false
```

**Common patterns:**

```typescript
// Check if type is array
type IsArray<T> = T extends any[] ? true : false;

// Check if type is function
type IsFunction<T> = T extends (...args: any[]) => any ? true : false;

// Check if type is object
type IsObject<T> = T extends object ? true : false;

// Check if type is promise
type IsPromise<T> = T extends Promise<any> ? true : false;
```

---

### 3. Distributive Conditional Types (CRITICAL!)

**What it means:**

- When checking a **naked type parameter** against a union, the conditional distributes
- Applied to each member of the union separately
- Then results are unioned together
- One of TypeScript's most powerful features

**Distributive behavior:**

```typescript
type ToArray<T> = T extends any ? T[] : never;

type A = ToArray<string | number>;
// Distributes:
// (string extends any ? string[] : never) | (number extends any ? number[] : never)
// Result: string[] | number[]

// NOT: (string | number)[]
```

**Naked vs Non-naked:**

```typescript
// Naked type parameter (distributes)
type Naked<T> = T extends string ? "yes" : "no";
type A = Naked<string | number>; // "yes" | "no"

// Non-naked (wrapped in array - doesn't distribute)
type NotNaked<T> = [T] extends [string] ? "yes" : "no";
type B = NotNaked<string | number>; // "no"
```

**Why this matters:**

```typescript
// Exclude utility type (distributive)
type Exclude<T, U> = T extends U ? never : T;

type Result = Exclude<"a" | "b" | "c", "a">;
// Distributes:
// ("a" extends "a" ? never : "a") |
// ("b" extends "a" ? never : "b") |
// ("c" extends "a" ? never : "c")
// Result: "b" | "c"
```

**Preventing distribution:**

```typescript
// Use tuple wrapper to prevent distribution
type NoDistribute<T, U> = [T] extends [U] ? true : false;

type A = NoDistribute<string | number, string>; // false
// Without wrapper:
type B = string | number extends string ? true : false; // false (same, but different for naked params)

// Practical: Check if union is exactly a type
type IsExactly<T, U> = [T] extends [U]
  ? [U] extends [T]
    ? true
    : false
  : false;
```

**Real-world example:**

```typescript
// Convert union to intersection (advanced)
type UnionToIntersection<U> = (U extends any ? (x: U) => void : never) extends (
  x: infer I
) => void
  ? I
  : never;

type A = UnionToIntersection<{ a: string } | { b: number }>;
// Result: { a: string } & { b: number }
```

---

### 4. Type Inference with infer (CRITICAL!)

**What it means:**

- `infer` keyword extracts types from within conditional types
- Creates a type variable that TypeScript infers
- Only valid in the true branch of conditional types
- Essential for extracting generic types

**Basic infer patterns:**

```typescript
// Extract return type
type ReturnType<T> = T extends (...args: any[]) => infer R ? R : never;

type A = ReturnType<() => string>; // string
type B = ReturnType<() => number>; // number
type C = ReturnType<(x: number) => void>; // void

// Extract parameter types
type Parameters<T> = T extends (...args: infer P) => any ? P : never;

type D = Parameters<(a: string, b: number) => void>; // [string, number]

// Extract array element type
type ElementType<T> = T extends (infer E)[] ? E : never;

type E = ElementType<string[]>; // string
type F = ElementType<number[]>; // number
```

**Multiple infer:**

```typescript
// Extract first parameter
type FirstParam<T> = T extends (first: infer F, ...args: any[]) => any
  ? F
  : never;

type A = FirstParam<(a: string, b: number) => void>; // string

// Extract promise value
type Awaited<T> = T extends Promise<infer U> ? U : T;

type B = Awaited<Promise<string>>; // string
type C = Awaited<number>; // number
```

**Nested infer:**

```typescript
// Deep awaited (recursive)
type DeepAwaited<T> = T extends Promise<infer U> ? DeepAwaited<U> : T;

type A = DeepAwaited<Promise<Promise<string>>>; // string
type B = DeepAwaited<Promise<number>>; // number

// Extract nested property type
type PropType<T, K extends keyof T> = T[K] extends infer P ? P : never;
```

**Practical examples:**

```typescript
// Get constructor parameters
type ConstructorParams<T> = T extends new (...args: infer P) => any ? P : never;

class User {
  constructor(name: string, age: number) {}
}

type UserParams = ConstructorParams<typeof User>; // [string, number]

// Extract function this type
type ThisType<T> = T extends (this: infer U, ...args: any[]) => any
  ? U
  : unknown;
```

**Common pattern - flatten array:**

```typescript
type Flatten<T> = T extends Array<infer U> ? U : T;

type A = Flatten<string[]>; // string
type B = Flatten<number>; // number
type C = Flatten<[1, 2, 3]>; // 1 | 2 | 3 (tuple to union)
```

---

### 5. Nested Conditional Types

**What it means:**

- Conditional types can be nested like nested ternary operators
- Used for complex type logic
- Can become hard to read (use carefully!)

**Basic nesting:**

```typescript
type TypeName<T> = T extends string
  ? "string"
  : T extends number
  ? "number"
  : T extends boolean
  ? "boolean"
  : T extends undefined
  ? "undefined"
  : T extends Function
  ? "function"
  : "object";

type A = TypeName<string>; // "string"
type B = TypeName<42>; // "number"
type C = TypeName<() => void>; // "function"
```

**Complex nesting:**

```typescript
type DeepReadonly<T> = T extends any[]
  ? ReadonlyArray<DeepReadonly<T[number]>>
  : T extends object
  ? { readonly [K in keyof T]: DeepReadonly<T[K]> }
  : T;

interface Nested {
  a: {
    b: {
      c: string;
    };
  };
  arr: number[];
}

type R = DeepReadonly<Nested>;
// All properties deeply readonly
```

**Multiple conditions:**

```typescript
type Unpacked<T> = T extends (infer U)[]
  ? U
  : T extends (...args: any[]) => infer U
  ? U
  : T extends Promise<infer U>
  ? U
  : T;

type A = Unpacked<string[]>; // string
type B = Unpacked<() => number>; // number
type C = Unpacked<Promise<boolean>>; // boolean
type D = Unpacked<string>; // string
```

**Best practices:**

```typescript
// ‚ùå Too nested - hard to read
type Bad<T> = T extends A
  ? X
  : T extends B
  ? Y
  : T extends C
  ? Z
  : T extends D
  ? W
  : T extends E
  ? V
  : Never;

// ‚úÖ Better - use helper types
type IsA<T> = T extends A ? true : false;
type IsB<T> = T extends B ? true : false;

type Good<T> = IsA<T> extends true ? X : IsB<T> extends true ? Y : Never;
```

---

### 6. Built-in Conditional Utility Types

**What it means:**

- TypeScript includes many utility types built with conditionals
- Understanding their implementation helps master conditionals
- Can create custom versions

**Exclude (removes types from union):**

```typescript
// Implementation
type Exclude<T, U> = T extends U ? never : T;

// Usage
type A = Exclude<"a" | "b" | "c", "a">; // "b" | "c"
type B = Exclude<string | number, number>; // string
type C = Exclude<string | number | boolean, string | boolean>; // number
```

**Extract (keeps only matching types):**

```typescript
// Implementation
type Extract<T, U> = T extends U ? T : never;

// Usage
type A = Extract<"a" | "b" | "c", "a" | "f">; // "a"
type B = Extract<string | number, number>; // number
```

**NonNullable (removes null and undefined):**

```typescript
// Implementation
type NonNullable<T> = T extends null | undefined ? never : T;

// Usage
type A = NonNullable<string | null | undefined>; // string
type B = NonNullable<number | null>; // number
```

**ReturnType (extracts function return type):**

```typescript
// Implementation
type ReturnType<T> = T extends (...args: any[]) => infer R ? R : any;

// Usage
type A = ReturnType<() => string>; // string
type B = ReturnType<(x: number) => number>; // number
```

**Parameters (extracts function parameters):**

```typescript
// Implementation
type Parameters<T> = T extends (...args: infer P) => any ? P : never;

// Usage
type A = Parameters<(a: string, b: number) => void>; // [string, number]
```

**Awaited (unwraps Promise type):**

```typescript
// Implementation (simplified)
type Awaited<T> = T extends Promise<infer U> ? Awaited<U> : T;

// Usage
type A = Awaited<Promise<string>>; // string
type B = Awaited<Promise<Promise<number>>>; // number
```

---

### 7. Practical Conditional Type Patterns

**Pattern 1: Nullable to Non-nullable:**

```typescript
type NoNull<T> = T extends null | undefined ? never : T;

type A = NoNull<string | null>; // string
type B = NoNull<number | undefined>; // number
```

**Pattern 2: Function overload resolution:**

```typescript
type OverloadedReturnType<T> = T extends {
  (...args: any[]): infer R;
  (...args: any[]): any;
}
  ? R
  : T extends (...args: any[]) => infer R
  ? R
  : never;
```

**Pattern 3: Tuple to union:**

```typescript
type TupleToUnion<T> = T extends (infer U)[] ? U : never;

type A = TupleToUnion<[string, number, boolean]>; // string | number | boolean
```

**Pattern 4: Required keys:**

```typescript
type RequiredKeys<T> = {
  [K in keyof T]-?: {} extends Pick<T, K> ? never : K;
}[keyof T];

interface User {
  id: number;
  name: string;
  email?: string;
}

type R = RequiredKeys<User>; // "id" | "name"
```

**Pattern 5: Readonly keys:**

```typescript
type ReadonlyKeys<T> = {
  [K in keyof T]-?: (<G>() => G extends { [P in K]: T[K] } ? 1 : 2) extends <
    G
  >() => G extends { -readonly [P in K]: T[K] } ? 1 : 2
    ? never
    : K;
}[keyof T];
```

---

### 8. Advanced Conditional Patterns

**Pattern 1: IsAny type:**

```typescript
type IsAny<T> = 0 extends 1 & T ? true : false;

type A = IsAny<any>; // true
type B = IsAny<string>; // false
type C = IsAny<unknown>; // false
```

**Pattern 2: IsNever type:**

```typescript
type IsNever<T> = [T] extends [never] ? true : false;

type A = IsNever<never>; // true
type B = IsNever<any>; // false
```

**Pattern 3: IsUnion type:**

```typescript
type IsUnion<T> = [T] extends [UnionToIntersection<T>] ? false : true;
```

**Pattern 4: Exact type matching:**

```typescript
type Equals<X, Y> = (<T>() => T extends X ? 1 : 2) extends <T>() => T extends Y
  ? 1
  : 2
  ? true
  : false;

type A = Equals<string, string>; // true
type B = Equals<string, number>; // false
type C = Equals<string, string | number>; // false
```

---

## üé§ Top Interview Questions & Model Answers

### Q1: How do conditional types work and what is their syntax?

**Answer:**

> "Conditional types use the syntax `T extends U ? X : Y` - like a ternary operator for types. They check if type T is assignable to type U. If yes, the type resolves to X; if no, to Y. For example, `type IsString<T> = T extends string ? true : false` creates a type that becomes true for strings and false otherwise. Conditional types are powerful because they enable type-level logic and are the foundation for many utility types like Exclude, Extract, and ReturnType."

---

### Q2: What are distributive conditional types?

**Answer:**

> "Distributive conditional types automatically distribute over union types. When you have a naked type parameter (not wrapped in array or tuple) in a conditional, TypeScript applies the condition to each member of a union separately, then unions the results. For example, `type ToArray<T> = T extends any ? T[] : never` with `ToArray<string | number>` gives `string[] | number[]`, not `(string | number)[]`. This behavior powers utility types like Exclude and Extract. You can prevent distribution by wrapping the type parameter in a tuple: `[T] extends [U]`."

---

### Q3: How does the infer keyword work?

**Answer:**

> "The `infer` keyword lets you extract types from within conditional types. It creates a type variable that TypeScript infers based on the structure you're matching. It only works in the true branch of a conditional. For example, `type ReturnType<T> = T extends (...args: any[]) => infer R ? R : never` extracts the return type R from a function. You can use multiple infer keywords in one conditional, and they can be nested. It's essential for building type utilities that need to extract generic types from complex structures like functions, promises, or arrays."

---

### Q4: When would you prevent distributive behavior in conditional types?

**Answer:**

> "I prevent distribution when I want to check the entire union type as a whole, not each member individually. I do this by wrapping the type parameter in a tuple: `[T] extends [U]`. For example, checking if a type is exactly a union: `type IsUnion<T> = [T] extends [UnionToIntersection<T>] ? false : true`. Another case is when comparing types for exact equality - you need to prevent distribution to compare the full types, not distribute and compare members. Without the tuple wrapper, `string | number` would be checked as `string` then `number`, giving wrong results."

---

### Q5: How would you implement your own ReturnType utility?

**Answer:**

> "I'd use a conditional type with infer to extract the return type: `type MyReturnType<T> = T extends (...args: any[]) => infer R ? R : any`. This checks if T is a function type, uses infer to capture the return type as R, and returns R if it matches. If T isn't a function, it returns any. The `...args: any[]` matches any parameters, and `infer R` captures whatever the return type is. This pattern extends to other utilities - Parameters uses `infer P` on the args, ConstructorParameters uses `new (...args: infer P)`, and so on."

---

## üîë Must Know Checklist

### ‚úÖ Critical (Always asked)

- ‚úÖ Conditional type syntax (T extends U ? X : Y)
- ‚úÖ Distributive conditional types
- ‚úÖ infer keyword usage
- ‚úÖ Built-in utility types (Exclude, Extract, etc.)

### ‚úÖ Should Know (Often asked)

- ‚úÖ Preventing distribution with tuples
- ‚úÖ Nested conditional types
- ‚úÖ Multiple infer usage
- ‚úÖ Custom utility type creation

### ‚úÖ Nice to Know (Senior level)

- [ ] IsAny and IsNever patterns
- [ ] Exact type equality checking
- [ ] Union to intersection conversion
- [ ] Advanced infer patterns

---

## üö® Common Mistakes to Avoid

### 1. Confusing extends with inheritance

```typescript
// ‚ùå Not inheritance!
type Check = string extends object ? true : false;

// ‚úÖ It's assignability check
type Check = "hello" extends string ? true : false; // true
```

### 2. Forgetting distribution behavior

```typescript
// May not get expected result
type ToArray<T> = T extends any ? T[] : never;
type A = ToArray<string | number>; // string[] | number[] (distributed!)

// Prevent distribution if needed
type ToArray<T> = [T] extends [any] ? T[] : never;
type B = ToArray<string | number>; // (string | number)[]
```

### 3. Using infer outside conditional

```typescript
// ‚ùå infer only in conditional true branch
type Bad<T> = infer R; // Error!

// ‚úÖ Must be in conditional
type Good<T> = T extends (infer R)[] ? R : never;
```

### 4. Over-nesting conditionals

```typescript
// ‚ùå Hard to read
type Bad<T> =
  T extends A ? X :
  T extends B ? Y :
  T extends C ? Z :
  T extends D ? W :
  Never;

// ‚úÖ Use helper types
type IsA<T> = T extends A ? true : false;
type Good<T> = IsA<T> extends true ? X : ...;
```
