# Utility Types - Deep Dive

## üéØ Overview

Utility types are built-in TypeScript types that transform existing types. They're implemented using mapped types, conditional types, and other advanced features. **Knowing these is CRITICAL for interviews.**

---

## 1. Partial<T> (CRITICAL!)

**Makes all properties optional**

```typescript
type Partial<T> = {
  [P in keyof T]?: T[P];
};
```

**Use cases:**

- Update functions (don't need all fields)
- Configuration objects with defaults
- Partial form data

**Examples:**

```typescript
interface User {
  name: string;
  email: string;
  age: number;
}

type PartialUser = Partial<User>;
// { name?: string; email?: string; age?: number; }

function updateUser(user: User, updates: Partial<User>): User {
  return { ...user, ...updates };
}

const user: User = { name: "Alice", email: "alice@example.com", age: 30 };
const updated = updateUser(user, { age: 31 }); // Only age provided!
```

**Interview Answer:**
"Partial<T> makes all properties optional by adding `?` modifier. It's perfect for update operations where you don't need to provide all fields - like PATCH requests or React setState. Implementation uses mapped types with optional modifier."

---

## 2. Required<T> (CRITICAL!)

**Makes all properties required (removes optional)**

```typescript
type Required<T> = {
  [P in keyof T]-?: T[P];
};
```

**Use cases:**

- Ensure complete objects before saving
- Convert config with defaults to required
- Validation schemas

**Examples:**

```typescript
interface Config {
  host?: string;
  port?: number;
  ssl?: boolean;
}

type RequiredConfig = Required<Config>;
// { host: string; port: number; ssl: boolean; }

function validateConfig(config: Required<Config>) {
  // All properties guaranteed to exist
  console.log(config.host, config.port, config.ssl);
}
```

**Interview Answer:**
"Required<T> removes optional modifiers using `-?` in mapped type. It's the opposite of Partial. Use it when you need to ensure all properties exist, like validating complete data before database operations."

---

## 3. Readonly<T> (CRITICAL!)

**Makes all properties readonly**

```typescript
type Readonly<T> = {
  readonly [P in keyof T]: T[P];
};
```

**Use cases:**

- Immutable data structures
- Configuration objects
- Prevent accidental mutations

**Examples:**

```typescript
interface Point {
  x: number;
  y: number;
}

type ReadonlyPoint = Readonly<Point>;

const point: ReadonlyPoint = { x: 10, y: 20 };
// point.x = 15; // ‚ùå Error: readonly

function freezeUser(user: User): Readonly<User> {
  return Object.freeze(user);
}
```

**Interview Answer:**
"Readonly<T> adds readonly modifier to all properties, preventing reassignment. It's shallow - nested objects aren't readonly. For deep immutability, you'd need recursive implementation. Use it to protect against accidental mutations and enforce immutable patterns."

---

## 4. Pick<T, K> (CRITICAL!)

**Selects subset of properties**

```typescript
type Pick<T, K extends keyof T> = {
  [P in K]: T[P];
};
```

**Use cases:**

- Create focused types for specific operations
- API responses (only needed fields)
- Component props from larger types

**Examples:**

```typescript
interface User {
  id: number;
  name: string;
  email: string;
  password: string;
  createdAt: Date;
}

type UserPreview = Pick<User, "id" | "name" | "email">;
// { id: number; name: string; email: string; }

type LoginCredentials = Pick<User, "email" | "password">;
// { email: string; password: string; }

function displayPreview(user: UserPreview) {
  // Only has id, name, email
  console.log(user.name, user.email);
}
```

**Interview Answer:**
"Pick<T, K> extracts specific properties from a type, creating a new type with only those properties. It's like SELECT in SQL - you choose which fields you want. Perfect for creating view models or restricting data exposure."

---

## 5. Omit<T, K> (CRITICAL!)

**Excludes properties**

```typescript
type Omit<T, K extends keyof any> = {
  [P in keyof T as P extends K ? never : P]: T[P];
};
// Alternative: Pick<T, Exclude<keyof T, K>>
```

**Use cases:**

- Remove sensitive fields
- Create types for database operations (omit id)
- Form data (omit computed fields)

**Examples:**

```typescript
interface User {
  id: number;
  name: string;
  email: string;
  password: string;
}

type UserWithoutPassword = Omit<User, "password">;
// { id: number; name: string; email: string; }

type NewUser = Omit<User, "id">;
// For creation - no id yet
```

**Interview Answer:**
"Omit<T, K> is the opposite of Pick - it excludes specified properties. Use it to remove sensitive data, create insert types (omit auto-generated ids), or exclude computed properties. Implementation uses key remapping with `never` to filter out unwanted keys."

---

## 6. Record<K, T> (CRITICAL!)

**Creates object type with specified keys and value type**

```typescript
type Record<K extends keyof any, T> = {
  [P in K]: T;
};
```

**Use cases:**

- Maps and dictionaries
- Lookup tables
- Index signatures with known keys

**Examples:**

```typescript
type PageInfo = Record<
  "home" | "about" | "contact",
  { title: string; url: string }
>;
// {
//   home: { title: string; url: string };
//   about: { title: string; url: string };
//   contact: { title: string; url: string };
// }

type ErrorMessages = Record<number, string>;
const errors: ErrorMessages = {
  404: "Not Found",
  500: "Server Error",
};

type UserRoles = Record<string, boolean>;
const permissions: UserRoles = {
  admin: true,
  editor: true,
  viewer: false,
};
```

**Interview Answer:**
"Record<K, T> creates an object type where keys are K and all values are type T. It's the typed version of an index signature - perfect for maps, lookup tables, and dictionaries. More specific than `{ [key: string]: T }` because you can constrain the keys."

---

## 7. Exclude<T, U>

**Removes types from union**

```typescript
type Exclude<T, U> = T extends U ? never : T;
```

**Use cases:**

- Filter union types
- Remove specific types
- Type algebra

**Examples:**

```typescript
type T0 = Exclude<"a" | "b" | "c", "a">;
// "b" | "c"

type T1 = Exclude<string | number | boolean, string>;
// number | boolean

type T2 = Exclude<string | number, string | boolean>;
// number

type NonNullable<T> = Exclude<T, null | undefined>;
```

**Interview Answer:**
"Exclude<T, U> removes types from a union that are assignable to U. It distributes over unions using conditional types. Think of it as union subtraction - great for filtering out unwanted types from a union."

---

## 8. Extract<T, U>

**Keeps only types that exist in both unions**

```typescript
type Extract<T, U> = T extends U ? T : never;
```

**Use cases:**

- Find common types in unions
- Filter unions
- Type intersection operations

**Examples:**

```typescript
type T0 = Extract<"a" | "b" | "c", "a" | "f">;
// "a"

type T1 = Extract<string | number | boolean, string | boolean>;
// string | boolean

type Primitive = Extract<any, string | number | boolean>;
// string | number | boolean
```

**Interview Answer:**
"Extract<T, U> is the opposite of Exclude - it keeps only types assignable to U. It's like union intersection - finding common types. Use it when you need to filter a union to only include certain types."

---

## 9. NonNullable<T>

**Removes null and undefined**

```typescript
type NonNullable<T> = T extends null | undefined ? never : T;
// Or: Exclude<T, null | undefined>
```

**Use cases:**

- Ensure values aren't null/undefined
- After null checks
- API responses

**Examples:**

```typescript
type T0 = NonNullable<string | number | undefined>;
// string | number

type T1 = NonNullable<string | null | undefined>;
// string

function process(value: string | null) {
  if (value !== null) {
    const safe: NonNullable<typeof value> = value;
    // safe is string
  }
}
```

---

## 10. ReturnType<T> (CRITICAL!)

**Extracts function return type**

```typescript
type ReturnType<T extends (...args: any) => any> = T extends (
  ...args: any
) => infer R
  ? R
  : any;
```

**Use cases:**

- Get return type from functions
- Type derived data
- Generic utilities

**Examples:**

```typescript
function getUser() {
  return { name: "Alice", age: 30 };
}

type User = ReturnType<typeof getUser>;
// { name: string; age: number; }

type T0 = ReturnType<() => string>;
// string

type T1 = ReturnType<(s: string) => void>;
// void

type T2 = ReturnType<<T>() => T>;
// unknown
```

**Interview Answer:**
"ReturnType<T> extracts the return type of a function using `infer` in a conditional type. Super useful when you don't have the type definition but have the function - common with third-party libraries or factory functions."

---

## 11. Parameters<T> (CRITICAL!)

**Extracts function parameter types as tuple**

```typescript
type Parameters<T extends (...args: any) => any> = T extends (
  ...args: infer P
) => any
  ? P
  : never;
```

**Use cases:**

- Extract parameter types
- Type wrappers
- Higher-order functions

**Examples:**

```typescript
function createUser(name: string, age: number, email: string) {
  return { name, age, email };
}

type CreateUserParams = Parameters<typeof createUser>;
// [name: string, age: number, email: string]

function wrapper(...args: Parameters<typeof createUser>) {
  return createUser(...args);
}

type T0 = Parameters<(s: string) => void>;
// [s: string]

type T1 = Parameters<() => void>;
// []
```

**Interview Answer:**
"Parameters<T> extracts function parameters as a tuple using `infer`. Perfect for typing wrapper functions, decorators, or when you need to pass function arguments around. Returns a tuple preserving parameter names and types."

---

## 12. ConstructorParameters<T>

**Extracts constructor parameter types**

```typescript
type ConstructorParameters<T extends abstract new (...args: any) => any> =
  T extends abstract new (...args: infer P) => any ? P : never;
```

**Examples:**

```typescript
class User {
  constructor(public name: string, public age: number) {}
}

type UserParams = ConstructorParameters<typeof User>;
// [name: string, age: number]

function createUser(...args: ConstructorParameters<typeof User>) {
  return new User(...args);
}
```

---

## 13. InstanceType<T>

**Extracts instance type from constructor**

```typescript
type InstanceType<T extends abstract new (...args: any) => any> =
  T extends abstract new (...args: any) => infer R ? R : any;
```

**Examples:**

```typescript
class User {
  name: string;
  constructor(name: string) {
    this.name = name;
  }
}

type UserInstance = InstanceType<typeof User>;
// User

function createUser(): InstanceType<typeof User> {
  return new User("Alice");
}
```

---

## 14. Awaited<T> (TypeScript 4.5+)

**Unwraps Promise type recursively**

```typescript
type Awaited<T> = T extends null | undefined
  ? T
  : T extends object & { then(onfulfilled: infer F): any }
  ? F extends (value: infer V, ...args: any) => any
    ? Awaited<V>
    : never
  : T;
```

**Examples:**

```typescript
type T0 = Awaited<Promise<string>>;
// string

type T1 = Awaited<Promise<Promise<number>>>;
// number (recursive!)

type T2 = Awaited<boolean | Promise<number>>;
// boolean | number

async function fetchUser(): Promise<User> {
  // ...
}

type FetchedUser = Awaited<ReturnType<typeof fetchUser>>;
// User
```

**Interview Answer:**
"Awaited<T> unwraps Promise types recursively - even nested Promises. Added in TS 4.5 to properly type async/await. Before this, you'd manually unwrap with conditional types. Essential for typing async functions correctly."

---

## 15. Combining Utility Types

**Real-world patterns:**

```typescript
// Partial update with some required fields
type UpdateUser = Partial<User> & Pick<User, "id">;

// Readonly input, mutable output
function process(input: Readonly<Config>): Required<Config> {
  // ...
}

// Omit sensitive fields, make rest partial
type UserUpdate = Partial<Omit<User, "id" | "password">>;

// Pick fields and make readonly
type UserDisplay = Readonly<Pick<User, "name" | "email">>;

// Record with non-nullable values
type StrictRecord<K extends string, T> = Record<K, NonNullable<T>>;
```

---

## üé§ Top Interview Questions

### Q1: Explain the difference between Pick and Omit. When would you use each?

**Answer:**

> "Pick<T, K> selects specific properties to include - you explicitly list what you want. Omit<T, K> excludes specific properties - you list what you don't want, keeping everything else. Use Pick when you need a small subset (like 2-3 properties from 20), and Omit when you need most properties except a few. Pick is like SQL SELECT, Omit is like SELECT \* EXCEPT. For example, Pick<User, 'name' | 'email'> for user preview, or Omit<User, 'password'> to remove sensitive data."

### Q2: How would you implement a DeepReadonly type?

**Answer:**

> "I'd use recursive mapped types with conditional types: `type DeepReadonly<T> = { readonly [P in keyof T]: T[P] extends object ? DeepReadonly<T[P]> : T[P] }`. This makes the current level readonly, then checks if each property is an object - if yes, recursively applies DeepReadonly. Need to handle arrays specially with ReadonlyArray. Built-in Readonly is shallow - only makes first level readonly."

### Q3: What's the difference between Exclude and Extract?

**Answer:**

> "Both work on union types but opposite operations. Exclude<T, U> removes types from T that are assignable to U - like subtraction. Extract<T, U> keeps only types in T that are assignable to U - like intersection. For example, `Exclude<'a' | 'b' | 'c', 'a'>` gives `'b' | 'c'`, while `Extract<'a' | 'b', 'a' | 'c'>` gives `'a'`. Think Exclude as filter out, Extract as filter keep."

### Q4: How does ReturnType work internally?

**Answer:**

> "ReturnType uses conditional types with `infer` keyword: `T extends (...args: any) => infer R ? R : any`. It checks if T is a function, and if so, infers the return type R. The infer keyword is like a type variable in the conditional that TypeScript solves. You use it with `typeof` for actual functions: `ReturnType<typeof myFunction>`. This pattern is how many utility types extract information from complex types."

### Q5: When would you use Record vs an index signature?

**Answer:**

> "Record<K, T> is more specific than index signatures. Use Record when you know the keys - like `Record<'home' | 'about', PageInfo>` creates specific properties. Use index signature `{ [key: string]: T }` when keys are dynamic or unlimited. Record provides better autocomplete and type checking. Record also works with number and symbol keys: `Record<number, string>`. Record is essentially a mapped type over a union of keys."

---

## üîë Must Know Checklist

### ‚úÖ Critical (Always asked)

- ‚úÖ Partial<T>
- ‚úÖ Required<T>
- ‚úÖ Readonly<T>
- ‚úÖ Pick<T, K>
- ‚úÖ Omit<T, K>
- ‚úÖ Record<K, T>
- ‚úÖ ReturnType<T>
- ‚úÖ Parameters<T>

### ‚úÖ Should Know

- ‚úÖ Exclude<T, U>
- ‚úÖ Extract<T, U>
- ‚úÖ NonNullable<T>
- ‚úÖ Awaited<T>

### ‚úÖ Nice to Know

- [ ] ConstructorParameters<T>
- [ ] InstanceType<T>
- [ ] ThisParameterType<T>
- [ ] OmitThisParameter<T>

---

## üö® Common Mistakes

### 1. Confusing Pick and Omit

```typescript
// ‚ùå Backwards
type Bad = Omit<User, "name" | "email">; // Keeps everything BUT these

// ‚úÖ Correct
type Good = Pick<User, "name" | "email">; // Only these
```

### 2. Forgetting typeof with ReturnType

```typescript
function getUser() {
  return { name: "Alice" };
}

// ‚ùå Wrong
type Bad = ReturnType<getUser>; // Error

// ‚úÖ Correct
type Good = ReturnType<typeof getUser>;
```

### 3. Not handling nested objects

```typescript
// ‚ùå Shallow
type Bad = Readonly<{ user: { name: string } }>;
// user is readonly, but user.name is mutable!

// ‚úÖ Deep
type Good = DeepReadonly<{ user: { name: string } }>;
```
