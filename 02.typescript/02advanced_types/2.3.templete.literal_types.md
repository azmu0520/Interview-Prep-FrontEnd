# Template Literal Types - Deep Dive

## üéØ Key Concepts

### 1. Template Literal Type Syntax (CRITICAL!)

**What it means:**

- String literal types with embedded type expressions
- Uses template literal syntax: `` `string ${Type} string` ``
- Interpolates types into string patterns
- TypeScript 4.1+ feature

**Basic syntax:**

```typescript
type Greeting = `Hello ${string}`;

const greeting1: Greeting = "Hello World"; // ‚úÖ
const greeting2: Greeting = "Hello TypeScript"; // ‚úÖ
const greeting3: Greeting = "Hi World"; // ‚ùå Must start with "Hello "
```

**With specific types:**

```typescript
type EventName = `on${string}`;
type ID = `user_${number}`;
type CSSProperty = `${string}px` | `${string}%` | `${string}em`;

const event: EventName = "onClick"; // ‚úÖ
const userId: ID = "user_123"; // ‚úÖ
const size: CSSProperty = "16px"; // ‚úÖ
```

**Why they're powerful:**

- ‚úÖ Type-safe string patterns
- ‚úÖ Build complex string types from unions
- ‚úÖ Enforce naming conventions
- ‚úÖ Create type-safe APIs
- ‚úÖ Work with mapped types for key transformation

**Interview Gold:** "Template literal types let you create string patterns at the type level using template literal syntax. They interpolate types into strings, distribute over unions, and combine with mapped types to create sophisticated string-based type systems. They're essential for type-safe string APIs, CSS-in-JS, and enforcing naming conventions."

---

### 2. Type Interpolation

**What it means:**

- Embed type expressions in template literals
- Use `${Type}` syntax
- Types are converted to their string representation

**With literal types:**

```typescript
type World = "World";
type Greeting = `Hello ${World}`; // "Hello World"

type Size = "small" | "medium" | "large";
type ClassName = `btn-${Size}`; // "btn-small" | "btn-medium" | "btn-large"
```

**With number types:**

```typescript
type ID = `id-${number}`;
const id1: ID = "id-123"; // ‚úÖ
const id2: ID = "id-abc"; // ‚ùå abc is not a number

type Version = `v${number}.${number}.${number}`;
const version: Version = "v1.2.3"; // ‚úÖ
```

**With union types:**

```typescript
type Prefix = "get" | "set";
type Suffix = "Name" | "Age";
type Method = `${Prefix}${Suffix}`;
// "getName" | "getAge" | "setName" | "setAge"
```

**Multiple interpolations:**

```typescript
type HttpMethod = "GET" | "POST";
type Endpoint = "users" | "posts";
type APIRoute = `${HttpMethod} /${Endpoint}`;
// "GET /users" | "GET /posts" | "POST /users" | "POST /posts"
```

---

### 3. Distribution Over Unions (CRITICAL!)

**What it means:**

- Template literal types automatically distribute over unions
- Each union member creates a separate string type
- Results are unioned together
- Creates combinatorial expansion

**Basic distribution:**

```typescript
type Size = "small" | "medium" | "large";
type ButtonClass = `btn-${Size}`;
// Distributes to:
// "btn-small" | "btn-medium" | "btn-large"
```

**Multiple unions (Cartesian product):**

```typescript
type Color = "red" | "blue" | "green";
type Size = "sm" | "md" | "lg";

type ClassName = `${Color}-${Size}`;
// Creates 3 √ó 3 = 9 combinations:
// "red-sm" | "red-md" | "red-lg" |
// "blue-sm" | "blue-md" | "blue-lg" |
// "green-sm" | "green-md" | "green-lg"
```

**Three-way distribution:**

```typescript
type Prefix = "get" | "set";
type Property = "name" | "age";
type Suffix = "Sync" | "Async";

type Method = `${Prefix}${Property}${Suffix}`;
// 2 √ó 2 √ó 2 = 8 combinations
// "getNameSync" | "getNameAsync" | "getAgeSync" | ...
```

**Practical example - CSS:**

```typescript
type Size = "sm" | "md" | "lg";
type Variant = "primary" | "secondary" | "danger";
type State = "" | "-hover" | "-active" | "-disabled";

type ButtonClass = `btn-${Variant}-${Size}${State}`;
// Creates all valid button class combinations
```

**Performance consideration:**

```typescript
// ‚ö†Ô∏è Too many combinations can slow compilation
type A = "a" | "b" | "c" | "d" | "e"; // 5 options
type B = "1" | "2" | "3" | "4" | "5"; // 5 options
type C = "x" | "y" | "z"; // 3 options

type Combined = `${A}${B}${C}`; // 5 √ó 5 √ó 3 = 75 combinations ‚úÖ

// But this is too much:
// type Huge = `${A}${B}${C}${A}${B}${C}`; // 5‚Å∂ = 15,625 combinations ‚ö†Ô∏è
```

---

### 4. Intrinsic String Manipulation Types

**What it means:**

- Built-in types for common string transformations
- Uppercase, Lowercase, Capitalize, Uncapitalize
- Work on literal types only

**Uppercase:**

```typescript
type Uppercase<S extends string> = intrinsic; // Built-in

type Loud = Uppercase<"hello">; // "HELLO"
type LoudUnion = Uppercase<"a" | "b">; // "A" | "B"
```

**Lowercase:**

```typescript
type Lowercase<S extends string> = intrinsic;

type Quiet = Lowercase<"HELLO">; // "hello"
type QuietUnion = Lowercase<"A" | "B">; // "a" | "b"
```

**Capitalize:**

```typescript
type Capitalize<S extends string> = intrinsic;

type Title = Capitalize<"hello">; // "Hello"
type Titles = Capitalize<"foo" | "bar">; // "Foo" | "Bar"
```

**Uncapitalize:**

```typescript
type Uncapitalize<S extends string> = intrinsic;

type Lower = Uncapitalize<"Hello">; // "hello"
type Lowers = Uncapitalize<"Foo" | "Bar">; // "foo" | "bar"
```

**Practical combinations:**

```typescript
type EventName<T extends string> = `on${Capitalize<T>}`;
type Events = EventName<"click" | "hover" | "focus">;
// "onClick" | "onHover" | "onFocus"

type ActionType<T extends string> = `SET_${Uppercase<T>}`;
type Actions = ActionType<"user" | "theme">;
// "SET_USER" | "SET_THEME"
```

**Chaining transformations:**

```typescript
type ShoutingEvent<T extends string> = `on${Uppercase<Capitalize<T>>}`;
type ShoutEvents = ShoutingEvent<"click" | "submit">;
// "onCLICK" | "onSUBMIT"
```

---

### 5. Template Literals with Mapped Types (CRITICAL!)

**What it means:**

- Combine template literals with mapped types
- Transform object keys systematically
- Create getters, setters, event handlers, etc.

**Basic key transformation:**

```typescript
type Getters<T> = {
  [K in keyof T as `get${Capitalize<K & string>}`]: () => T[K];
};

interface State {
  name: string;
  age: number;
}

type StateGetters = Getters<State>;
// {
//   getName: () => string;
//   getAge: () => number;
// }
```

**Setters pattern:**

```typescript
type Setters<T> = {
  [K in keyof T as `set${Capitalize<K & string>}`]: (value: T[K]) => void;
};

type StateSetters = Setters<State>;
// {
//   setName: (value: string) => void;
//   setAge: (value: number) => void;
// }
```

**Event handlers:**

```typescript
type EventHandlers<T> = {
  [K in keyof T as `on${Capitalize<K & string>}`]: (data: T[K]) => void;
};

interface Events {
  click: MouseEvent;
  submit: FormEvent;
}

type Handlers = EventHandlers<Events>;
// {
//   onClick: (data: MouseEvent) => void;
//   onSubmit: (data: FormEvent) => void;
// }
```

**Action creators:**

```typescript
type ActionCreators<T> = {
  [K in keyof T as `set${Capitalize<K & string>}`]: (payload: T[K]) => {
    type: `SET_${Uppercase<K & string>}`;
    payload: T[K];
  };
};

interface AppState {
  user: User;
  theme: string;
}

type Actions = ActionCreators<AppState>;
// {
//   setUser: (payload: User) => { type: "SET_USER"; payload: User };
//   setTheme: (payload: string) => { type: "SET_THEME"; payload: string };
// }
```

**API endpoints:**

```typescript
type Endpoints<T> = {
  [K in keyof T as `/${K & string}`]: {
    get: () => Promise<T[K]>;
    post: (data: T[K]) => Promise<T[K]>;
  };
};
```

---

### 6. Pattern Matching with Template Literals

**What it means:**

- Use template literals in conditional types
- Extract parts of string types
- Pattern matching with infer

**Basic pattern matching:**

```typescript
type ExtractRouteParams<T extends string> =
  T extends `${string}:${infer Param}/${infer Rest}`
    ? Param | ExtractRouteParams<`/${Rest}`>
    : T extends `${string}:${infer Param}`
    ? Param
    : never;

type Params = ExtractRouteParams<"/users/:userId/posts/:postId">;
// "userId" | "postId"
```

**Extract prefix:**

```typescript
type RemovePrefix<
  S extends string,
  Prefix extends string
> = S extends `${Prefix}${infer Rest}` ? Rest : S;

type WithoutOn = RemovePrefix<"onClick", "on">; // "Click"
type NoPrefix = RemovePrefix<"click", "on">; // "click"
```

**Extract suffix:**

```typescript
type RemoveSuffix<
  S extends string,
  Suffix extends string
> = S extends `${infer Rest}${Suffix}` ? Rest : S;

type WithoutAsync = RemoveSuffix<"getUserAsync", "Async">; // "getUser"
```

**Split string:**

```typescript
type Split<
  S extends string,
  D extends string
> = S extends `${infer T}${D}${infer U}` ? [T, ...Split<U, D>] : [S];

type Parts = Split<"a-b-c", "-">; // ["a", "b", "c"]
```

**Parse version:**

```typescript
type ParseVersion<V extends string> =
  V extends `v${infer Major}.${infer Minor}.${infer Patch}`
    ? { major: Major; minor: Minor; patch: Patch }
    : never;

type Version = ParseVersion<"v1.2.3">;
// { major: "1"; minor: "2"; patch: "3" }
```

---

### 7. Real-World Use Cases

**Use Case 1: CSS-in-JS type safety:**

```typescript
type CSSUnit = "px" | "em" | "rem" | "%" | "vh" | "vw";
type CSSValue = `${number}${CSSUnit}` | "auto" | "inherit";

interface CSSProperties {
  width: CSSValue;
  height: CSSValue;
  margin: CSSValue;
}

const styles: CSSProperties = {
  width: "100px",
  height: "50%",
  margin: "1rem",
};
```

**Use Case 2: Route typing:**

```typescript
type Route =
  | "/home"
  | "/users/:userId"
  | "/users/:userId/posts/:postId"
  | "/settings";

type RouteParams<T extends string> =
  T extends `${string}:${infer Param}/${infer Rest}`
    ? { [K in Param]: string } & RouteParams<Rest>
    : T extends `${string}:${infer Param}`
    ? { [K in Param]: string }
    : {};

type UserPostParams = RouteParams<"/users/:userId/posts/:postId">;
// { userId: string; postId: string }
```

**Use Case 3: SQL query builder:**

```typescript
type Table = "users" | "posts" | "comments";
type Action = "SELECT" | "INSERT" | "UPDATE" | "DELETE";

type Query = `${Action} FROM ${Table}`;
// "SELECT FROM users" | "INSERT FROM users" | ...
```

**Use Case 4: Event system:**

```typescript
type DOMEvent = "click" | "input" | "submit" | "focus";
type CustomEvent = "dataLoaded" | "userLoggedIn";

type EventName = `on${Capitalize<DOMEvent | CustomEvent>}`;
// "onClick" | "onInput" | "onDataLoaded" | ...
```

**Use Case 5: API versioning:**

```typescript
type Version = "v1" | "v2" | "v3";
type Endpoint = "users" | "posts" | "comments";

type VersionedAPI = `/${Version}/${Endpoint}`;
// "/v1/users" | "/v1/posts" | "/v2/users" | ...
```

---

### 8. Advanced Patterns and Techniques

**Pattern 1: Recursive string manipulation:**

```typescript
type Join<T extends string[], D extends string> = T extends [
  infer F extends string,
  ...infer R extends string[]
]
  ? R extends []
    ? F
    : `${F}${D}${Join<R, D>}`
  : "";

type Path = Join<["users", "123", "posts"], "/">;
// "users/123/posts"
```

**Pattern 2: Type-safe object path:**

```typescript
type PathImpl<T, Key extends keyof T> = Key extends string
  ? T[Key] extends Record<string, any>
    ? `${Key}.${PathImpl<T[Key], keyof T[Key]> & string}` | `${Key}`
    : `${Key}`
  : never;

type Path<T> = PathImpl<T, keyof T>;

interface User {
  profile: {
    name: string;
    address: {
      city: string;
    };
  };
}

type UserPath = Path<User>;
// "profile" | "profile.name" | "profile.address" | "profile.address.city"
```

**Pattern 3: Type-safe i18n keys:**

```typescript
type Translations = {
  common: {
    save: string;
    cancel: string;
  };
  errors: {
    required: string;
    invalid: string;
  };
};

type TranslationKey = Path<Translations>;
// "common" | "common.save" | "common.cancel" | "errors" | ...
```

**Pattern 4: CSS class builder:**

```typescript
type Modifier = "hover" | "active" | "disabled";
type BaseClass = "button" | "input" | "card";

type ClassWithModifier = `${BaseClass}--${Modifier}`;
// "button--hover" | "button--active" | "input--hover" | ...

type BEMClass = `${BaseClass}__${string}` | ClassWithModifier;
```

---

## üé§ Top Interview Questions & Model Answers

### Q1: What are template literal types and how do they work?

**Answer:**

> "Template literal types let you create string patterns at the type level using template literal syntax. You write them as `` `string ${Type} string` `` where Type can be any literal type. They automatically distribute over unions, so `\`btn-${Size}\`` where Size is 'sm' | 'md' creates 'btn-sm' | 'btn-md'. They're powerful for enforcing naming conventions, creating type-safe APIs, and building sophisticated string-based type systems. Combined with mapped types, you can transform object keys - like converting properties to getters: `\`get${Capitalize<Key>}\``."

---

### Q2: How do template literal types distribute over unions?

**Answer:**

> "Template literal types automatically perform a Cartesian product over union types. If you have `\`${A}-${B}\`` where A is 'x' | 'y' and B is '1' | '2', TypeScript creates all 4 combinations: 'x-1', 'x-2', 'y-1', 'y-2'. This distribution happens automatically and creates the union of all possible string combinations. It's powerful but can cause performance issues with too many unions - 5 unions with 5 options each creates 3,125 combinations. The distribution is what makes template literals so useful for generating all variants of class names, API routes, or event names."

---

### Q3: What are the built-in string manipulation types?

**Answer:**

> "TypeScript provides four intrinsic string manipulation types: Uppercase, Lowercase, Capitalize, and Uncapitalize. They only work on string literal types, not runtime strings. For example, `Uppercase<'hello'>` gives 'HELLO', and `Capitalize<'hello'>` gives 'Hello'. They distribute over unions, so `Capitalize<'a' | 'b'>` gives 'A' | 'B'. I use them constantly with mapped types - like `\`get${Capitalize<KeyName>}\`` to create getter methods, or `\`SET_${Uppercase<PropertyName>}\`` for Redux action types. They're essential for maintaining consistent naming conventions at the type level."

---

### Q4: How do you combine template literals with mapped types?

**Answer:**

> "You use template literals in the key remapping 'as' clause of mapped types to transform property names. The syntax is `[K in keyof T as \`pattern${K & string}\`]`. For example, to create getters: `{ [K in keyof T as \`get${Capitalize<K & string>}\`]: () => T[K] }`transforms each property name into a getter method. The`K & string` is necessary because keyof can include symbols and numbers. This pattern is incredibly useful for creating event handlers (`on${Capitalize<K>}`), Redux actions (`set${Capitalize<K>}`), or API endpoints (`/${K}`). It's one of TypeScript's most powerful patterns."

---

### Q5: Can you pattern match and extract parts from string types?

**Answer:**

> "Yes, using template literals with conditional types and infer. For example, to extract route parameters: `type ExtractParam<T> = T extends \`\${string}:\${infer Param}/\${infer Rest}\` ? Param | ExtractParam<Rest> : never`. This recursively extracts parameters from '/users/:userId/posts/:postId' giving 'userId' | 'postId'. You can extract prefixes: `S extends \`\${Prefix}\${infer Rest}\` ? Rest : S`, or parse versions: `V extends \`v\${infer Major}.\${infer Minor}\` ? { major: Major; minor: Minor } : never`. It's pattern matching for string types, enabling sophisticated string parsing at the type level."

---

## üîë Must Know Checklist

### ‚úÖ Critical (Always asked)

- ‚úÖ Template literal type syntax
- ‚úÖ Distribution over unions
- ‚úÖ Intrinsic string manipulation types
- ‚úÖ Combining with mapped types

### ‚úÖ Should Know (Often asked)

- ‚úÖ Pattern matching with infer
- ‚úÖ Multiple interpolations
- ‚úÖ Key transformation patterns
- ‚úÖ Real-world use cases

### ‚úÖ Nice to Know (Senior level)

- [ ] Recursive string manipulation
- [ ] Object path types
- [ ] Performance considerations
- [ ] Complex pattern matching

---

## üö® Common Mistakes to Avoid

### 1. Forgetting string intersection

```typescript
// ‚ùå K might be symbol or number
type Bad<T> = {
  [K in keyof T as `get${K}`]: T[K]; // Error!
};

// ‚úÖ Ensure K is string
type Good<T> = {
  [K in keyof T as `get${K & string}`]: T[K];
};
```

### 2. Not considering distribution

```typescript
// Union distributes
type Size = "sm" | "md";
type Class = `btn-${Size}`; // "btn-sm" | "btn-md" ‚úÖ

// If you want the union in the string:
type BadClass = `btn-${Size | "lg"}`; // Distributes ‚ùå
type GoodClass = `btn-${"sm" | "md" | "lg"}`; // Also distributes ‚úÖ
```

### 3. Too many combinations

```typescript
// ‚ö†Ô∏è Creates 1000 types!
type Bad = `${A}${B}${C}`; // where each has 10 options

// ‚úÖ Limit combinations or use at runtime
type Good = A | B | C;
```

### 4. Using with non-literal types

```typescript
// ‚ùå string is not a literal
type Bad = Capitalize<string>; // string (no effect)

// ‚úÖ Use with literals
type Good = Capitalize<"hello">; // "Hello"
```
