# Mapped Types - Deep Dive

## üéØ Key Concepts

### 1. Mapped Type Syntax (CRITICAL!)

**What it means:**

- Transform properties of an existing type
- Iterate over keys to create new type
- Syntax: `{ [P in K]: T }`
- Foundation for many utility types

**Basic syntax:**

```typescript
type Readonly<T> = {
  readonly [P in keyof T]: T[P];
};

interface User {
  name: string;
  age: number;
}

type ReadonlyUser = Readonly<User>;
// { readonly name: string; readonly age: number }
```

**How it works:**

- `P in keyof T` - iterate over each key P in T
- `keyof T` - union of all keys
- `T[P]` - lookup property type
- Creates new type with transformed properties

**Basic patterns:**

```typescript
// Make all properties optional
type Partial<T> = {
  [P in keyof T]?: T[P];
};

// Make all properties required
type Required<T> = {
  [P in keyof T]-?: T[P]; // -? removes optional modifier
};

// Make all properties readonly
type Readonly<T> = {
  readonly [P in keyof T]: T[P];
};

// Make all properties mutable
type Mutable<T> = {
  -readonly [P in keyof T]: T[P]; // -readonly removes readonly
};
```

**Why mapped types are powerful:**

- ‚úÖ Transform entire object types systematically
- ‚úÖ Preserve property names and structure
- ‚úÖ Add/remove modifiers (readonly, optional)
- ‚úÖ Change property types
- ‚úÖ Foundation for utility types
- ‚úÖ Enable type-level programming

**Interview Gold:** "Mapped types iterate over object keys to create new types. Using `[P in keyof T]`, you can transform all properties - making them optional, readonly, changing their types, or even filtering/renaming them. They're the foundation for utility types like Partial, Required, and Pick."

---

### 2. Mapping Modifiers (+ and -)

**What it means:**

- `+` adds a modifier (readonly or optional)
- `-` removes a modifier
- Default is `+` if not specified
- Essential for creating opposite transformations

**Adding modifiers (+):**

```typescript
// Add readonly (+ is implicit)
type Readonly<T> = {
  +readonly [P in keyof T]: T[P];
  // Same as: readonly [P in keyof T]: T[P];
};

// Add optional (+ is implicit)
type Partial<T> = {
  [P in keyof T]+?: T[P];
  // Same as: [P in keyof T]?: T[P];
};
```

**Removing modifiers (-):**

```typescript
// Remove optional (make required)
type Required<T> = {
  [P in keyof T]-?: T[P];
};

// Remove readonly (make mutable)
type Mutable<T> = {
  -readonly [P in keyof T]: T[P];
};

// Remove both modifiers
type Concrete<T> = {
  -readonly [P in keyof T]-?: T[P];
};
```

**Practical example:**

```typescript
interface Config {
  readonly host: string;
  readonly port?: number;
  readonly ssl?: boolean;
}

// Make everything required and mutable
type EditableConfig = Concrete<Config>;
// { host: string; port: number; ssl: boolean }
```

**Common combinations:**

```typescript
// Partial + Readonly
type PartialReadonly<T> = {
  readonly [P in keyof T]?: T[P];
};

// Required + Readonly
type RequiredReadonly<T> = {
  readonly [P in keyof T]-?: T[P];
};

// Optional but not readonly
type OptionalMutable<T> = {
  -readonly [P in keyof T]?: T[P];
};
```

---

### 3. Key Remapping with 'as' Clause (CRITICAL!)

**What it means:**

- Rename keys while mapping
- Filter keys (use never to exclude)
- Transform key names (add prefixes, change case)
- TypeScript 4.1+ feature

**Basic remapping:**

```typescript
// Add prefix to all keys
type Prefixed<T, Prefix extends string> = {
  [P in keyof T as `${Prefix}${P & string}`]: T[P];
};

interface User {
  name: string;
  age: number;
}

type PrefixedUser = Prefixed<User, "user_">;
// { user_name: string; user_age: number }
```

**Filtering keys:**

```typescript
// Remove properties by name
type OmitById<T> = {
  [P in keyof T as P extends "id" ? never : P]: T[P];
};

interface Product {
  id: number;
  name: string;
  price: number;
}

type ProductWithoutId = OmitById<Product>;
// { name: string; price: number }
```

**Filtering by type:**

```typescript
// Keep only function properties
type FunctionProperties<T> = {
  [P in keyof T as T[P] extends Function ? P : never]: T[P];
};

interface API {
  baseUrl: string;
  timeout: number;
  get: () => void;
  post: () => void;
}

type APIFunctions = FunctionProperties<API>;
// { get: () => void; post: () => void }
```

**Case transformation:**

```typescript
// Convert keys to uppercase
type Uppercase<T> = {
  [P in keyof T as Uppercase<P & string>]: T[P];
};

type Config = {
  host: string;
  port: number;
};

type ConfigUpper = Uppercase<Config>;
// { HOST: string; PORT: number }
```

**Conditional remapping:**

```typescript
// Add 'get' prefix to getters
type Getters<T> = {
  [P in keyof T as `get${Capitalize<P & string>}`]: () => T[P];
};

interface State {
  count: number;
  name: string;
}

type StateGetters = Getters<State>;
// {
//   getCount: () => number;
//   getName: () => string;
// }
```

---

### 4. Mapping Over Union Types

**What it means:**

- Create mapped type from union of keys
- Use union in `in` clause
- Build object from string literal union

**Basic union mapping:**

```typescript
type Keys = "name" | "age" | "email";

type ObjectFromKeys<K extends string> = {
  [P in K]: string;
};

type User = ObjectFromKeys<Keys>;
// { name: string; age: string; email: string }
```

**With specific types:**

```typescript
type EventMap = {
  click: MouseEvent;
  keypress: KeyboardEvent;
  submit: SubmitEvent;
};

type EventHandlers = {
  [K in keyof EventMap]: (event: EventMap[K]) => void;
};
// {
//   click: (event: MouseEvent) => void;
//   keypress: (event: KeyboardEvent) => void;
//   submit: (event: SubmitEvent) => void;
// }
```

**Record utility type:**

```typescript
// Implementation
type Record<K extends string | number | symbol, T> = {
  [P in K]: T;
};

// Usage
type PageInfo = Record<"home" | "about" | "contact", { title: string }>;
// {
//   home: { title: string };
//   about: { title: string };
//   contact: { title: string };
// }
```

**Enum to object:**

```typescript
enum Status {
  Idle = "IDLE",
  Loading = "LOADING",
  Success = "SUCCESS",
}

type StatusMap<T> = {
  [K in keyof T]: boolean;
};

type StatusFlags = StatusMap<typeof Status>;
// { Idle: boolean; Loading: boolean; Success: boolean }
```

---

### 5. Built-in Mapped Utility Types

**What it means:**

- TypeScript includes many mapped types
- Understanding implementations helps master mapping
- Can create custom variations

**Partial - make all optional:**

```typescript
type Partial<T> = {
  [P in keyof T]?: T[P];
};

interface Todo {
  title: string;
  description: string;
  completed: boolean;
}

type PartialTodo = Partial<Todo>;
// All properties optional
```

**Required - make all required:**

```typescript
type Required<T> = {
  [P in keyof T]-?: T[P];
};

interface Config {
  host?: string;
  port?: number;
}

type RequiredConfig = Required<Config>;
// All properties required
```

**Readonly - make all readonly:**

```typescript
type Readonly<T> = {
  readonly [P in keyof T]: T[P];
};
```

**Pick - select properties:**

```typescript
type Pick<T, K extends keyof T> = {
  [P in K]: T[P];
};

type UserBasic = Pick<User, "name" | "email">;
// Only name and email
```

**Omit - exclude properties:**

```typescript
type Omit<T, K extends keyof T> = {
  [P in keyof T as P extends K ? never : P]: T[P];
};
// Or using Pick and Exclude:
type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;

type UserWithoutId = Omit<User, "id">;
```

**Record - create object type:**

```typescript
type Record<K extends string | number | symbol, T> = {
  [P in K]: T;
};

type PageSettings = Record<string, { title: string; layout: string }>;
```

---

### 6. Advanced Mapping Patterns

**Pattern 1: Nullable properties:**

```typescript
type Nullable<T> = {
  [P in keyof T]: T[P] | null;
};

interface User {
  name: string;
  age: number;
}

type NullableUser = Nullable<User>;
// { name: string | null; age: number | null }
```

**Pattern 2: Deeply nested mapping:**

```typescript
type DeepPartial<T> = {
  [P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : T[P];
};

type DeepReadonly<T> = {
  readonly [P in keyof T]: T[P] extends object ? DeepReadonly<T[P]> : T[P];
};
```

**Pattern 3: Type transformation:**

```typescript
// Convert all properties to promises
type Promisify<T> = {
  [P in keyof T]: Promise<T[P]>;
};

interface SyncAPI {
  getUser: () => User;
  getPost: () => Post;
}

type AsyncAPI = Promisify<SyncAPI>;
// {
//   getUser: Promise<User>;
//   getPost: Promise<Post>;
// }
```

**Pattern 4: Proxy type:**

```typescript
// Add 'get' and 'set' methods for each property
type Proxify<T> = {
  [P in keyof T]: {
    get: () => T[P];
    set: (value: T[P]) => void;
  };
};
```

**Pattern 5: Flatten object:**

```typescript
type Flatten<T> = {
  [P in keyof T]: T[P] extends object
    ? T[P] extends any[]
      ? T[P] // Keep arrays as-is
      : Flatten<T[P]> // Recurse into objects
    : T[P];
};
```

---

### 7. Combining Mapped Types with Conditionals

**What it means:**

- Use conditional types within mapped types
- Create sophisticated transformations
- Filter and transform simultaneously

**Basic combination:**

```typescript
// Make functions async, keep others same
type Asyncify<T> = {
  [P in keyof T]: T[P] extends (...args: infer A) => infer R
    ? (...args: A) => Promise<R>
    : T[P];
};

interface API {
  getUser: (id: string) => User;
  timeout: number;
}

type AsyncAPI = Asyncify<API>;
// {
//   getUser: (id: string) => Promise<User>;
//   timeout: number;
// }
```

**Filter by type:**

```typescript
// Extract only string properties
type StringProps<T> = {
  [P in keyof T as T[P] extends string ? P : never]: T[P];
};

interface Mixed {
  name: string;
  age: number;
  email: string;
}

type Strings = StringProps<Mixed>;
// { name: string; email: string }
```

**Conditional transformation:**

```typescript
// Wrap primitives in arrays, keep objects
type Arrayify<T> = {
  [P in keyof T]: T[P] extends object ? T[P] : T[P][];
};
```

**Readonly based on type:**

```typescript
// Make primitives readonly, keep objects mutable
type SelectiveReadonly<T> = {
  [P in keyof T]: T[P] extends object ? T[P] : Readonly<T[P]>;
};
```

---

### 8. Practical Real-World Patterns

**Pattern 1: Form state:**

```typescript
type FormState<T> = {
  [P in keyof T]: {
    value: T[P];
    error?: string;
    touched: boolean;
    dirty: boolean;
  };
};

interface LoginForm {
  email: string;
  password: string;
}

type LoginFormState = FormState<LoginForm>;
// {
//   email: { value: string; error?: string; touched: boolean; dirty: boolean };
//   password: { value: string; error?: string; touched: boolean; dirty: boolean };
// }
```

**Pattern 2: API endpoints:**

```typescript
type APIEndpoints<T> = {
  [P in keyof T as `/${P & string}`]: {
    get: () => Promise<T[P]>;
    post: (data: T[P]) => Promise<T[P]>;
  };
};
```

**Pattern 3: Event listeners:**

```typescript
type EventListeners<T> = {
  [P in keyof T as `on${Capitalize<P & string>}`]: (data: T[P]) => void;
};

interface Events {
  login: { userId: string };
  logout: void;
}

type Listeners = EventListeners<Events>;
// {
//   onLogin: (data: { userId: string }) => void;
//   onLogout: (data: void) => void;
// }
```

**Pattern 4: Validation schema:**

```typescript
type ValidationSchema<T> = {
  [P in keyof T]: {
    required: boolean;
    validator: (value: T[P]) => boolean;
    errorMessage: string;
  };
};
```

**Pattern 5: Redux actions:**

```typescript
type Actions<T> = {
  [P in keyof T as `set${Capitalize<P & string>}`]: (value: T[P]) => {
    type: `SET_${Uppercase<P & string>}`;
    payload: T[P];
  };
};
```

---

## üé§ Top Interview Questions & Model Answers

### Q1: What are mapped types and how do they work?

**Answer:**

> "Mapped types iterate over object keys to create new types. Using the syntax `[P in keyof T]`, TypeScript loops through each property P in type T, allowing you to transform properties systematically. You can add or remove modifiers like readonly and optional using + and -, change property types, or even rename/filter keys using the 'as' clause. They're the foundation for utility types like Partial, Required, and Pick. For example, `type Readonly<T> = { readonly [P in keyof T]: T[P] }` makes all properties readonly by mapping over them."

---

### Q2: How do you use the 'as' clause for key remapping?

**Answer:**

> "The 'as' clause in mapped types lets you transform key names or filter keys entirely. You use it as `[P in keyof T as NewKeyType]`. To filter, return `never` for keys you want to exclude: `[P in keyof T as P extends 'id' ? never : P]` removes the id property. To transform, use template literals: `[P in keyof T as \`get${Capitalize<P & string>}\`]`adds 'get' prefix to all keys. You can also filter by type:`[P in keyof T as T[P] extends Function ? P : never]` keeps only function properties. This feature was added in TypeScript 4.1 and is incredibly powerful for type manipulation."

---

### Q3: Explain mapping modifiers (+ and -) with examples.

**Answer:**

> "Mapping modifiers control readonly and optional properties. The `+` modifier adds them (it's the default), and `-` removes them. For example, `[P in keyof T]?:` adds optional (same as `+?:`), while `[P in keyof T]-?:` removes optional, making properties required - that's how the Required utility type works. Similarly, `readonly [P in keyof T]` adds readonly, and `-readonly [P in keyof T]` removes it. You can combine them: `{ -readonly [P in keyof T]-?: T[P] }` removes both readonly and optional modifiers. This is essential for creating opposite transformations like Mutable (opposite of Readonly) or Required (opposite of Partial)."

---

### Q4: How do mapped types differ from conditional types?

**Answer:**

> "Mapped types transform object properties by iterating over keys, while conditional types make decisions based on type checks. Mapped types use `[P in keyof T]` syntax to loop through properties, whereas conditional types use `T extends U ? X : Y` to choose between types. However, they work great together - you can use conditional types inside mapped types to create sophisticated transformations. For example, `{ [P in keyof T]: T[P] extends Function ? AsyncFunction<T[P]> : T[P] }` uses mapping to iterate and conditionals to decide the transformation. Mapped types are for object transformation, conditionals are for type-level logic."

---

### Q5: How would you implement a DeepReadonly type?

**Answer:**

> "I'd use recursive mapped types with a conditional type to handle nested objects: `type DeepReadonly<T> = { readonly [P in keyof T]: T[P] extends object ? DeepReadonly<T[P]> : T[P] }`. This makes the current level readonly, then checks if each property is an object - if yes, recursively applies DeepReadonly to it. I'd also handle arrays specially: check `T[P] extends any[]` before the object check, and use `ReadonlyArray<DeepReadonly<T[P][number]>>` to handle array elements. The key is combining mapping (to iterate properties), conditionals (to check types), and recursion (to handle nesting) - this pattern is the foundation for many advanced utility types."

---

## üîë Must Know Checklist

### ‚úÖ Critical (Always asked)

- ‚úÖ Mapped type syntax ([P in keyof T])
- ‚úÖ Mapping modifiers (+ and -)
- ‚úÖ Key remapping with 'as' clause
- ‚úÖ Built-in utility types (Partial, Required, etc.)

### ‚úÖ Should Know (Often asked)

- ‚úÖ Mapping over union types
- ‚úÖ Combining with conditional types
- ‚úÖ Filtering keys (using never)
- ‚úÖ Deep mapped types (recursive)

### ‚úÖ Nice to Know (Senior level)

- [ ] Advanced key transformations
- [ ] Template literal key mapping
- [ ] Complex filtering patterns
- [ ] Performance considerations

---

## üö® Common Mistakes to Avoid

### 1. Forgetting keyof

```typescript
// ‚ùå Missing keyof
type Bad<T> = {
  [P in T]: T[P]; // Error: T is not iterable
};

// ‚úÖ Use keyof
type Good<T> = {
  [P in keyof T]: T[P];
};
```

### 2. Wrong modifier syntax

```typescript
// ‚ùå Wrong position
type Bad<T> = {
  [P in keyof T]: readonly T[P]; // readonly on value, not property
};

// ‚úÖ Correct position
type Good<T> = {
  readonly [P in keyof T]: T[P];
};
```

### 3. Not constraining union types

```typescript
// ‚ùå Union type not constrained
type Bad<K> = {
  [P in K]: string; // Error: K might not be key-like
};

// ‚úÖ Constrain the union
type Good<K extends string | number | symbol> = {
  [P in K]: string;
};
```

### 4. Forgetting string intersection for template literals

```typescript
// ‚ùå P might not be string
type Bad<T> = {
  [P in keyof T as `get${P}`]: T[P]; // Error
};

// ‚úÖ Ensure P is string
type Good<T> = {
  [P in keyof T as `get${P & string}`]: T[P];
};
```
