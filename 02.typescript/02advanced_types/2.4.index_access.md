# Index Access Types - Deep Dive

## üéØ Key Concepts

### 1. Basic Index Access Syntax (CRITICAL!)

**What it means:**

- Look up a property type from another type
- Use bracket notation: `Type[Key]`
- Like accessing object properties, but at type level
- Extract types from objects, arrays, tuples

**Basic property access:**

```typescript
interface User {
  name: string;
  age: number;
  email: string;
}

type UserName = User["name"]; // string
type UserAge = User["age"]; // number
type UserEmail = User["email"]; // string
```

**Multiple property access:**

```typescript
type NameOrAge = User["name" | "age"]; // string | number
type AllProps = User["name" | "age" | "email"]; // string | number
```

**Why index access is powerful:**

- ‚úÖ Extract types without duplication
- ‚úÖ Stay in sync with source type automatically
- ‚úÖ Access nested property types
- ‚úÖ Work with computed keys
- ‚úÖ Essential for advanced type patterns

**Interview Gold:** "Index access types use bracket notation to look up property types from other types. `User['name']` gives you the type of the name property. You can use unions to access multiple properties: `User['name' | 'age']` gives `string | number`. They're essential for extracting types, keeping types in sync, and building type-safe utilities."

---

### 2. Using keyof with Index Access (CRITICAL!)

**What it means:**

- `keyof T` gets all keys as a union
- `T[keyof T]` gets union of all property types
- Common pattern for getting all value types

**Get all property types:**

```typescript
interface Person {
  name: string;
  age: number;
  isActive: boolean;
}

type PersonKeys = keyof Person; // "name" | "age" | "isActive"
type PersonValues = Person[keyof Person]; // string | number | boolean
```

**Why this pattern is useful:**

```typescript
// Create a Record with same value types
type PersonRecord = Record<string, Person[keyof Person]>;
// Record<string, string | number | boolean>

// Get all function types
interface API {
  getUser: () => User;
  saveUser: (user: User) => void;
  baseUrl: string;
}

type APIFunctions = API[keyof API];
// (() => User) | ((user: User) => void) | string
```

**Filtering by type:**

```typescript
// Get keys of string properties
type StringKeys<T> = {
  [K in keyof T]: T[K] extends string ? K : never;
}[keyof T];

type PersonStringKeys = StringKeys<Person>; // "name"
```

**Practical example:**

```typescript
function getProperty<T, K extends keyof T>(obj: T, key: K): T[K] {
  return obj[key];
}

const person: Person = {
  name: "Alice",
  age: 30,
  isActive: true,
};

const name = getProperty(person, "name"); // Type: string
const age = getProperty(person, "age"); // Type: number
```

---

### 3. Array Element Types

**What it means:**

- Access array element type using number index
- Use `Array[number]` pattern
- Works with arrays and tuples

**Array element access:**

```typescript
type StringArray = string[];
type ElementType = StringArray[number]; // string

type NumberArray = number[];
type NumElement = NumberArray[number]; // number
```

**Union of array elements:**

```typescript
const colors = ["red", "green", "blue"] as const;
type Colors = typeof colors; // readonly ["red", "green", "blue"]
type Color = (typeof colors)[number]; // "red" | "green" | "blue"
```

**With tuple types:**

```typescript
type Tuple = [string, number, boolean];
type TupleElement = Tuple[number]; // string | number | boolean
type FirstElement = Tuple[0]; // string
type SecondElement = Tuple[1]; // number
```

**Practical patterns:**

```typescript
// Extract element type from array
type Flatten<T> = T extends (infer U)[] ? U : T;

type Numbers = number[];
type Num = Flatten<Numbers>; // number

// Or using index access
type FlattenIndex<T> = T extends any[] ? T[number] : T;
type Num2 = FlattenIndex<Numbers>; // number
```

**Real-world example:**

```typescript
const ROLES = ["admin", "user", "moderator"] as const;
type Role = (typeof ROLES)[number]; // "admin" | "user" | "moderator"

function hasRole(role: Role) {
  // Type-safe role checking
}
```

---

### 4. Nested Property Access

**What it means:**

- Chain bracket notation to access nested types
- Navigate through object hierarchies
- Type-safe deep property access

**Basic nested access:**

```typescript
interface User {
  profile: {
    name: string;
    address: {
      city: string;
      country: string;
    };
  };
}

type ProfileType = User["profile"];
// { name: string; address: { city: string; country: string } }

type NameType = User["profile"]["name"]; // string
type AddressType = User["profile"]["address"]; // { city: string; country: string }
type CityType = User["profile"]["address"]["city"]; // string
```

**Generic nested access:**

```typescript
type NestedValue<T, K1 extends keyof T, K2 extends keyof T[K1]> = T[K1][K2];

type City = NestedValue<User, "profile", "address">;
// { city: string; country: string }
```

**Deep property path type:**

```typescript
type DeepValue<T, Path extends string> = Path extends `${infer K}.${infer Rest}`
  ? K extends keyof T
    ? DeepValue<T[K], Rest>
    : never
  : Path extends keyof T
  ? T[Path]
  : never;

type City = DeepValue<User, "profile.address.city">; // string
```

**Practical use - form field access:**

```typescript
interface Form {
  user: {
    name: string;
    email: string;
  };
  settings: {
    theme: string;
  };
}

function getField<T, K1 extends keyof T, K2 extends keyof T[K1]>(
  form: T,
  key1: K1,
  key2: K2
): T[K1][K2] {
  return form[key1][key2];
}

const userName = getField(form, "user", "name"); // string
```

---

### 5. Conditional Types with Index Access

**What it means:**

- Combine index access with conditional logic
- Filter properties by type
- Extract specific kinds of properties

**Filter properties:**

```typescript
// Get only string properties
type StringProperties<T> = {
  [K in keyof T]: T[K] extends string ? K : never;
}[keyof T];

interface Mixed {
  name: string;
  age: number;
  email: string;
  active: boolean;
}

type StringKeys = StringProperties<Mixed>; // "name" | "email"
```

**Get function properties:**

```typescript
type FunctionProperties<T> = {
  [K in keyof T]: T[K] extends Function ? K : never;
}[keyof T];

interface API {
  baseUrl: string;
  get: () => void;
  post: () => void;
}

type Methods = FunctionProperties<API>; // "get" | "post"
```

**Extract optional properties:**

```typescript
type OptionalKeys<T> = {
  [K in keyof T]-?: {} extends Pick<T, K> ? K : never;
}[keyof T];

interface Config {
  host: string;
  port?: number;
  ssl?: boolean;
}

type Optional = OptionalKeys<Config>; // "port" | "ssl"
```

**Extract required properties:**

```typescript
type RequiredKeys<T> = {
  [K in keyof T]-?: {} extends Pick<T, K> ? never : K;
}[keyof T];

type Required = RequiredKeys<Config>; // "host"
```

---

### 6. Index Signatures and Access

**What it means:**

- Index signatures define dynamic property types
- Access them using string/number/symbol
- Different from specific property access

**Basic index signature access:**

```typescript
interface Dictionary {
  [key: string]: number;
}

type DictValue = Dictionary[string]; // number
```

**Mixed index signatures:**

```typescript
interface MixedDict {
  knownProp: string;
  [key: string]: string | number;
}

type KnownType = MixedDict["knownProp"]; // string
type DynamicType = MixedDict[string]; // string | number
```

**Array-like access:**

```typescript
interface ArrayLike<T> {
  [index: number]: T;
  length: number;
}

type Element<T> = ArrayLike<T>[number]; // T
type Length = ArrayLike<any>["length"]; // number
```

**Practical pattern:**

```typescript
type Values<T> = T[keyof T];

interface Status {
  [key: string]: boolean;
}

type StatusValue = Values<Status>; // boolean
```

---

### 7. Mapped Types with Index Access

**What it means:**

- Combine mapped types and index access
- Create sophisticated type transformations
- Extract and transform simultaneously

**Pick properties of certain type:**

```typescript
type PickByType<T, Type> = {
  [K in keyof T as T[K] extends Type ? K : never]: T[K];
};

interface User {
  name: string;
  age: number;
  email: string;
  active: boolean;
}

type StringProps = PickByType<User, string>;
// { name: string; email: string }

type NumberProps = PickByType<User, number>;
// { age: number }
```

**Transform property types:**

```typescript
type Nullable<T> = {
  [K in keyof T]: T[K] | null;
};

type NullableUser = Nullable<User>;
// {
//   name: string | null;
//   age: number | null;
//   email: string | null;
//   active: boolean | null;
// }
```

**Getter types:**

```typescript
type Getters<T> = {
  [K in keyof T as `get${Capitalize<K & string>}`]: () => T[K];
};

type UserGetters = Getters<User>;
// {
//   getName: () => string;
//   getAge: () => number;
//   getEmail: () => string;
//   getActive: () => boolean;
// }
```

---

### 8. Advanced Patterns and Techniques

**Pattern 1: Deep readonly:**

```typescript
type DeepReadonly<T> = {
  readonly [K in keyof T]: T[K] extends object ? DeepReadonly<T[K]> : T[K];
};
```

**Pattern 2: Path-based property access:**

```typescript
type PropType<T, Path extends string> = Path extends keyof T
  ? T[Path]
  : Path extends `${infer K}.${infer R}`
  ? K extends keyof T
    ? PropType<T[K], R>
    : never
  : never;

interface Nested {
  user: {
    profile: {
      name: string;
    };
  };
}

type Name = PropType<Nested, "user.profile.name">; // string
```

**Pattern 3: Union of nested values:**

```typescript
type NestedValues<T> = T[keyof T] extends infer V
  ? V extends object
    ? V | NestedValues<V>
    : V
  : never;
```

**Pattern 4: Type-safe object path:**

```typescript
type PathsToValue<T, V> = {
  [K in keyof T]: T[K] extends V
    ? K
    : T[K] extends object
    ? `${K & string}.${PathsToValue<T[K], V> & string}`
    : never;
}[keyof T];

type StringPaths = PathsToValue<User, string>;
// All paths leading to string values
```

**Pattern 5: Conditional index access:**

```typescript
type ExtractByType<T, U> = {
  [K in keyof T]: T[K] extends U ? T[K] : never;
}[keyof T];

type StringValues = ExtractByType<User, string>;
// string (union of all string property types)
```

---

## üé§ Top Interview Questions & Model Answers

### Q1: What are index access types and how do they work?

**Answer:**

> "Index access types let you look up property types from other types using bracket notation, like `User['name']` to get the string type. You can access multiple properties with unions: `User['name' | 'age']` gives `string | number`. Combined with `keyof`, you can get all value types: `User[keyof User]` creates a union of all property types. They're essential for extracting types without duplication, staying in sync with source types, and building type-safe utilities. I use them constantly with generic functions to ensure the return type matches the accessed property type."

---

### Q2: How do you get the type of array elements?

**Answer:**

> "You use the number index: `ArrayType[number]` gives you the element type. For example, `string[][number]` gives `string`, and for tuples, `[string, number, boolean][number]` gives `string | number | boolean`. This is particularly useful with `as const` arrays: `const colors = ['red', 'green'] as const; type Color = typeof colors[number]` gives `'red' | 'green'`. This pattern is how I create type-safe enums from arrays. You can also access specific tuple indices: `Tuple[0]` for the first element."

---

### Q3: How do you access nested property types?

**Answer:**

> "You chain bracket notation to navigate through object hierarchies: `User['profile']['address']['city']` accesses the deeply nested city type. For dynamic paths, I combine this with conditional types and template literals: `type PropType<T, Path> = Path extends \`\${infer K}.\${infer Rest}\` ? PropType<T[K], Rest> : T[Path]`. This enables type-safe property access using string paths like 'profile.address.city'. It's crucial for form libraries, state management, and any deep object manipulation where you need compile-time type safety."

---

### Q4: How do you filter properties by type using index access?

**Answer:**

> "I combine mapped types with conditional types and index access. The pattern is: `type FilterByType<T, U> = { [K in keyof T as T[K] extends U ? K : never]: T[K] }[keyof T]`. The mapped type checks each property with a conditional, the 'as' clause filters keys by returning 'never' for non-matches, and the final `[keyof T]` extracts just the values. For example, to get all string properties: `FilterByType<User, string>`. This is foundational for building type utilities that operate on subsets of properties."

---

### Q5: What's the difference between T[K] and T[keyof T]?

**Answer:**

> "`T[K]` accesses a specific property type where K is a known key, while `T[keyof T]` accesses all property types and creates their union. For example, if User has name: string and age: number, then `User['name']` is `string`, but `User[keyof User]` is `string | number`. I use `T[K]` when I know the specific property I'm accessing, like in generic functions: `function get<T, K extends keyof T>(obj: T, key: K): T[K]`. I use `T[keyof T]` when I need the union of all possible value types."

---

## üîë Must Know Checklist

### ‚úÖ Critical (Always asked)

- ‚úÖ Basic index access syntax (T[K])
- ‚úÖ Using keyof with index access (T[keyof T])
- ‚úÖ Array element access (Array[number])
- ‚úÖ Nested property access (chaining brackets)

### ‚úÖ Should Know (Often asked)

- ‚úÖ Conditional types with index access
- ‚úÖ Filtering properties by type
- ‚úÖ Index signatures and access
- ‚úÖ Mapped types with index access

### ‚úÖ Nice to Know (Senior level)

- [ ] Deep property path types
- [ ] Union of nested values
- [ ] Type-safe object paths
- [ ] Advanced filtering patterns

---

## üö® Common Mistakes to Avoid

### 1. Accessing non-existent properties

```typescript
interface User {
  name: string;
}

// ‚ùå Error: Property doesn't exist
type Email = User["email"];

// ‚úÖ Check property exists first
type Email = "email" extends keyof User ? User["email"] : never;
```

### 2. Confusing T[K] with T[keyof T]

```typescript
// T[K] - specific property
type Name<T> = T["name"]; // Only works if 'name' exists

// T[keyof T] - union of all properties
type Values<T> = T[keyof T]; // Union of all value types
```

### 3. Forgetting to constrain K

```typescript
// ‚ùå K not constrained
function get<T, K>(obj: T, key: K): T[K] {
  // Error!
  return obj[key];
}

// ‚úÖ Constrain K
function get<T, K extends keyof T>(obj: T, key: K): T[K] {
  return obj[key];
}
```

### 4. Not handling optional properties

```typescript
interface User {
  name: string;
  email?: string;
}

type Email = User["email"]; // string | undefined

// ‚úÖ Use NonNullable if needed
type DefiniteEmail = NonNullable<User["email"]>; // string
```
