# Jest Configuration

## üéØ Key Concepts

### 1. Jest Configuration File

**What it means:**

- `jest.config.js` controls Jest behavior
- Located in project root
- Can also be in package.json
- TypeScript version: `jest.config.ts`

**Basic structure:**

```javascript
// jest.config.js
module.exports = {
  testEnvironment: "jsdom",
  setupFilesAfterEnv: ["<rootDir>/jest.setup.js"],
  moduleNameMapper: {
    "^@/(.*)$": "<rootDir>/src/$1",
  },
  collectCoverageFrom: ["src/**/*.{js,jsx,ts,tsx}", "!src/**/*.d.ts"],
};
```

**Configuration locations:**

```javascript
// Option 1: jest.config.js (recommended)
module.exports = { /* config */ };

// Option 2: package.json
{
  "jest": {
    "testEnvironment": "jsdom"
  }
}

// Option 3: jest.config.ts (TypeScript)
import type { Config } from 'jest';
const config: Config = { /* config */ };
export default config;
```

---

### 2. Test Environment

**What it means:**

- Environment where tests run
- `jsdom` simulates browser (for React)
- `node` for Node.js code

**testEnvironment option:**

```javascript
module.exports = {
  // For browser/React code (default for CRA)
  testEnvironment: "jsdom",

  // OR for Node.js code
  testEnvironment: "node",
};
```

**When to use each:**

```javascript
// jsdom - Browser-like environment
// ‚úÖ Use for: React, DOM testing, browser APIs
testEnvironment: "jsdom";
// Provides: window, document, localStorage, etc.

// node - Node.js environment
// ‚úÖ Use for: API routes, server code, utilities
testEnvironment: "node";
// No browser APIs available
```

**Per-file environment:**

```javascript
/**
 * @jest-environment jsdom
 */
test("component test", () => {
  // Uses jsdom
});

/**
 * @jest-environment node
 */
test("API test", () => {
  // Uses node
});
```

---

### 3. Setup Files

**What it means:**

- Code that runs before tests
- Configure global test utilities
- Setup Testing Library matchers

**setupFilesAfterEnv:**

```javascript
// jest.config.js
module.exports = {
  setupFilesAfterEnv: ["<rootDir>/jest.setup.js"],
};

// jest.setup.js
import "@testing-library/jest-dom";

// Custom matchers
expect.extend({
  toBeWithinRange(received, floor, ceiling) {
    const pass = received >= floor && received <= ceiling;
    return {
      pass,
      message: () => `expected ${received} to be within ${floor}-${ceiling}`,
    };
  },
});

// Global test utilities
global.testUser = {
  id: 1,
  name: "Test User",
  email: "test@example.com",
};

// Mock console to reduce noise
global.console = {
  ...console,
  error: jest.fn(),
  warn: jest.fn(),
};
```

**setupFiles vs setupFilesAfterEnv:**

```javascript
module.exports = {
  // Runs BEFORE test framework installed
  // Use for: polyfills, global mocks
  setupFiles: ["<rootDir>/setup-polyfills.js"],

  // Runs AFTER test framework installed
  // Use for: Testing Library config, custom matchers
  setupFilesAfterEnv: ["<rootDir>/jest.setup.js"],
};
```

---

### 4. Module Name Mapping (Path Aliases)

**What it means:**

- Map import paths to file locations
- Support path aliases from tsconfig
- Simplify imports

**Basic mapping:**

```javascript
// jest.config.js
module.exports = {
  moduleNameMapper: {
    // Map @ to src
    "^@/(.*)$": "<rootDir>/src/$1",

    // Map ~components to src/components
    "^~components/(.*)$": "<rootDir>/src/components/$1",

    // Mock CSS modules
    "\\.(css|less|scss|sass)$": "identity-obj-proxy",

    // Mock static files
    "\\.(jpg|jpeg|png|gif|svg)$": "<rootDir>/__mocks__/fileMock.js",
  },
};
```

**Real-world example:**

```javascript
// Without mapping
import Button from '../../../components/Button';
import { api } from '../../../utils/api';

// With mapping
import Button from '@/components/Button';
import { api } from '@/utils/api';

// jest.config.js enables this:
moduleNameMapper: {
  '^@/(.*)$': '<rootDir>/src/$1',
}
```

**CSS modules:**

```javascript
// Mock CSS modules to return className as-is
moduleNameMapper: {
  '\\.module\\.(css|scss)$': 'identity-obj-proxy',
}

// Now in tests:
import styles from './Button.module.css';
console.log(styles.primary); // 'primary' instead of hash
```

---

### 5. Transform Configuration

**What it means:**

- How to process files before testing
- Handle TypeScript, JSX, etc.
- Babel or SWC for transpilation

**Basic transform:**

```javascript
module.exports = {
  transform: {
    // Use babel-jest for JS/JSX/TS/TSX
    "^.+\\.(js|jsx|ts|tsx)$": "babel-jest",
  },
};
```

**With custom babel config:**

```javascript
// jest.config.js
module.exports = {
  transform: {
    "^.+\\.(js|jsx|ts|tsx)$": [
      "babel-jest",
      {
        presets: [
          "@babel/preset-env",
          "@babel/preset-react",
          "@babel/preset-typescript",
        ],
      },
    ],
  },
};
```

**Next.js with SWC:**

```javascript
// jest.config.js for Next.js
const nextJest = require("next/jest");

const createJestConfig = nextJest({
  dir: "./",
});

const customJestConfig = {
  setupFilesAfterEnv: ["<rootDir>/jest.setup.js"],
  testEnvironment: "jest-environment-jsdom",
};

module.exports = createJestConfig(customJestConfig);
```

---

### 6. Test Match Patterns

**What it means:**

- Which files Jest considers tests
- Default: `**/*.test.js`, `**/*.spec.js`
- Customize to your structure

**testMatch option:**

```javascript
module.exports = {
  testMatch: ["**/__tests__/**/*.[jt]s?(x)", "**/?(*.)+(spec|test).[jt]s?(x)"],
};
```

**Common patterns:**

```javascript
// Default pattern
testMatch: ["**/__tests__/**/*.[jt]s?(x)", "**/?(*.)+(spec|test).[jt]s?(x)"];

// Only .test.js files
testMatch: ["**/*.test.js"];

// Tests in __tests__ folder only
testMatch: ["**/__tests__/**/*.js"];

// Exclude certain patterns
testMatch: ["**/*.test.js", "!**/node_modules/**", "!**/dist/**"];
```

**testIgnorePatterns:**

```javascript
module.exports = {
  testPathIgnorePatterns: ["/node_modules/", "/dist/", "/.next/", "/build/"],
};
```

---

### 7. Coverage Configuration

**What it means:**

- Configure code coverage collection
- Set coverage thresholds
- Specify which files to include

**Basic coverage config:**

```javascript
module.exports = {
  // Collect coverage from these files
  collectCoverageFrom: [
    "src/**/*.{js,jsx,ts,tsx}",
    "!src/**/*.d.ts",
    "!src/**/*.stories.{js,jsx,ts,tsx}",
    "!src/**/__tests__/**",
  ],

  // Coverage thresholds
  coverageThresholds: {
    global: {
      branches: 80,
      functions: 80,
      lines: 80,
      statements: 80,
    },
  },

  // Coverage reporters
  coverageReporters: ["text", "lcov", "html"],
};
```

**Per-directory thresholds:**

```javascript
module.exports = {
  coverageThresholds: {
    global: {
      statements: 80,
      branches: 80,
      functions: 80,
      lines: 80,
    },
    "./src/components/": {
      statements: 90,
      branches: 85,
      functions: 90,
      lines: 90,
    },
    "./src/utils/": {
      statements: 95,
      branches: 90,
      functions: 95,
      lines: 95,
    },
  },
};
```

**Run coverage:**

```bash
# Generate coverage report
npm test -- --coverage

# With watch mode
npm test -- --coverage --watchAll=false

# Only changed files
npm test -- --coverage --onlyChanged
```

---

### 8. Globals Configuration

**What it means:**

- Make variables available in all tests
- Avoid repetitive imports

**globals option:**

```javascript
module.exports = {
  globals: {
    __DEV__: true,
    API_URL: "http://localhost:3000",
  },
};

// Available in all tests without import
test("uses globals", () => {
  console.log(__DEV__); // true
  console.log(API_URL); // 'http://localhost:3000'
});
```

**TypeScript globals:**

```javascript
module.exports = {
  globals: {
    "ts-jest": {
      tsconfig: {
        jsx: "react",
        esModuleInterop: true,
      },
    },
  },
};
```

---

### 9. Watch Mode Options

**What it means:**

- Configure watch mode behavior
- Auto-run tests on file changes

**watchman option:**

```javascript
module.exports = {
  // Use Watchman for file watching (faster)
  watchman: true,

  // Watch plugins
  watchPlugins: [
    "jest-watch-typeahead/filename",
    "jest-watch-typeahead/testname",
  ],
};
```

**Watch mode commands:**

```bash
# Start watch mode
npm test -- --watch

# Watch all files
npm test -- --watchAll

# Run only changed files
npm test -- --onlyChanged
```

---

### 10. Complete Real-World Config

**React + TypeScript project:**

```javascript
// jest.config.js
module.exports = {
  // Environment
  testEnvironment: "jsdom",

  // Setup
  setupFilesAfterEnv: ["<rootDir>/jest.setup.js"],

  // Module resolution
  moduleNameMapper: {
    "^@/(.*)$": "<rootDir>/src/$1",
    "\\.(css|less|scss|sass)$": "identity-obj-proxy",
    "\\.(jpg|jpeg|png|gif|svg)$": "<rootDir>/__mocks__/fileMock.js",
  },

  // Transform
  transform: {
    "^.+\\.(js|jsx|ts|tsx)$": [
      "babel-jest",
      {
        presets: [
          "@babel/preset-env",
          "@babel/preset-react",
          "@babel/preset-typescript",
        ],
      },
    ],
  },

  // Test patterns
  testMatch: ["**/__tests__/**/*.[jt]s?(x)", "**/?(*.)+(spec|test).[jt]s?(x)"],

  testPathIgnorePatterns: ["/node_modules/", "/dist/", "/.next/"],

  // Coverage
  collectCoverageFrom: [
    "src/**/*.{js,jsx,ts,tsx}",
    "!src/**/*.d.ts",
    "!src/**/*.stories.{js,jsx,ts,tsx}",
    "!src/**/__tests__/**",
  ],

  coverageThresholds: {
    global: {
      branches: 80,
      functions: 80,
      lines: 80,
      statements: 80,
    },
  },

  // Watch mode
  watchman: true,
  watchPlugins: [
    "jest-watch-typeahead/filename",
    "jest-watch-typeahead/testname",
  ],
};
```

**jest.setup.js:**

```javascript
// jest.setup.js
import "@testing-library/jest-dom";

// Mock window.matchMedia
Object.defineProperty(window, "matchMedia", {
  writable: true,
  value: jest.fn().mockImplementation((query) => ({
    matches: false,
    media: query,
    onchange: null,
    addListener: jest.fn(),
    removeListener: jest.fn(),
    addEventListener: jest.fn(),
    removeEventListener: jest.fn(),
    dispatchEvent: jest.fn(),
  })),
});

// Mock IntersectionObserver
global.IntersectionObserver = class IntersectionObserver {
  constructor() {}
  disconnect() {}
  observe() {}
  takeRecords() {
    return [];
  }
  unobserve() {}
};

// Suppress console errors in tests
global.console = {
  ...console,
  error: jest.fn(),
  warn: jest.fn(),
};
```

---

## üé§ Interview Questions & Model Answers

### Q1: What's the difference between jsdom and node test environments?

**Answer:**

> "The jsdom environment simulates a browser, providing window, document, and other browser APIs, making it essential for testing React components and anything that uses the DOM. The node environment is lighter and faster but doesn't include browser APIs, so it's better for testing backend code, API routes, or pure JavaScript utilities. I use jsdom for React components and node for server-side code."

---

### Q2: What goes in setupFilesAfterEnv vs setupFiles?

**Answer:**

> "setupFiles runs before the test framework is installed, so I use it for polyfills or environment setup that needs to happen early. setupFilesAfterEnv runs after Jest is ready, so I use it for Testing Library configuration, custom matchers, and global test utilities. Most React projects only need setupFilesAfterEnv for importing jest-dom matchers."

---

### Q3: How do you handle path aliases in Jest?

**Answer:**

> "I use moduleNameMapper in jest.config.js to map import aliases to actual paths. For example, mapping '^@/(.\*)$' to '<rootDir>/src/$1' lets me use '@/components/Button' instead of relative paths like '../../../components/Button'. This needs to match what's configured in tsconfig.json or webpack so imports work consistently in both tests and application code."

---

### Q4: How do you configure code coverage in Jest?

**Answer:**

> "I use collectCoverageFrom to specify which files to include, typically 'src/\*_/_.{js,jsx,ts,tsx}' while excluding test files and type definitions. I set coverageThresholds to enforce minimum coverage, usually 80% for statements, branches, functions, and lines. For critical code like utilities, I might set higher thresholds. I run 'npm test -- --coverage' to generate reports."

---

### Q5: Why would you mock CSS modules in Jest config?

**Answer:**

> "CSS modules need to be mocked because Jest can't process CSS. I use 'identity-obj-proxy' which returns className values as-is, so in tests, styles.button returns 'button' instead of a hashed className. This lets me test that the right classes are applied without worrying about the actual CSS. For images and other static files, I create a simple mock file that exports a string."

---

## üîë Must Know for Interviews

### ‚úÖ Critical (Always Asked)

- ‚úÖ testEnvironment: jsdom vs node
- ‚úÖ setupFilesAfterEnv for jest-dom
- ‚úÖ moduleNameMapper for path aliases
- ‚úÖ Basic coverage configuration

### ‚úÖ Should Know (Often Asked)

- ‚úÖ Transform configuration for TypeScript/JSX
- ‚úÖ testMatch and testPathIgnorePatterns
- ‚úÖ Mocking CSS and static assets
- ‚úÖ Coverage thresholds

### ‚úÖ Nice to Know (Senior Level)

- [ ] Watch mode configuration
- [ ] Global variables configuration
- [ ] Custom transformers
- [ ] Per-file environment directives

---

## üö® Common Mistakes

### 1. Wrong Test Environment

```javascript
// ‚ùå BAD - Using node for React tests
module.exports = {
  testEnvironment: "node", // No DOM APIs!
};

test("renders button", () => {
  render(<Button />); // Error: document is not defined
});

// ‚úÖ GOOD - Use jsdom for React
module.exports = {
  testEnvironment: "jsdom",
};
```

### 2. Forgetting to Import jest-dom

```javascript
// ‚ùå BAD - No jest-dom matchers
test("button is visible", () => {
  render(<Button />);
  expect(screen.getByRole("button")).toBeInTheDocument(); // Error!
});

// ‚úÖ GOOD - Import in setupFilesAfterEnv
// jest.setup.js
import "@testing-library/jest-dom";
```

### 3. Path Aliases Not Matching

```javascript
// tsconfig.json
{
  "compilerOptions": {
    "paths": {
      "@/*": ["./src/*"]
    }
  }
}

// ‚ùå BAD - Jest doesn't know about this
// Tests will fail with module not found

// ‚úÖ GOOD - Mirror in jest.config.js
module.exports = {
  moduleNameMapper: {
    '^@/(.*)$': '<rootDir>/src/$1',
  },
};
```

### 4. Not Mocking CSS

```javascript
// ‚ùå BAD - No CSS handling
// Jest tries to parse CSS and fails

// ‚úÖ GOOD - Mock CSS files
module.exports = {
  moduleNameMapper: {
    "\\.(css|less|scss)$": "identity-obj-proxy",
  },
};
```

---

## üí° Quick Reference

```javascript
// Minimal React + TypeScript config
module.exports = {
  testEnvironment: "jsdom",
  setupFilesAfterEnv: ["<rootDir>/jest.setup.js"],
  moduleNameMapper: {
    "^@/(.*)$": "<rootDir>/src/$1",
    "\\.(css|scss)$": "identity-obj-proxy",
  },
  transform: {
    "^.+\\.(ts|tsx)$": "babel-jest",
  },
  collectCoverageFrom: ["src/**/*.{ts,tsx}", "!src/**/*.d.ts"],
};
```

```javascript
// jest.setup.js
import "@testing-library/jest-dom";
```

---

## üìù Package Scripts

```json
{
  "scripts": {
    "test": "jest",
    "test:watch": "jest --watch",
    "test:coverage": "jest --coverage",
    "test:ci": "jest --ci --coverage --maxWorkers=2"
  }
}
```
