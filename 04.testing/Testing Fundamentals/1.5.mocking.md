


# Mocking Fundamentals

## ðŸŽ¯ Key Concepts

### 1. Why Mock?

**What it means:**
- Replace real dependencies with controlled versions
- Isolate code under test
- Make tests faster and more reliable
- Test edge cases that are hard to reproduce

**The Problem Without Mocking:**

```javascript
// Component makes real API call
function UserProfile({ userId }) {
  const [user, setUser] = useState(null);
  
  useEffect(() => {
    fetch(`https://api.example.com/users/${userId}`)
      .then(res => res.json())
      .then(setUser);
  }, [userId]);
  
  return <div>{user?.name}</div>;
}

// Testing without mocks:
// âŒ Makes real HTTP request (slow!)
// âŒ Needs internet connection
// âŒ Needs backend running
// âŒ Can't test error scenarios easily
// âŒ Flaky (network issues)
```

**With Mocking:**

```javascript
// Mock the API call
global.fetch = jest.fn(() =>
  Promise.resolve({
    json: () => Promise.resolve({ name: 'John' })
  })
);

// Now test is:
// âœ… Fast (no network)
// âœ… Reliable (no real API)
// âœ… Can test any scenario
// âœ… Runs offline
```

**When to mock:**
- âœ… External APIs
- âœ… Databases
- âœ… File system operations
- âœ… Time/Date
- âœ… Random number generation
- âœ… Third-party libraries
- âœ… Slow operations

**When NOT to mock:**
- âŒ Code you're testing
- âŒ Simple utilities (just test them)
- âŒ Everything (over-mocking = testing mocks)

---

### 2. Mock vs Stub vs Spy

**What it means:**
- Three related but different concepts
- Often confused, but have distinct purposes

**Mock:**
- Replaces entire function/module
- You control all behavior
- Fully fake implementation

```javascript
// Mock - Complete replacement
const mockFn = jest.fn(() => 'mocked value');

mockFn('any', 'args'); // Returns 'mocked value'
expect(mockFn).toHaveBeenCalledWith('any', 'args');
```

**Stub:**
- Provides predetermined responses
- No real logic
- Returns fixed values

```javascript
// Stub - Fixed return values
const getUserStub = jest.fn()
  .mockReturnValue({ id: 1, name: 'John' });

const user = getUserStub();
console.log(user); // { id: 1, name: 'John' }
```

**Spy:**
- Wraps real function
- Observes calls but executes real code
- Records interactions

```javascript
// Spy - Real function + observation
const realFunction = (x) => x * 2;
const spy = jest.spyOn({ method: realFunction }, 'method');

const result = spy(5); // Actually runs real function
console.log(result); // 10 (real result)
expect(spy).toHaveBeenCalledWith(5);
```

**Summary:**

| Type | Behavior | Use Case |
|------|----------|----------|
| **Mock** | Fake implementation | Replace entire dependency |
| **Stub** | Fixed return values | Control outputs |
| **Spy** | Real code + recording | Verify real function calls |

---

### 3. jest.fn() - Mock Functions

**What it means:**
- Creates a mock function
- Records all calls
- Configurable return values

**Basic usage:**

```javascript
// Create mock function
const mockFn = jest.fn();

// Call it
mockFn('hello', 'world');
mockFn(123);

// Verify calls
expect(mockFn).toHaveBeenCalledTimes(2);
expect(mockFn).toHaveBeenCalledWith('hello', 'world');
expect(mockFn).toHaveBeenLastCalledWith(123);
```

**With return value:**

```javascript
// Return fixed value
const mockFn = jest.fn(() => 42);
expect(mockFn()).toBe(42);

// Or use mockReturnValue
const mockFn = jest.fn().mockReturnValue(42);
expect(mockFn()).toBe(42);
```

**With implementation:**

```javascript
// Custom logic
const mockAdd = jest.fn((a, b) => a + b);
expect(mockAdd(2, 3)).toBe(5);

// Or use mockImplementation
const mockAdd = jest.fn().mockImplementation((a, b) => a + b);
expect(mockAdd(2, 3)).toBe(5);
```

**One-time return values:**

```javascript
const mockFn = jest.fn()
  .mockReturnValueOnce('first')
  .mockReturnValueOnce('second')
  .mockReturnValue('default');

expect(mockFn()).toBe('first');
expect(mockFn()).toBe('second');
expect(mockFn()).toBe('default');
expect(mockFn()).toBe('default');
```

**Practical example:**

```javascript
test('button calls onClick', async () => {
  const handleClick = jest.fn();
  render(<Button onClick={handleClick}>Click me</Button>);
  
  await userEvent.click(screen.getByRole('button'));
  
  expect(handleClick).toHaveBeenCalledTimes(1);
});
```

---

### 4. jest.spyOn() - Spying on Methods

**What it means:**
- Monitor existing function
- Can replace or keep original
- Useful for object methods

**Basic usage:**

```javascript
const user = {
  getName: () => 'John',
  getAge: () => 30
};

// Spy on method
const spy = jest.spyOn(user, 'getName');

// Call it (executes real function)
const name = user.getName();
expect(name).toBe('John');

// Verify it was called
expect(spy).toHaveBeenCalled();

// Restore original
spy.mockRestore();
```

**Replace implementation:**

```javascript
const calculator = {
  add: (a, b) => a + b
};

// Spy and override
const spy = jest.spyOn(calculator, 'add')
  .mockImplementation((a, b) => 999);

expect(calculator.add(2, 3)).toBe(999); // Mocked
expect(spy).toHaveBeenCalledWith(2, 3);

spy.mockRestore();
expect(calculator.add(2, 3)).toBe(5); // Real function restored
```

**Spying on console:**

```javascript
test('logs error message', () => {
  const consoleSpy = jest.spyOn(console, 'error')
    .mockImplementation(() => {}); // Suppress output
  
  doSomethingThatLogs();
  
  expect(consoleSpy).toHaveBeenCalledWith('Error occurred');
  
  consoleSpy.mockRestore();
});
```

**When to use spyOn:**
- âœ… Testing if function was called
- âœ… Temporarily override method
- âœ… Suppress console output in tests
- âœ… Monitor third-party library calls

---

### 5. Mocking Modules

**What it means:**
- Replace entire module
- Mock all exports
- Control dependencies

**Manual mock:**

```javascript
// Mock entire module
jest.mock('./api');

// Now all imports from './api' are mocked
import { fetchUser } from './api';

// Configure mock
fetchUser.mockResolvedValue({ name: 'John' });

test('loads user', async () => {
  render(<UserProfile userId={1} />);
  expect(await screen.findByText('John')).toBeInTheDocument();
});
```

**Mock with implementation:**

```javascript
jest.mock('./api', () => ({
  fetchUser: jest.fn(() => Promise.resolve({ name: 'John' })),
  fetchPosts: jest.fn(() => Promise.resolve([]))
}));
```

**Partial mock:**

```javascript
// Mock only some exports, keep others real
jest.mock('./utils', () => ({
  ...jest.requireActual('./utils'), // Keep real exports
  slowFunction: jest.fn(() => 'fast') // Mock just this one
}));
```

**Mock default export:**

```javascript
// Module with default export
jest.mock('./api', () => ({
  default: jest.fn(() => 'mocked')
}));

import api from './api';
api(); // 'mocked'
```

**Clearing mocks:**

```javascript
beforeEach(() => {
  jest.clearAllMocks(); // Clear call history
});

afterEach(() => {
  jest.restoreAllMocks(); // Restore original implementations
});
```

---

### 6. Mocking Async Functions

**What it means:**
- Mock promises and async/await
- Control timing and results

**Mock resolved promise:**

```javascript
const mockFetch = jest.fn()
  .mockResolvedValue({ data: 'success' });

// Same as:
const mockFetch = jest.fn(() =>
  Promise.resolve({ data: 'success' })
);

const result = await mockFetch();
expect(result).toEqual({ data: 'success' });
```

**Mock rejected promise:**

```javascript
const mockFetch = jest.fn()
  .mockRejectedValue(new Error('Failed'));

// Same as:
const mockFetch = jest.fn(() =>
  Promise.reject(new Error('Failed'))
);

await expect(mockFetch()).rejects.toThrow('Failed');
```

**Multiple calls:**

```javascript
const mockFetch = jest.fn()
  .mockResolvedValueOnce({ data: 'first' })
  .mockResolvedValueOnce({ data: 'second' })
  .mockRejectedValue(new Error('Failed'));

expect(await mockFetch()).toEqual({ data: 'first' });
expect(await mockFetch()).toEqual({ data: 'second' });
await expect(mockFetch()).rejects.toThrow('Failed');
```

**Practical example:**

```javascript
test('displays fetched user', async () => {
  global.fetch = jest.fn().mockResolvedValue({
    json: () => Promise.resolve({ name: 'John' })
  });
  
  render(<UserProfile userId={1} />);
  
  expect(await screen.findByText('John')).toBeInTheDocument();
  expect(fetch).toHaveBeenCalledWith('/api/users/1');
});

test('shows error on fetch failure', async () => {
  global.fetch = jest.fn().mockRejectedValue(new Error('Network error'));
  
  render(<UserProfile userId={1} />);
  
  expect(await screen.findByText(/error/i)).toBeInTheDocument();
});
```

---

### 7. Mocking Timers

**What it means:**
- Control time in tests
- Fast-forward setTimeout/setInterval
- No real waiting

**Fake timers:**

```javascript
// Enable fake timers
jest.useFakeTimers();

test('callback fires after delay', () => {
  const callback = jest.fn();
  
  setTimeout(callback, 1000);
  
  // No waiting! Just advance time
  jest.advanceTimersByTime(1000);
  
  expect(callback).toHaveBeenCalled();
});

// Restore real timers
jest.useRealTimers();
```

**Run all timers:**

```javascript
jest.useFakeTimers();

test('all timers execute', () => {
  const callback1 = jest.fn();
  const callback2 = jest.fn();
  
  setTimeout(callback1, 100);
  setTimeout(callback2, 500);
  
  // Run all pending timers
  jest.runAllTimers();
  
  expect(callback1).toHaveBeenCalled();
  expect(callback2).toHaveBeenCalled();
});
```

**Run only pending:**

```javascript
jest.useFakeTimers();

test('runs only pending timers', () => {
  const callback = jest.fn(() => {
    // This creates a new timer
    setTimeout(callback, 1000);
  });
  
  setTimeout(callback, 1000);
  
  // Runs only currently pending timers
  jest.runOnlyPendingTimers();
  
  expect(callback).toHaveBeenCalledTimes(1); // Not recursively
});
```

**Practical examples:**

```javascript
test('debounced search', () => {
  jest.useFakeTimers();
  const onSearch = jest.fn();
  
  render(<SearchInput onSearch={onSearch} delay={300} />);
  
  // Type multiple times
  userEvent.type(screen.getByRole('textbox'), 'test');
  
  // Before delay
  expect(onSearch).not.toHaveBeenCalled();
  
  // Fast-forward
  jest.advanceTimersByTime(300);
  
  // Now it should be called
  expect(onSearch).toHaveBeenCalledWith('test');
  
  jest.useRealTimers();
});

test('auto-save after inactivity', () => {
  jest.useFakeTimers();
  const onSave = jest.fn();
  
  render(<Editor onSave={onSave} autoSaveDelay={5000} />);
  
  userEvent.type(screen.getByRole('textbox'), 'content');
  
  // Fast-forward 5 seconds
  jest.advanceTimersByTime(5000);
  
  expect(onSave).toHaveBeenCalledWith('content');
  
  jest.useRealTimers();
});
```

---

### 8. Clearing and Resetting Mocks

**What it means:**
- Clean up mocks between tests
- Ensure test isolation

**clearAllMocks:**

```javascript
// Clears call history but keeps implementation
const mockFn = jest.fn().mockReturnValue(42);

mockFn();
mockFn();
expect(mockFn).toHaveBeenCalledTimes(2);

jest.clearAllMocks();

expect(mockFn).toHaveBeenCalledTimes(0); // Cleared
expect(mockFn()).toBe(42); // Implementation still works
```

**resetAllMocks:**

```javascript
// Clears history AND removes implementation
const mockFn = jest.fn().mockReturnValue(42);

jest.resetAllMocks();

expect(mockFn()).toBeUndefined(); // Implementation gone
```

**restoreAllMocks:**

```javascript
// Restores original implementation (for spies)
const obj = { method: () => 'original' };
jest.spyOn(obj, 'method').mockReturnValue('mocked');

expect(obj.method()).toBe('mocked');

jest.restoreAllMocks();

expect(obj.method()).toBe('original'); // Restored
```

**Best practice:**

```javascript
describe('MyComponent', () => {
  beforeEach(() => {
    jest.clearAllMocks(); // Clear before each test
  });
  
  afterEach(() => {
    jest.restoreAllMocks(); // Restore after each test
  });
  
  test('test 1', () => {
    // Fresh mocks
  });
  
  test('test 2', () => {
    // Fresh mocks
  });
});
```

---

### 9. Mocking Best Practices

**1. Mock at the right level:**

```javascript
// âŒ BAD - Mocking too much
jest.mock('./Component'); // Don't mock what you're testing!

// âœ… GOOD - Mock dependencies
jest.mock('./api'); // Mock external dependencies
```

**2. Keep mocks realistic:**

```javascript
// âŒ BAD - Unrealistic mock
fetchUser.mockResolvedValue({ name: 'User' });

// âœ… GOOD - Realistic structure
fetchUser.mockResolvedValue({
  id: 1,
  name: 'John Doe',
  email: 'john@example.com',
  createdAt: '2024-01-01',
  role: 'user'
});
```

**3. Don't over-mock:**

```javascript
// âŒ BAD - Testing mocks, not real code
jest.mock('./utils');
jest.mock('./helpers');
jest.mock('./components');
// Nothing real left to test!

// âœ… GOOD - Only mock external boundaries
jest.mock('./api'); // External API
// Test everything else for real
```

**4. Clear mocks between tests:**

```javascript
// âœ… Always clear in beforeEach
beforeEach(() => {
  jest.clearAllMocks();
});
```

**5. Use descriptive mock data:**

```javascript
// âŒ BAD - Generic data
const user = { name: 'User', id: 1 };

// âœ… GOOD - Descriptive data
const testUser = {
  id: 123,
  name: 'John Test User',
  email: 'john.testuser@example.com',
  role: 'admin'
};
```

---

### 10. Common Mocking Patterns

**Mock API responses:**

```javascript
// Success
global.fetch = jest.fn().mockResolvedValue({
  ok: true,
  json: () => Promise.resolve({ data: 'success' })
});

// Error
global.fetch = jest.fn().mockResolvedValue({
  ok: false,
  status: 404,
  json: () => Promise.resolve({ error: 'Not found' })
});
```

**Mock localStorage:**

```javascript
const localStorageMock = {
  getItem: jest.fn(),
  setItem: jest.fn(),
  removeItem: jest.fn(),
  clear: jest.fn()
};
global.localStorage = localStorageMock;
```

**Mock Date:**

```javascript
// Mock current time
jest.useFakeTimers();
jest.setSystemTime(new Date('2024-01-01'));

expect(new Date().toISOString()).toBe('2024-01-01T00:00:00.000Z');

jest.useRealTimers();
```

**Mock Math.random:**

```javascript
// Predictable randomness
jest.spyOn(Math, 'random').mockReturnValue(0.5);

expect(Math.random()).toBe(0.5);
expect(Math.random()).toBe(0.5);
```

**Mock window methods:**

```javascript
// Mock window.alert
global.alert = jest.fn();

// Mock window.confirm
global.confirm = jest.fn().mockReturnValue(true);

// Mock window.location
delete window.location;
window.location = { href: 'http://localhost' };
```

---

## ðŸŽ¤ Interview Questions & Model Answers

### Q1: What's the difference between a mock, stub, and spy?

**Answer:**
> "A mock is a complete replacement of a function that I fully control - I define what it returns and can verify how it was called. A stub is similar but focuses on providing predetermined responses with no real logic. A spy wraps the real function, allowing it to execute normally while recording all calls for verification. I use mocks for dependencies like APIs, stubs for simple return values, and spies when I need to verify the real function was called correctly."

---

### Q2: When should you mock and when should you not mock?

**Answer:**
> "I mock external dependencies that are slow, unreliable, or hard to control - like HTTP requests, databases, file systems, and timers. I don't mock the code I'm actually testing, simple utilities, or everything in sight. Over-mocking leads to testing mocks instead of real code, giving false confidence. The goal is to isolate what I'm testing from external factors while keeping the test realistic."

---

### Q3: How do you mock an API call in Jest?

**Answer:**
> "I typically mock the fetch function using `global.fetch = jest.fn()` and configure it to return a resolved promise with the expected data structure. For example: `global.fetch = jest.fn().mockResolvedValue({ json: () => Promise.resolve({ name: 'John' }) })`. This makes the test fast, reliable, and allows me to test different scenarios like errors by using `mockRejectedValue` instead."

---

### Q4: What's the difference between jest.clearAllMocks() and jest.resetAllMocks()?

**Answer:**
> "clearAllMocks clears the call history but keeps the mock implementation, so if I configured mockReturnValue, it still works. resetAllMocks clears history AND removes the implementation, returning mocks to their default undefined behavior. restoreAllMocks goes further by restoring the original implementation for spies. I typically use clearAllMocks in beforeEach to ensure clean state between tests."

---

### Q5: How do you test code that uses setTimeout or setInterval?

**Answer:**
> "I use Jest's fake timers with `jest.useFakeTimers()` to control time in tests. Instead of actually waiting, I can fast-forward time using `jest.advanceTimersByTime(1000)` to jump ahead 1 second, or `jest.runAllTimers()` to execute all pending timers immediately. This makes tests fast and deterministic. I always remember to call `jest.useRealTimers()` after the test to restore normal timing."

---

## ðŸ”‘ Must Know for Interviews

### âœ… Critical (Always Asked)

- âœ… Why mock dependencies
- âœ… jest.fn() for mock functions
- âœ… Mocking async functions (mockResolvedValue/mockRejectedValue)
- âœ… When to mock vs when not to mock

### âœ… Should Know (Often Asked)

- âœ… jest.spyOn() for existing methods
- âœ… Mocking modules with jest.mock()
- âœ… Fake timers for setTimeout/setInterval
- âœ… Clearing mocks between tests

### âœ… Nice to Know (Senior Level)

- [ ] Mock vs stub vs spy differences
- [ ] Partial module mocking
- [ ] Custom mock implementations
- [ ] Mocking Date, Math.random, window methods

---

## ðŸš¨ Common Mistakes

### 1. Mocking What You're Testing

```javascript
// âŒ BAD - Mocking the component you're testing
jest.mock('./Button');
test('button works', () => {
  render(<Button />); // Testing a mock, not real code!
});

// âœ… GOOD - Only mock dependencies
jest.mock('./api');
test('button calls API', () => {
  render(<Button />); // Testing real button
});
```

### 2. Not Clearing Mocks

```javascript
// âŒ BAD - Mocks accumulate
test('test 1', () => {
  mockFn();
  expect(mockFn).toHaveBeenCalledTimes(1);
});

test('test 2', () => {
  mockFn();
  expect(mockFn).toHaveBeenCalledTimes(1); // Fails! Called 2 times
});

// âœ… GOOD - Clear between tests
beforeEach(() => {
  jest.clearAllMocks();
});
```

### 3. Unrealistic Mock Data

```javascript
// âŒ BAD - Doesn't match real API
fetchUser.mockResolvedValue({ name: 'User' });

// âœ… GOOD - Matches real structure
fetchUser.mockResolvedValue({
  id: 1,
  name: 'John Doe',
  email: 'john@example.com',
  role: 'user',
  createdAt: '2024-01-01'
});
```

### 4. Forgetting to Restore Timers

```javascript
// âŒ BAD - Fake timers affect other tests
test('test with timers', () => {
  jest.useFakeTimers();
  // ... test code
  // Forgot jest.useRealTimers()!
});

// âœ… GOOD - Always restore
test('test with timers', () => {
  jest.useFakeTimers();
  // ... test code
  jest.useRealTimers();
});
```

---

## ðŸ’¡ Quick Reference

```javascript
// Create mock function
const mock = jest.fn();
const mock = jest.fn(() => 'value');
const mock = jest.fn().mockReturnValue('value');

// Async mocks
const mock = jest.fn().mockResolvedValue(data);
const mock = jest.fn().mockRejectedValue(error);

// Spy on method
const spy = jest.spyOn(obj, 'method');
spy.mockRestore();

// Mock module
jest.mock('./module');

// Fake timers
jest.useFakeTimers();
jest.advanceTimersByTime(1000);
jest.runAllTimers();
jest.useRealTimers();

// Clear mocks
jest.clearAllMocks();      // Clear history
jest.resetAllMocks();      // Clear history + implementation
jest.restoreAllMocks();    // Restore originals
```