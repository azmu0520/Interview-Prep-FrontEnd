# Test Anatomy

## ğŸ¯ Key Concepts

### 1. Test Structure - describe, test, it

**What it means:**
- `describe` - Groups related tests together
- `test` / `it` - Individual test cases (they're identical)
- Nested `describe` blocks for organization

**Basic Structure:**

```javascript
describe('ComponentName or FeatureName', () => {
  test('does something specific', () => {
    // Test code
  });
  
  test('handles another scenario', () => {
    // Test code
  });
});
```

**The naming convention:**

```javascript
// test() - reads naturally
test('user can submit form', () => {});

// it() - BDD style, reads like a sentence
it('should submit form when valid', () => {});

// Both are identical, choose one style and stick with it
```

**Nested describe blocks:**

```javascript
describe('ShoppingCart', () => {
  describe('when empty', () => {
    test('shows empty message', () => {});
    test('disables checkout button', () => {});
  });
  
  describe('when has items', () => {
    test('shows item count', () => {});
    test('enables checkout button', () => {});
    test('calculates total correctly', () => {});
  });
  
  describe('when item is removed', () => {
    test('updates count', () => {});
    test('updates total', () => {});
  });
});
```

**Why nest?**
- âœ… Logical grouping
- âœ… Easier to read test output
- âœ… Share setup code
- âœ… Run specific groups with `.only()`

**Test Output:**

```
ShoppingCart
  when empty
    âœ“ shows empty message
    âœ“ disables checkout button
  when has items
    âœ“ shows item count
    âœ“ enables checkout button
    âœ“ calculates total correctly
```

---

### 2. beforeEach and afterEach

**What it means:**
- `beforeEach()` - Runs before each test
- `afterEach()` - Runs after each test
- Used for setup and cleanup

**Basic Usage:**

```javascript
describe('UserProfile', () => {
  let user;
  
  // Runs before EACH test
  beforeEach(() => {
    user = {
      id: 1,
      name: 'John Doe',
      email: 'john@example.com'
    };
  });
  
  // Runs after EACH test
  afterEach(() => {
    // Cleanup if needed
    user = null;
  });
  
  test('displays user name', () => {
    render(<UserProfile user={user} />);
    expect(screen.getByText('John Doe')).toBeInTheDocument();
  });
  
  test('displays user email', () => {
    render(<UserProfile user={user} />);
    expect(screen.getByText('john@example.com')).toBeInTheDocument();
  });
});
```

**Why use beforeEach?**
- âœ… Avoid code duplication
- âœ… Ensure fresh state for each test
- âœ… Keep tests independent
- âœ… Clear setup location

**Common beforeEach patterns:**

```javascript
describe('Component tests', () => {
  // Pattern 1: Create test data
  let mockData;
  beforeEach(() => {
    mockData = createMockUser();
  });
  
  // Pattern 2: Setup mocks
  beforeEach(() => {
    jest.clearAllMocks();
    global.fetch = jest.fn();
  });
  
  // Pattern 3: Reset state
  beforeEach(() => {
    localStorage.clear();
    sessionStorage.clear();
  });
  
  // Pattern 4: Common renders
  beforeEach(() => {
    render(<App />);
  });
});
```

**afterEach for cleanup:**

```javascript
describe('Component with side effects', () => {
  afterEach(() => {
    // Clear mocks
    jest.clearAllMocks();
    
    // Clear timers
    jest.clearAllTimers();
    
    // Clear DOM
    cleanup(); // React Testing Library does this automatically
    
    // Restore mocked functions
    jest.restoreAllMocks();
  });
});
```

---

### 3. beforeAll and afterAll

**What it means:**
- `beforeAll()` - Runs once before all tests
- `afterAll()` - Runs once after all tests
- Used for expensive setup/teardown

**When to use:**

```javascript
describe('Database tests', () => {
  // Runs ONCE before all tests
  beforeAll(async () => {
    await database.connect();
    await database.migrate();
  });
  
  // Runs ONCE after all tests
  afterAll(async () => {
    await database.disconnect();
  });
  
  // Runs before EACH test
  beforeEach(async () => {
    await database.clear(); // Fresh data per test
  });
  
  test('creates user', async () => {
    // Database already connected
  });
  
  test('updates user', async () => {
    // Database still connected
  });
});
```

**beforeAll vs beforeEach:**

```javascript
describe('API tests', () => {
  let server;
  
  // âœ… beforeAll - Expensive, shared setup
  beforeAll(() => {
    server = setupMockServer(); // Only create once
    server.listen();
  });
  
  afterAll(() => {
    server.close(); // Cleanup once
  });
  
  // âœ… beforeEach - Fresh state per test
  beforeEach(() => {
    server.resetHandlers(); // Reset per test
  });
  
  test('test 1', () => {});
  test('test 2', () => {});
});
```

**Warning about beforeAll:**

```javascript
// âŒ BAD - Shared mutable state
describe('Tests', () => {
  let counter;
  
  beforeAll(() => {
    counter = 0; // Only initialized once
  });
  
  test('test 1', () => {
    counter++; // Mutates shared state
    expect(counter).toBe(1); // âœ“ Passes
  });
  
  test('test 2', () => {
    counter++;
    expect(counter).toBe(1); // âœ— Fails! counter is 2
  });
});

// âœ… GOOD - Fresh state per test
describe('Tests', () => {
  let counter;
  
  beforeEach(() => {
    counter = 0; // Fresh state each test
  });
  
  test('test 1', () => {
    counter++;
    expect(counter).toBe(1); // âœ“ Passes
  });
  
  test('test 2', () => {
    counter++;
    expect(counter).toBe(1); // âœ“ Passes
  });
});
```

---

### 4. Test Isolation

**What it means:**
- Each test should be independent
- Tests shouldn't depend on each other
- Tests should pass in any order

**The Problem:**

```javascript
// âŒ BAD - Tests depend on each other
describe('Counter', () => {
  let count = 0;
  
  test('increments', () => {
    count++;
    expect(count).toBe(1);
  });
  
  test('increments again', () => {
    count++; // Depends on previous test!
    expect(count).toBe(2); // Fails if run alone
  });
  
  test('doubles', () => {
    count = count * 2; // Depends on previous tests!
    expect(count).toBe(4); // Fails if run alone
  });
});
```

**The Solution:**

```javascript
// âœ… GOOD - Each test is independent
describe('Counter', () => {
  let counter;
  
  beforeEach(() => {
    counter = new Counter(); // Fresh instance
  });
  
  test('starts at zero', () => {
    expect(counter.value).toBe(0);
  });
  
  test('increments from zero', () => {
    counter.increment();
    expect(counter.value).toBe(1);
  });
  
  test('can increment multiple times', () => {
    counter.increment();
    counter.increment();
    expect(counter.value).toBe(2);
  });
});
```

**Why isolation matters:**

```javascript
// Without isolation
describe('Tests', () => {
  test('test A', () => {}); // âœ“ Pass
  test('test B', () => {}); // âœ“ Pass
  test('test C', () => {}); // âœ— Fail (depends on A)
});

// When test C fails:
// - Is bug in C?
// - Is bug in A?
// - Hard to debug!

// With isolation
describe('Tests', () => {
  test('test A', () => {}); // âœ“ Pass
  test('test B', () => {}); // âœ“ Pass
  test('test C', () => {}); // âœ— Fail
});

// When test C fails:
// - Bug is definitely in C
// - Easy to debug!
```

---

### 5. Test Naming Conventions

**What it means:**
- Good names explain what's being tested
- Names should be descriptive, not generic
- Names should read like documentation

**Bad names:**

```javascript
// âŒ Too vague
test('works', () => {});
test('test 1', () => {});
test('button', () => {});
test('renders correctly', () => {});
```

**Good names:**

```javascript
// âœ… Specific and descriptive
test('displays user name in header', () => {});
test('disables submit button when form is invalid', () => {});
test('shows error message when API returns 500', () => {});
test('redirects to login when user is not authenticated', () => {});
```

**Naming patterns:**

```javascript
// Pattern 1: "should" style (BDD)
it('should display error when email is invalid', () => {});
it('should enable button when form is valid', () => {});

// Pattern 2: User action style (recommended)
test('user can submit form with valid data', () => {});
test('user sees error when password is too short', () => {});

// Pattern 3: State/behavior style
test('form is disabled when loading', () => {});
test('modal closes when escape key is pressed', () => {});

// Pattern 4: Given-When-Then (BDD)
test('given empty cart, when user navigates to checkout, then sees empty message', () => {});
```

**Component test naming:**

```javascript
describe('LoginForm', () => {
  // âœ… GOOD - Specific scenarios
  test('submits form with email and password', () => {});
  test('shows error when email is invalid', () => {});
  test('disables submit button while loading', () => {});
  test('shows success message after successful login', () => {});
  
  // âŒ BAD - Too generic
  test('renders', () => {});
  test('works', () => {});
  test('handles submit', () => {});
});
```

**The name should answer:**
1. What is being tested?
2. Under what conditions?
3. What is the expected result?

```javascript
// Template: [Action] [Condition] [Expected Result]
test('submits form when all fields are valid', () => {});
test('shows error when password is too short', () => {});
test('disables button when user is not logged in', () => {});
```

---

### 6. only and skip

**What it means:**
- `.only()` - Run only this test/describe
- `.skip()` - Skip this test/describe
- Useful for debugging

**Using .only():**

```javascript
describe('Feature', () => {
  test('test 1', () => {}); // Skipped
  test('test 2', () => {}); // Skipped
  
  // ONLY this test runs
  test.only('test 3', () => {});
  
  test('test 4', () => {}); // Skipped
});

// Can also use on describe
describe.only('This suite only', () => {
  test('test 1', () => {}); // Runs
  test('test 2', () => {}); // Runs
});

describe('Other suite', () => {
  test('test 3', () => {}); // Skipped
});
```

**Using .skip():**

```javascript
describe('Feature', () => {
  test('test 1', () => {}); // Runs
  
  // Skip this test
  test.skip('test 2', () => {});
  
  test('test 3', () => {}); // Runs
});

// Skip entire suite
describe.skip('Not ready yet', () => {
  test('test 1', () => {}); // Skipped
  test('test 2', () => {}); // Skipped
});
```

**When to use:**

```javascript
// Debugging - focus on failing test
test.only('this one is failing', () => {
  // Debug this one
});

// Work in progress
test.skip('TODO: implement this test', () => {
  // Will implement later
});

// Known issue
test.skip('bug #123: form validation broken', () => {
  // Skip until bug is fixed
});

// Flaky test
test.skip('FLAKY: sometimes fails in CI', () => {
  // Investigate later
});
```

**âš ï¸ Warning:**

```javascript
// âŒ DON'T commit .only() to main branch!
test.only('my test', () => {}); // Other tests won't run in CI!

// Use CI checks to prevent this:
// In CI script: grep -r "\.only(" tests/ && exit 1
```

---

### 7. Test Organization Best Practices

**File structure:**

```javascript
// âœ… GOOD - Clear hierarchy
describe('ShoppingCart', () => {
  describe('Rendering', () => {
    test('displays empty message when no items', () => {});
    test('displays item count when has items', () => {});
  });
  
  describe('Adding items', () => {
    test('increases item count', () => {});
    test('updates total price', () => {});
    test('shows notification', () => {});
  });
  
  describe('Removing items', () => {
    test('decreases item count', () => {});
    test('updates total price', () => {});
    test('shows empty message when last item removed', () => {});
  });
});
```

**One assertion per test?**

```javascript
// Debate: One assertion vs multiple?

// âŒ Too granular
test('renders header', () => {
  render(<Header />);
  expect(screen.getByRole('banner')).toBeInTheDocument();
});

test('header has logo', () => {
  render(<Header />);
  expect(screen.getByAltText(/logo/i)).toBeInTheDocument();
});

test('header has nav', () => {
  render(<Header />);
  expect(screen.getByRole('navigation')).toBeInTheDocument();
});

// âœ… Better - Related assertions together
test('renders header with logo and navigation', () => {
  render(<Header />);
  
  expect(screen.getByRole('banner')).toBeInTheDocument();
  expect(screen.getByAltText(/logo/i)).toBeInTheDocument();
  expect(screen.getByRole('navigation')).toBeInTheDocument();
});

// âŒ Bad - Unrelated assertions
test('form works', () => {
  render(<Form />);
  
  // Unrelated things:
  expect(screen.getByLabelText(/email/i)).toBeInTheDocument();
  fireEvent.submit(form);
  expect(mockFn).toHaveBeenCalled();
  expect(screen.getByText(/success/i)).toBeInTheDocument();
});

// âœ… Better - Split into logical tests
test('renders email input', () => {
  render(<Form />);
  expect(screen.getByLabelText(/email/i)).toBeInTheDocument();
});

test('calls onSubmit when submitted', () => {
  const onSubmit = jest.fn();
  render(<Form onSubmit={onSubmit} />);
  fireEvent.submit(screen.getByRole('form'));
  expect(onSubmit).toHaveBeenCalled();
});

test('shows success message after submission', async () => {
  render(<Form />);
  fireEvent.submit(screen.getByRole('form'));
  expect(await screen.findByText(/success/i)).toBeInTheDocument();
});
```

**Rule of thumb:**
- âœ… Multiple assertions OK if testing same behavior
- âŒ Separate tests for different behaviors
- âœ… If test name needs "and", consider splitting

---

## ğŸ¤ Interview Questions & Model Answers

### Q1: What's the difference between beforeEach and beforeAll?

**Answer:**
> "`beforeEach` runs before every single test, ensuring each test starts with fresh state. This is crucial for test isolation. `beforeAll` runs once before all tests in a describe block, which is useful for expensive setup like database connections or starting a mock server. The key difference is frequency: beforeEach runs N times for N tests, beforeAll runs only once. I use beforeEach for test data and mocks, and beforeAll for expensive resources that can be safely shared."

---

### Q2: Why is test isolation important?

**Answer:**
> "Test isolation ensures each test is independent and can run in any order. Without isolation, tests can affect each other through shared state, making them fragile and hard to debug. If test B fails, you need to know if the bug is in B itself, or if A somehow affected B. Isolated tests make debugging straightforward - when a test fails, the bug is definitely in that test's code. I ensure isolation by using beforeEach for setup, avoiding shared mutable state, and never making tests depend on execution order."

---

### Q3: How do you organize tests in a large codebase?

**Answer:**
> "I use nested describe blocks to create logical hierarchies - typically by component, then by feature or scenario. For example, 'ShoppingCart' describes the component, with nested describes for 'when empty', 'adding items', 'removing items', etc. This makes test output readable and allows me to share setup code within each group. I also co-locate tests with components, so UserProfile.tsx has a UserProfile.test.tsx right next to it. This makes tests easier to find and maintain."

---

### Q4: When would you use .only() or .skip()?

**Answer:**
> ".only() is great for debugging - when I have a failing test, I use .only() to run just that test for faster feedback. .skip() is useful for temporarily disabling flaky tests or tests for features not yet implemented. However, both should be used carefully and never committed to the main branch. We have CI checks to prevent .only() from being merged, as it would cause other tests not to run in CI."

---

### Q5: What makes a good test name?

**Answer:**
> "A good test name is specific and descriptive, reading like documentation. It should explain what's being tested, under what conditions, and what the expected result is. For example, 'shows error when email is invalid' is much better than 'test email'. I avoid generic names like 'works' or 'renders correctly'. The test name should be so clear that if it fails, you immediately understand what broke without reading the code."

---

## ğŸ”‘ Must Know for Interviews

### âœ… Critical

- âœ… describe/test/it structure
- âœ… beforeEach vs beforeAll
- âœ… Test isolation importance
- âœ… Good test naming conventions

### âœ… Should Know

- âœ… afterEach/afterAll for cleanup
- âœ… .only() and .skip() for debugging
- âœ… Nested describe blocks
- âœ… One assertion vs multiple

### âœ… Nice to Know

- [ ] Test execution order
- [ ] Concurrent test execution
- [ ] Test timeouts
- [ ] Custom test utilities

---

## ğŸš¨ Common Mistakes

### 1. Tests Affecting Each Other

```javascript
// âŒ BAD - Shared mutable state
describe('Tests', () => {
  const user = { name: 'John' };
  
  test('test 1', () => {
    user.name = 'Jane'; // Mutates shared object
  });
  
  test('test 2', () => {
    expect(user.name).toBe('John'); // Fails!
  });
});

// âœ… GOOD - Fresh state
describe('Tests', () => {
  let user;
  
  beforeEach(() => {
    user = { name: 'John' }; // New object each test
  });
  
  test('test 1', () => {
    user.name = 'Jane';
    expect(user.name).toBe('Jane');
  });
  
  test('test 2', () => {
    expect(user.name).toBe('John'); // Passes!
  });
});
```

### 2. Using beforeAll for Mutable State

```javascript
// âŒ BAD
describe('Tests', () => {
  let items;
  
  beforeAll(() => {
    items = []; // Only initialized once
  });
  
  test('adds item', () => {
    items.push('a');
    expect(items).toHaveLength(1);
  });
  
  test('is empty', () => {
    expect(items).toHaveLength(0); // Fails! items has 'a'
  });
});

// âœ… GOOD
describe('Tests', () => {
  let items;
  
  beforeEach(() => {
    items = []; // Fresh array each test
  });
  
  test('adds item', () => {
    items.push('a');
    expect(items).toHaveLength(1);
  });
  
  test('is empty', () => {
    expect(items).toHaveLength(0); // Passes!
  });
});
```

### 3. Vague Test Names

```javascript
// âŒ BAD
test('button', () => {});
test('works', () => {});
test('test 1', () => {});
test('renders', () => {});

// âœ… GOOD
test('submit button is disabled when form is invalid', () => {});
test('form validation works for email field', () => {});
test('displays user profile after successful login', () => {});
test('renders product list with correct prices', () => {});
```

### 4. Too Many Nested Describes

```javascript
// âŒ BAD - Over-nested
describe('App', () => {
  describe('Header', () => {
    describe('Navigation', () => {
      describe('Links', () => {
        describe('Home Link', () => {
          test('renders', () => {}); // Too deep!
        });
      });
    });
  });
});

// âœ… GOOD - Reasonable nesting
describe('Header Navigation', () => {
  test('renders home link', () => {});
  test('renders about link', () => {});
  test('highlights active link', () => {});
});
```

---

## ğŸ’¡ Key Takeaways

1. **Use describe to group related tests** - creates logical hierarchy
2. **beforeEach for test isolation** - fresh state every test
3. **beforeAll for expensive setup** - database connections, servers
4. **Each test should be independent** - can run in any order
5. **Good names are documentation** - specific and descriptive
6. **Use .only() for debugging** - but never commit it
7. **Use .skip() temporarily** - for WIP or flaky tests
8. **Cleanup in afterEach** - clear mocks, timers, DOM

---

## ğŸ“ Quick Reference

```javascript
// Test structure
describe('Component', () => {
  beforeAll(() => {/* Once before all tests */});
  afterAll(() => {/* Once after all tests */});
  
  beforeEach(() => {/* Before each test */});
  afterEach(() => {/* After each test */});
  
  test('does something', () => {
    // Arrange
    // Act
    // Assert
  });
  
  test.only('debug this', () => {});
  test.skip('not ready yet', () => {});
});
```