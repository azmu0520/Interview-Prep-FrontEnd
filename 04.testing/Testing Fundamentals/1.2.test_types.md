# Types of Tests

## ğŸ¯ Key Concepts

### 1. Unit Tests

**What it means:**

- Test individual functions, components, or modules in isolation
- No dependencies on other code
- Fast and focused
- Many of these in your test suite

**Characteristics:**

- âœ… Test one thing at a time
- âœ… Fast execution (< 10ms each)
- âœ… No external dependencies
- âœ… Easy to debug when they fail
- âŒ Lower confidence than integration tests

**Example:**

```javascript
// Pure function - PERFECT for unit testing
function calculateTotal(items) {
  return items.reduce((sum, item) => sum + item.price * item.quantity, 0);
}

// Unit test
describe("calculateTotal", () => {
  test("calculates total for multiple items", () => {
    const items = [
      { price: 10, quantity: 2 },
      { price: 5, quantity: 3 },
    ];
    expect(calculateTotal(items)).toBe(35);
  });

  test("returns 0 for empty array", () => {
    expect(calculateTotal([])).toBe(0);
  });

  test("handles single item", () => {
    expect(calculateTotal([{ price: 10, quantity: 1 }])).toBe(10);
  });
});
```

**When to write unit tests:**

- âœ… Pure functions and utilities
- âœ… Complex business logic
- âœ… Algorithms and calculations
- âœ… Validators and formatters
- âœ… Custom hooks with complex logic

**When NOT to write unit tests:**

- âŒ Simple components with no logic
- âŒ Code that just calls other code
- âŒ Trivial getters/setters

---

### 2. Integration Tests

**What it means:**

- Test multiple units working together
- Test realistic user scenarios
- May involve multiple components, hooks, and state
- The **sweet spot** for frontend testing

**Characteristics:**

- âœ… Test component integration
- âœ… More realistic than unit tests
- âœ… Catch more real bugs
- âœ… Reasonably fast (< 100ms each)
- âœ… Best confidence-to-speed ratio

**Example:**

```javascript
// Integration test - Multiple components working together
test("user can add item to shopping cart", async () => {
  const user = userEvent.setup();

  // Render entire feature
  render(<ShoppingApp />);

  // User flow across multiple components
  const productCard = screen.getByRole("article", { name: /laptop/i });
  const addButton = within(productCard).getByRole("button", {
    name: /add to cart/i,
  });

  await user.click(addButton);

  // Verify cart updated
  expect(screen.getByText(/1 item in cart/i)).toBeInTheDocument();

  // Navigate to cart
  await user.click(screen.getByRole("link", { name: /cart/i }));

  // Verify item appears in cart
  expect(screen.getByRole("heading", { name: /laptop/i })).toBeInTheDocument();
});
```

**What makes it integration:**

- Tests multiple components (ProductCard, Cart, CartButton)
- Tests state management across components
- Tests routing between pages
- Tests complete user workflow

**When to write integration tests:**

- âœ… User workflows (most common!)
- âœ… Features that span multiple components
- âœ… Forms with validation and submission
- âœ… Data fetching and display
- âœ… Navigation and routing

---

### 3. End-to-End (E2E) Tests

**What it means:**

- Test entire application in real browser
- From user's perspective, no mocking
- Tests complete user journeys
- Slowest and most expensive

**Characteristics:**

- âœ… Highest confidence
- âœ… Tests real browser behavior
- âœ… Catches integration issues between frontend/backend
- âŒ Slow (seconds per test)
- âŒ Flaky (network, timing issues)
- âŒ Expensive to maintain

**Example (Playwright):**

```javascript
// E2E test - Real browser, real backend
test("user can complete purchase flow", async ({ page }) => {
  // Start at home page
  await page.goto("https://myapp.com");

  // Browse and add product
  await page.click("text=Browse Products");
  await page.click('button:has-text("Add to Cart")');

  // Go to checkout
  await page.click('a:has-text("Cart")');
  await page.click('button:has-text("Checkout")');

  // Fill shipping form
  await page.fill('input[name="name"]', "John Doe");
  await page.fill('input[name="address"]', "123 Main St");
  await page.fill('input[name="city"]', "New York");

  // Fill payment (using test card)
  await page.fill('input[name="cardNumber"]', "4242424242424242");
  await page.fill('input[name="expiry"]', "12/25");
  await page.fill('input[name="cvv"]', "123");

  // Submit order
  await page.click('button:has-text("Place Order")');

  // Verify success
  await expect(page.locator("h1")).toContainText("Order Confirmed");
  await expect(page.locator(".order-number")).toBeVisible();
});
```

**When to write E2E tests:**

- âœ… Critical user flows (checkout, signup, login)
- âœ… Happy path of main features
- âœ… Flows that involve backend
- âœ… Cross-browser compatibility checks

**When NOT to write E2E tests:**

- âŒ Every user interaction (too slow)
- âŒ Edge cases (use integration tests)
- âŒ Unit logic (use unit tests)
- âŒ Error handling (use integration tests with mocked errors)

---

### 4. Smoke Tests

**What it means:**

- Quick tests to verify basic functionality
- "Is the app on fire?" checks
- Run after deployment
- Subset of critical E2E tests

**Example:**

```javascript
// Smoke tests - Quick sanity checks
describe("Smoke Tests", () => {
  test("app loads without crashing", async ({ page }) => {
    await page.goto("https://myapp.com");
    await expect(page.locator("h1")).toBeVisible();
  });

  test("can navigate to main pages", async ({ page }) => {
    await page.goto("https://myapp.com");
    await page.click('a:has-text("About")');
    await expect(page).toHaveURL(/.*about/);

    await page.click('a:has-text("Products")');
    await expect(page).toHaveURL(/.*products/);
  });

  test("API is responding", async ({ page }) => {
    await page.goto("https://myapp.com/products");
    // Wait for products to load
    await expect(page.locator(".product-card").first()).toBeVisible();
  });
});
```

**When to use:**

- âœ… After deployment (production checks)
- âœ… Monitoring in production
- âœ… Quick PR checks before full test suite
- âœ… Verify critical paths still work

---

### 5. Regression Tests

**What it means:**

- Tests that prevent old bugs from coming back
- Written when a bug is found
- Ensure bug stays fixed

**Example:**

```javascript
// Regression test for bug #1234
test("bug #1234: date picker should not allow past dates", async () => {
  const user = userEvent.setup();
  render(<BookingForm />);

  const datePicker = screen.getByLabelText(/select date/i);

  // Try to select yesterday
  const yesterday = new Date();
  yesterday.setDate(yesterday.getDate() - 1);

  await user.click(datePicker);
  await user.type(datePicker, yesterday.toISOString().split("T")[0]);

  // Should show error
  expect(screen.getByText(/past dates not allowed/i)).toBeInTheDocument();

  // Submit button should be disabled
  expect(screen.getByRole("button", { name: /submit/i })).toBeDisabled();
});
```

**Best practice:**

```javascript
// Add bug number to test name for tracking
test("bug #1234: user cannot submit empty form", () => {
  // Reproduces the bug that was fixed
});
```

---

### 6. Visual Regression Tests

**What it means:**

- Compare screenshots to catch unintended UI changes
- Automated visual diffing
- Requires manual approval for changes

**Tools:**

- Percy
- Chromatic
- BackstopJS
- Playwright screenshots

**Example (Playwright):**

```javascript
test("homepage looks correct", async ({ page }) => {
  await page.goto("https://myapp.com");

  // Take screenshot
  await expect(page).toHaveScreenshot("homepage.png");
  // First run: saves baseline
  // Subsequent runs: compares to baseline
});

test("responsive design on mobile", async ({ page }) => {
  await page.setViewportSize({ width: 375, height: 667 });
  await page.goto("https://myapp.com");

  await expect(page).toHaveScreenshot("homepage-mobile.png");
});
```

**When to use:**

- âœ… Component libraries
- âœ… Design systems
- âœ… Marketing pages (where visual matters)
- âœ… Cross-browser visual differences

---

### 7. Performance Tests

**What it means:**

- Measure and assert on performance metrics
- Prevent performance regressions
- Test render times, bundle sizes, etc.

**Example:**

```javascript
import { render } from "@testing-library/react";
import { performance } from "perf_hooks";

test("large list renders in under 100ms", () => {
  const items = Array.from({ length: 1000 }, (_, i) => ({
    id: i,
    name: `Item ${i}`,
  }));

  const start = performance.now();
  render(<LargeList items={items} />);
  const end = performance.now();

  const renderTime = end - start;
  expect(renderTime).toBeLessThan(100);
});

test("component does not cause unnecessary re-renders", () => {
  const renderSpy = jest.fn();

  function TrackedComponent({ value }) {
    renderSpy();
    return <div>{value}</div>;
  }

  const { rerender } = render(<TrackedComponent value="initial" />);
  expect(renderSpy).toHaveBeenCalledTimes(1);

  // Rerender with same value
  rerender(<TrackedComponent value="initial" />);
  expect(renderSpy).toHaveBeenCalledTimes(1); // Should not re-render!
});
```

---

### 8. Accessibility (A11y) Tests

**What it means:**

- Test for accessibility violations
- Ensure app is usable by everyone
- Automated tools catch many issues

**Example:**

```javascript
import { axe, toHaveNoViolations } from "jest-axe";

expect.extend(toHaveNoViolations);

test("form has no accessibility violations", async () => {
  const { container } = render(<LoginForm />);

  const results = await axe(container);
  expect(results).toHaveNoViolations();
});

test("supports keyboard navigation", async () => {
  const user = userEvent.setup();
  render(<Menu />);

  const firstItem = screen.getByRole("menuitem", { name: /home/i });
  firstItem.focus();

  // Tab through menu
  await user.keyboard("{Tab}");
  expect(screen.getByRole("menuitem", { name: /about/i })).toHaveFocus();

  // Arrow keys work
  await user.keyboard("{ArrowDown}");
  expect(screen.getByRole("menuitem", { name: /contact/i })).toHaveFocus();
});
```

---

## ğŸ¯ The Ideal Test Distribution

```
Your Test Suite:

ğŸ“Š Static Analysis (TypeScript, ESLint)     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ 40%
ğŸ§ª Integration Tests                        â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ 30%
âš¡ Unit Tests                                â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ 20%
ğŸŒ E2E Tests (Critical Paths)               â–ˆâ–ˆ 5%
ğŸ‘ï¸ Visual Regression                        â–ˆâ–ˆ 5%
```

---

## ğŸ¤ Interview Questions & Model Answers

### Q1: What's the difference between unit and integration tests?

**Answer:**

> "Unit tests verify individual functions or components in isolation, with all dependencies mocked. They're fast but provide lower confidence. Integration tests verify multiple units working together in realistic scenarios. For example, a unit test might verify a function calculates a total correctly, while an integration test would verify the entire checkout flow from adding items to cart through payment confirmation. I focus more on integration tests because they catch real bugs while still being fast enough to run frequently."

---

### Q2: When would you write E2E tests vs integration tests?

**Answer:**

> "I use E2E tests only for critical user flows that must work in production - like checkout, signup, or login. These run in a real browser against the real backend, giving maximum confidence but they're slow and can be flaky. For most features, I use integration tests because they're 10-100x faster, less flaky, and still test realistic scenarios. The key difference is E2E tests everything including the backend, while integration tests mock the API layer."

---

### Q3: What are smoke tests and when do you use them?

**Answer:**

> "Smoke tests are quick sanity checks to verify the app isn't completely broken. I run them after deployment to production or as a fast pre-check before running the full suite. They might verify the app loads, main pages are accessible, and critical APIs respond. They're a subset of your E2E tests, focusing on 'is anything on fire?' rather than comprehensive coverage."

---

### Q4: How do you decide what type of test to write?

**Answer:**

> "I follow this decision tree: For pure functions and utilities, I write unit tests. For user interactions and features involving multiple components, I write integration tests - this is my default. For critical user flows that need backend verification, I write E2E tests. I also add regression tests when fixing bugs to prevent them from coming back. The goal is maximum confidence with minimum maintenance cost."

---

### Q5: What's your test distribution philosophy?

**Answer:**

> "I follow the testing trophy: mostly integration tests (60-70%), some unit tests for complex logic (20-30%), and few E2E tests for critical paths (5-10%). I also rely heavily on static analysis like TypeScript which prevents many errors at compile time. This distribution gives me the best balance of confidence, speed, and maintainability."

---

## ğŸ”‘ Must Know for Interviews

### âœ… Critical

- âœ… Difference between unit, integration, and E2E
- âœ… When to use each type
- âœ… Testing trophy distribution
- âœ… Integration tests are the sweet spot

### âœ… Should Know

- âœ… Smoke tests for deployment verification
- âœ… Regression tests for bug prevention
- âœ… Visual regression basics
- âœ… A11y testing fundamentals

### âœ… Nice to Know

- [ ] Performance testing strategies
- [ ] Contract testing for APIs
- [ ] Mutation testing
- [ ] Fuzz testing

---

## ğŸ“Š Quick Reference Table

| Test Type       | Speed       | Confidence     | When to Use              | Quantity  |
| --------------- | ----------- | -------------- | ------------------------ | --------- |
| **Unit**        | âš¡âš¡âš¡ Fast | ğŸ”µ Low         | Pure functions, utils    | Many      |
| **Integration** | âš¡âš¡ Medium | ğŸŸ¢ High        | User workflows, features | Most      |
| **E2E**         | âš¡ Slow     | ğŸŸ¢ğŸŸ¢ Very High | Critical paths           | Few       |
| **Smoke**       | âš¡âš¡âš¡ Fast | ğŸ”µ Low         | Post-deployment          | Handful   |
| **Visual**      | âš¡âš¡ Medium | ğŸŸ¡ Medium      | UI components            | As needed |
| **A11y**        | âš¡âš¡ Medium | ğŸŸ¢ High        | All components           | All       |

---

## ğŸš¨ Common Mistakes

### 1. Writing Too Many Unit Tests

```javascript
// âŒ Over-testing simple code
test("getName returns name", () => {
  expect(user.getName()).toBe(user.name); // Trivial!
});

// âœ… Focus on behavior
test("displays user name in header", () => {
  render(<Header user={user} />);
  expect(screen.getByText(user.name)).toBeInTheDocument();
});
```

### 2. E2E Tests for Everything

```javascript
// âŒ E2E test for simple validation (too slow)
test("validates email format", async ({ page }) => {
  await page.goto("https://myapp.com/signup");
  await page.fill('input[name="email"]', "invalid");
  await page.click('button:has-text("Submit")');
  await expect(page.locator(".error")).toContainText("Invalid email");
});

// âœ… Integration test (100x faster)
test("validates email format", async () => {
  render(<SignupForm />);
  await userEvent.type(screen.getByLabelText(/email/i), "invalid");
  await userEvent.click(screen.getByRole("button", { name: /submit/i }));
  expect(screen.getByText(/invalid email/i)).toBeInTheDocument();
});
```

### 3. Not Testing Integration

```javascript
// âŒ Only testing pieces separately
test("button calls onClick", () => {
  const onClick = jest.fn();
  render(<Button onClick={onClick} />);
  fireEvent.click(screen.getByRole("button"));
  expect(onClick).toHaveBeenCalled();
});

test("form updates state", () => {
  // Test form alone
});

// âœ… Test them working together
test("clicking submit button submits form", async () => {
  const handleSubmit = jest.fn();
  render(<FormWithButton onSubmit={handleSubmit} />);
  await userEvent.type(screen.getByLabelText(/name/i), "John");
  await userEvent.click(screen.getByRole("button", { name: /submit/i }));
  expect(handleSubmit).toHaveBeenCalledWith({ name: "John" });
});
```

---

## ğŸ’¡ Key Takeaways

1. **Integration tests are your best friend** - they're the sweet spot
2. **Unit tests for pure functions** - not for components
3. **E2E tests for critical paths only** - they're slow and flaky
4. **Test distribution: 70% integration, 20% unit, 10% E2E**
5. **Smoke tests catch deployment issues** - run them in production
6. **Every bug becomes a regression test** - prevent it from coming back
7. **Visual tests for component libraries** - catch unintended UI changes
8. **A11y tests for everyone** - accessibility is not optional
