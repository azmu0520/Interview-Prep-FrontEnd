# Assertions & Matchers

## üéØ Key Concepts

### 1. The expect() Function

**What it means:**

- `expect()` creates an assertion
- You pass the actual value to expect
- Chain matchers to define expected behavior
- Tests fail if expectation not met

**Basic syntax:**

```javascript
expect(actualValue).matcher(expectedValue);
```

**Examples:**

```javascript
expect(2 + 2).toBe(4);
expect(user.name).toBe("John");
expect(items).toHaveLength(3);
expect(screen.getByText(/hello/i)).toBeInTheDocument();
```

**The flow:**

```javascript
// 1. Get actual value
const result = calculate(5, 3);

// 2. Create expectation
expect(result)
  // 3. Assert with matcher
  .toBe(8);

// If result !== 8, test fails with clear error message
```

---

### 2. toBe vs toEqual (CRITICAL!)

**What it means:**

- `toBe` uses `Object.is()` - checks reference equality (===)
- `toEqual` checks deep value equality
- **Most common mistake in testing**

**toBe - Reference Equality:**

```javascript
// ‚úÖ GOOD - Primitives
expect(5).toBe(5);
expect("hello").toBe("hello");
expect(true).toBe(true);
expect(null).toBe(null);
expect(undefined).toBe(undefined);

// ‚ùå FAILS - Objects (different references)
expect({ name: "John" }).toBe({ name: "John" }); // ‚úó Different objects!
expect([1, 2, 3]).toBe([1, 2, 3]); // ‚úó Different arrays!

// ‚úÖ PASSES - Same reference
const user = { name: "John" };
const sameUser = user;
expect(user).toBe(sameUser); // ‚úì Same reference
```

**toEqual - Deep Value Equality:**

```javascript
// ‚úÖ GOOD - Objects and arrays
expect({ name: "John", age: 30 }).toEqual({ name: "John", age: 30 });
expect([1, 2, 3]).toEqual([1, 2, 3]);

// Works with nested objects
expect({
  user: { name: "John", address: { city: "NYC" } },
}).toEqual({
  user: { name: "John", address: { city: "NYC" } },
});

// ‚úÖ Also works with primitives
expect(5).toEqual(5);
expect("hello").toEqual("hello");
```

**When to use which:**

```javascript
// Primitives: Either works, toBe preferred
expect(count).toBe(5);

// Objects/Arrays: Use toEqual
expect(user).toEqual({ name: "John", age: 30 });
expect(items).toEqual(["a", "b", "c"]);

// Checking same reference: Use toBe
expect(returnedUser).toBe(originalUser);

// null/undefined: Use toBe
expect(value).toBe(null);
expect(value).toBe(undefined);
```

**Interview Gold:**

> "toBe checks reference equality using Object.is(), so it only works for primitives or checking if two variables point to the same object. toEqual does deep comparison, checking if the values inside objects or arrays are equal, which is what you usually want when testing."

---

### 3. Truthiness Matchers

**What it means:**

- Check if values are truthy or falsy
- Different matchers for different needs

**The matchers:**

```javascript
// toBeTruthy - anything that's truthy
expect(true).toBeTruthy();
expect(1).toBeTruthy();
expect("hello").toBeTruthy();
expect([]).toBeTruthy(); // Empty array is truthy!
expect({}).toBeTruthy(); // Empty object is truthy!

// toBeFalsy - anything that's falsy
expect(false).toBeFalsy();
expect(0).toBeFalsy();
expect("").toBeFalsy();
expect(null).toBeFalsy();
expect(undefined).toBeFalsy();
expect(NaN).toBeFalsy();

// toBe(true) - EXACTLY true
expect(true).toBe(true);
expect(1).toBe(true); // ‚úó Fails! 1 is truthy but not true

// toBe(false) - EXACTLY false
expect(false).toBe(false);
expect(0).toBe(false); // ‚úó Fails! 0 is falsy but not false

// toBeNull - null only
expect(null).toBeNull();
expect(undefined).toBeNull(); // ‚úó Fails

// toBeUndefined - undefined only
expect(undefined).toBeUndefined();
expect(null).toBeUndefined(); // ‚úó Fails

// toBeDefined - not undefined
expect(0).toBeDefined();
expect("").toBeDefined();
expect(null).toBeDefined(); // null is defined!
```

**Common mistake:**

```javascript
// ‚ùå BAD - Too loose
expect(value).toBeTruthy(); // Passes for 1, 'hello', [], {}, etc.

// ‚úÖ GOOD - Explicit
expect(value).toBe(true); // Only passes for actual true
```

**When to use:**

```javascript
// Checking if variable exists
expect(user).toBeDefined(); // Better than checking for undefined

// Checking boolean logic
expect(isLoggedIn).toBe(true); // Better than toBeTruthy

// Checking for null/undefined
expect(error).toBeNull(); // Better than toBeFalsy
expect(data).toBeDefined(); // Better than toBeTruthy
```

---

### 4. Number Matchers

**What it means:**

- Special matchers for numeric comparisons
- Handle floating point precision

**Comparison matchers:**

```javascript
// Greater/Less than
expect(score).toBeGreaterThan(50);
expect(score).toBeGreaterThanOrEqual(100);
expect(age).toBeLessThan(18);
expect(age).toBeLessThanOrEqual(65);

// Practical examples
test("user must be adult", () => {
  expect(user.age).toBeGreaterThanOrEqual(18);
});

test("discount cannot exceed 100%", () => {
  expect(discount).toBeLessThanOrEqual(100);
});
```

**Floating point - toBeCloseTo:**

```javascript
// ‚ùå BAD - Floating point precision issues
expect(0.1 + 0.2).toBe(0.3); // ‚úó Fails! 0.1 + 0.2 = 0.30000000000000004

// ‚úÖ GOOD - Use toBeCloseTo
expect(0.1 + 0.2).toBeCloseTo(0.3); // ‚úì Passes

// toBeCloseTo(expected, precision)
expect(0.1 + 0.2).toBeCloseTo(0.3, 5); // Within 5 decimal places

// Practical example
test("calculates tax correctly", () => {
  const price = 19.99;
  const tax = price * 0.08;
  expect(tax).toBeCloseTo(1.6, 2); // $1.60 (2 decimal places)
});
```

**NaN matcher:**

```javascript
expect(NaN).toBeNaN();
expect(0 / 0).toBeNaN();
expect(parseInt("invalid")).toBeNaN();

// Check if NOT NaN
expect(5).not.toBeNaN();
```

---

### 5. String Matchers

**What it means:**

- Test string content and patterns
- Support regex for flexibility

**String content:**

```javascript
// Exact match
expect(message).toBe("Hello, World!");

// Contains substring
expect(message).toContain("World");
expect(email).toContain("@example.com");

// Regex matching
expect(message).toMatch(/hello/i); // Case insensitive
expect(email).toMatch(/^[\w-]+@[\w-]+\.\w+$/); // Email pattern
expect(phone).toMatch(/^\d{3}-\d{3}-\d{4}$/); // Phone pattern

// Starts/ends with
expect(url).toMatch(/^https:\/\//); // Starts with https://
expect(filename).toMatch(/\.pdf$/); // Ends with .pdf
```

**Practical examples:**

```javascript
test("error message is descriptive", () => {
  expect(errorMessage).toContain("Invalid email address");
});

test("formats phone number correctly", () => {
  const formatted = formatPhone("5551234567");
  expect(formatted).toMatch(/^\(\d{3}\) \d{3}-\d{4}$/);
  expect(formatted).toBe("(555) 123-4567");
});

test("validates email format", () => {
  expect(user.email).toMatch(/^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$/);
});
```

---

### 6. Array and Object Matchers

**Array matchers:**

```javascript
const items = ["apple", "banana", "orange"];

// Length
expect(items).toHaveLength(3);

// Contains item
expect(items).toContain("banana");

// Contains items matching (objects)
const users = [
  { id: 1, name: "John" },
  { id: 2, name: "Jane" },
];
expect(users).toContainEqual({ id: 1, name: "John" });

// Every item matches
expect([2, 4, 6]).toEqual(expect.arrayContaining([2, 4]));
```

**Object matchers:**

```javascript
const user = {
  id: 1,
  name: "John",
  email: "john@example.com",
  age: 30,
};

// Has property
expect(user).toHaveProperty("name");
expect(user).toHaveProperty("name", "John"); // With value

// Nested property
expect(user).toHaveProperty("address.city", "NYC");

// Partial match (subset of properties)
expect(user).toMatchObject({
  name: "John",
  email: "john@example.com",
  // age not checked
});

// Exact match
expect(user).toEqual({
  id: 1,
  name: "John",
  email: "john@example.com",
  age: 30,
});
```

**Practical examples:**

```javascript
test("response contains required fields", () => {
  expect(response).toHaveProperty("data");
  expect(response).toHaveProperty("status", 200);
  expect(response).toHaveProperty("headers");
});

test("user object has correct structure", () => {
  expect(user).toMatchObject({
    id: expect.any(Number),
    name: expect.any(String),
    email: expect.stringMatching(/@/),
    createdAt: expect.any(Date),
  });
});
```

---

### 7. Negation with .not

**What it means:**

- Negate any matcher
- Assert something is NOT true

**Examples:**

```javascript
// Basic negation
expect(value).not.toBe(null);
expect(items).not.toHaveLength(0);
expect(message).not.toContain("error");

// DOM assertions
expect(screen.queryByText(/error/i)).not.toBeInTheDocument();
expect(button).not.toBeDisabled();
expect(input).not.toHaveValue("");

// Practical examples
test("valid input has no error", () => {
  render(<Input value="valid@email.com" />);
  expect(screen.queryByText(/invalid/i)).not.toBeInTheDocument();
});

test("submitted form clears input", () => {
  // After submission
  expect(screen.getByLabelText(/email/i)).not.toHaveValue();
});
```

**Common patterns:**

```javascript
// Check element doesn't exist
expect(screen.queryByText(/loading/i)).not.toBeInTheDocument();

// Check array is not empty
expect(items).not.toHaveLength(0);

// Check not null/undefined
expect(user).not.toBeNull();
expect(data).not.toBeUndefined();
```

---

### 8. Async Matchers (resolves/rejects)

**What it means:**

- Test promises
- Built-in async support

**Resolves matcher:**

```javascript
// Promise resolves successfully
await expect(fetchUser()).resolves.toEqual({ name: "John" });

// Shorthand for:
const user = await fetchUser();
expect(user).toEqual({ name: "John" });

// Multiple assertions
await expect(fetchData()).resolves.toMatchObject({
  status: "success",
  data: expect.any(Array),
});
```

**Rejects matcher:**

```javascript
// Promise rejects
await expect(fetchInvalidUser()).rejects.toThrow();

// With specific error message
await expect(fetchInvalidUser()).rejects.toThrow("User not found");

// With error type
await expect(fetchInvalidUser()).rejects.toThrow(NotFoundError);

// Shorthand for:
try {
  await fetchInvalidUser();
  fail("Should have thrown");
} catch (error) {
  expect(error.message).toBe("User not found");
}
```

**Practical examples:**

```javascript
test("fetches user successfully", async () => {
  await expect(api.getUser(1)).resolves.toEqual({
    id: 1,
    name: "John",
    email: "john@example.com",
  });
});

test("throws error for invalid user ID", async () => {
  await expect(api.getUser(-1)).rejects.toThrow("Invalid user ID");
});

test("API returns proper error format", async () => {
  await expect(api.getUser(999)).rejects.toMatchObject({
    status: 404,
    message: "User not found",
  });
});
```

---

### 9. Function/Mock Matchers

**What it means:**

- Assert on mock function calls
- Verify function behavior

**Basic mock assertions:**

```javascript
const mockFn = jest.fn();

// Was called?
expect(mockFn).toHaveBeenCalled();
expect(mockFn).not.toHaveBeenCalled();

// Called how many times?
expect(mockFn).toHaveBeenCalledTimes(3);

// Called with specific arguments?
expect(mockFn).toHaveBeenCalledWith("arg1", "arg2");

// Called with (any call, not necessarily last)?
expect(mockFn).toHaveBeenCalledWith(expect.anything());

// Last call
expect(mockFn).toHaveBeenLastCalledWith("last", "args");

// Nth call
expect(mockFn).toHaveNthBeenCalledWith(2, "second", "call");
```

**Practical examples:**

```javascript
test("onClick handler is called", async () => {
  const handleClick = jest.fn();
  render(<Button onClick={handleClick}>Click me</Button>);

  await userEvent.click(screen.getByRole("button"));

  expect(handleClick).toHaveBeenCalledTimes(1);
});

test("submits form with correct data", async () => {
  const handleSubmit = jest.fn();
  render(<Form onSubmit={handleSubmit} />);

  await userEvent.type(screen.getByLabelText(/email/i), "test@example.com");
  await userEvent.click(screen.getByRole("button", { name: /submit/i }));

  expect(handleSubmit).toHaveBeenCalledWith({
    email: "test@example.com",
  });
});

test("callback called multiple times", async () => {
  const onUpdate = jest.fn();
  render(<LiveUpdate onUpdate={onUpdate} />);

  // Wait for multiple updates
  await waitFor(() => {
    expect(onUpdate).toHaveBeenCalledTimes(3);
  });
});
```

---

### 10. React Testing Library Matchers

**What it means:**

- Special matchers for DOM testing
- From @testing-library/jest-dom

**Document matchers:**

```javascript
// Element in document?
expect(element).toBeInTheDocument();
expect(element).not.toBeInTheDocument();

// Visible to user?
expect(element).toBeVisible();
expect(element).not.toBeVisible();

// Empty?
expect(element).toBeEmptyDOMElement();
```

**Content matchers:**

```javascript
// Text content
expect(element).toHaveTextContent("Hello");
expect(element).toHaveTextContent(/hello/i);

// Value (inputs)
expect(input).toHaveValue("text");
expect(input).toHaveValue(5); // number input

// Display value (select, input)
expect(select).toHaveDisplayValue("Option 1");
```

**Attribute matchers:**

```javascript
// Has attribute
expect(element).toHaveAttribute("href", "/home");
expect(element).toHaveAttribute("disabled");

// CSS class
expect(element).toHaveClass("active");
expect(element).toHaveClass("btn", "btn-primary");

// Style
expect(element).toHaveStyle({ color: "red" });
expect(element).toHaveStyle(`
  display: flex;
  color: red;
`);
```

**State matchers:**

```javascript
// Disabled/enabled
expect(button).toBeDisabled();
expect(button).toBeEnabled();

// Checked (checkboxes/radios)
expect(checkbox).toBeChecked();
expect(checkbox).not.toBeChecked();

// Required
expect(input).toBeRequired();

// Invalid
expect(input).toBeInvalid();
expect(input).toBeValid();

// Focus
expect(input).toHaveFocus();
```

**Practical examples:**

```javascript
test("form validation shows errors", async () => {
  render(<LoginForm />);

  await userEvent.click(screen.getByRole("button", { name: /submit/i }));

  expect(screen.getByText(/email is required/i)).toBeInTheDocument();
  expect(screen.getByLabelText(/email/i)).toBeInvalid();
});

test("disabled state is correct", () => {
  render(<Button disabled>Submit</Button>);

  const button = screen.getByRole("button");
  expect(button).toBeDisabled();
  expect(button).toHaveAttribute("disabled");
});

test("checkbox toggles correctly", async () => {
  render(<Checkbox />);

  const checkbox = screen.getByRole("checkbox");
  expect(checkbox).not.toBeChecked();

  await userEvent.click(checkbox);
  expect(checkbox).toBeChecked();
});
```

---

## üé§ Interview Questions & Model Answers

### Q1: What's the difference between toBe and toEqual?

**Answer:**

> "toBe uses Object.is() to check reference equality, like ===. It works for primitives, but for objects and arrays, it only passes if they're the exact same reference. toEqual does deep comparison, checking if the values inside are equal. So for primitives, either works, but for objects and arrays, you need toEqual. For example, `expect([1,2]).toBe([1,2])` fails because they're different arrays, but `expect([1,2]).toEqual([1,2])` passes because the contents match."

---

### Q2: When would you use toBeCloseTo instead of toBe for numbers?

**Answer:**

> "toBeCloseTo is essential for floating-point arithmetic because of precision issues. For example, `0.1 + 0.2` doesn't exactly equal `0.3` due to how JavaScript handles decimals‚Äîit's actually 0.30000000000000004. So `expect(0.1 + 0.2).toBe(0.3)` fails, but `toBeCloseTo(0.3)` passes. I use it anytime I'm testing calculated decimal values, like currency calculations or percentages."

---

### Q3: How do you test that a function was called with specific arguments?

**Answer:**

> "I use `toHaveBeenCalledWith` to verify the exact arguments. For example, if I'm testing a form submission, I'd write `expect(handleSubmit).toHaveBeenCalledWith({ email: 'test@example.com', password: 'pass123' })`. I can also use `toHaveBeenCalledTimes` to verify it was called the right number of times, and `toHaveBeenLastCalledWith` if I only care about the most recent call."

---

### Q4: What's the difference between toBeInTheDocument and toBeVisible?

**Answer:**

> "toBeInTheDocument checks if an element exists in the DOM at all, while toBeVisible checks if it's actually visible to the user. An element can be in the document but hidden with CSS, so it would pass toBeInTheDocument but fail toBeVisible. I use toBeInTheDocument for elements that should exist but might be hidden, and toBeVisible when I need to verify users can actually see the element."

---

### Q5: When should you use .not with matchers?

**Answer:**

> "I use .not to assert something is NOT true. Common cases include checking error messages don't appear for valid input, buttons aren't disabled when they should be enabled, or elements don't exist when they shouldn't. For example, after clearing an error, I'd write `expect(screen.queryByText(/error/i)).not.toBeInTheDocument()`. The key is using queryBy instead of getBy, since getBy throws if the element doesn't exist."

---

## üîë Must Know for Interviews

### ‚úÖ Critical (Always Asked)

- ‚úÖ toBe vs toEqual difference
- ‚úÖ toHaveBeenCalledWith for mocks
- ‚úÖ Testing Library matchers (toBeInTheDocument, toBeVisible)
- ‚úÖ .not negation

### ‚úÖ Should Know (Often Asked)

- ‚úÖ Truthiness matchers (toBeTruthy, toBeFalsy, toBeNull, toBeUndefined)
- ‚úÖ toBeCloseTo for floating point
- ‚úÖ async matchers (resolves, rejects)
- ‚úÖ Array/object matchers (toContain, toHaveProperty, toMatchObject)

### ‚úÖ Nice to Know (Senior Level)

- [ ] Custom matchers
- [ ] expect.extend for project-specific matchers
- [ ] Asymmetric matchers (expect.anything(), expect.any())
- [ ] Snapshot matchers

---

## üö® Common Mistakes

### 1. Using toBe for Objects

```javascript
// ‚ùå BAD - Will always fail
expect({ name: "John" }).toBe({ name: "John" });
expect([1, 2, 3]).toBe([1, 2, 3]);

// ‚úÖ GOOD - Use toEqual
expect({ name: "John" }).toEqual({ name: "John" });
expect([1, 2, 3]).toEqual([1, 2, 3]);
```

### 2. Floating Point with toBe

```javascript
// ‚ùå BAD - Precision issues
expect(0.1 + 0.2).toBe(0.3); // Fails!

// ‚úÖ GOOD - Use toBeCloseTo
expect(0.1 + 0.2).toBeCloseTo(0.3);
```

### 3. Wrong Query Method with .not

```javascript
// ‚ùå BAD - getBy throws error
expect(screen.getByText(/error/i)).not.toBeInTheDocument(); // Throws!

// ‚úÖ GOOD - Use queryBy
expect(screen.queryByText(/error/i)).not.toBeInTheDocument();
```

### 4. Forgetting await with Async

```javascript
// ‚ùå BAD - Missing await
expect(fetchUser()).resolves.toEqual({ name: "John" }); // Won't wait!

// ‚úÖ GOOD - Always await
await expect(fetchUser()).resolves.toEqual({ name: "John" });
```

---

## üí° Quick Reference

```javascript
// Equality
expect(a).toBe(b); // Reference equality (===)
expect(a).toEqual(b); // Deep value equality

// Truthiness
expect(a).toBeTruthy(); // Any truthy value
expect(a).toBeFalsy(); // Any falsy value
expect(a).toBe(true); // Exactly true
expect(a).toBeNull(); // Exactly null
expect(a).toBeUndefined(); // Exactly undefined
expect(a).toBeDefined(); // Not undefined

// Numbers
expect(a).toBeGreaterThan(b);
expect(a).toBeLessThan(b);
expect(a).toBeCloseTo(b); // Floating point

// Strings
expect(a).toContain("text");
expect(a).toMatch(/regex/);

// Arrays/Objects
expect(arr).toHaveLength(3);
expect(arr).toContain(item);
expect(obj).toHaveProperty("key");
expect(obj).toMatchObject({});

// Mocks
expect(fn).toHaveBeenCalled();
expect(fn).toHaveBeenCalledTimes(2);
expect(fn).toHaveBeenCalledWith(args);

// DOM
expect(el).toBeInTheDocument();
expect(el).toBeVisible();
expect(el).toHaveTextContent("text");
expect(el).toHaveValue("value");
expect(el).toBeDisabled();

// Negation
expect(a).not.toBe(b);
```
