# forwardRef

## üéØ Key Concepts

### 1. What is forwardRef?

**What it means:**

- `forwardRef` is a React API that allows a component to receive a `ref` from its parent and forward it to a child element or component
- By default, functional components cannot receive refs as props
- forwardRef "forwards" the ref through the component to an underlying DOM element or child component

**Why it matters:**

```javascript
// ‚ùå This doesn't work - ref is not forwarded
function MyInput(props) {
  return <input {...props} />;
  // Parent's ref won't reach the input!
}

// ‚úÖ This works - ref is forwarded
const MyInput = forwardRef((props, ref) => {
  return <input ref={ref} {...props} />;
});
```

**Key Points:**

- Necessary when you need to expose a DOM element from a component
- Common in component libraries (UI libraries like Material-UI, Chakra)
- Enables parent components to interact with child DOM elements
- Used with `useImperativeHandle` for custom ref APIs

---

### 2. Basic Usage

**Syntax:**

```javascript
const MyComponent = forwardRef((props, ref) => {
  // props: normal component props
  // ref: the ref passed from parent
  return <div ref={ref}>Content</div>;
});
```

**Complete Example:**

```javascript
import { forwardRef, useRef } from "react";

// Child component that forwards ref
const CustomInput = forwardRef((props, ref) => {
  return <input ref={ref} className="custom-input" {...props} />;
});

// Parent component using the ref
function Form() {
  const inputRef = useRef(null);

  const handleClick = () => {
    inputRef.current.focus(); // Direct DOM access!
  };

  return (
    <div>
      <CustomInput ref={inputRef} placeholder="Enter text" />
      <button onClick={handleClick}>Focus Input</button>
    </div>
  );
}
```

---

### 3. Why forwardRef is Needed

**The Problem:**

```javascript
function CustomButton(props) {
  return <button {...props}>Click me</button>;
}

function App() {
  const buttonRef = useRef(null);

  // ‚ùå ref is NOT a regular prop!
  // React won't pass it to CustomButton
  return <CustomButton ref={buttonRef} />;
  // Warning: Function components cannot be given refs
}
```

**The Solution:**

```javascript
const CustomButton = forwardRef((props, ref) => {
  return (
    <button ref={ref} {...props}>
      Click me
    </button>
  );
});

function App() {
  const buttonRef = useRef(null);

  // ‚úÖ Now it works!
  return <CustomButton ref={buttonRef} />;
}
```

**Why refs aren't normal props:**

- React treats `ref` specially, like `key`
- `ref` doesn't appear in `props` object
- This prevents accidental ref misuse
- forwardRef explicitly opts into ref forwarding

---

### 4. Common Use Cases

**1. Focus Management:**

```javascript
const CustomInput = forwardRef((props, ref) => {
  return (
    <div className="input-wrapper">
      <label>{props.label}</label>
      <input ref={ref} {...props} />
    </div>
  );
});

function LoginForm() {
  const emailRef = useRef(null);

  useEffect(() => {
    emailRef.current.focus(); // Auto-focus on mount
  }, []);

  return <CustomInput ref={emailRef} label="Email" />;
}
```

**2. Measuring DOM Elements:**

```javascript
const MeasurableDiv = forwardRef((props, ref) => {
  return <div ref={ref} {...props} />;
});

function App() {
  const divRef = useRef(null);

  const measure = () => {
    const { width, height } = divRef.current.getBoundingClientRect();
    console.log(`Width: ${width}, Height: ${height}`);
  };

  return (
    <>
      <MeasurableDiv ref={divRef}>Content</MeasurableDiv>
      <button onClick={measure}>Measure</button>
    </>
  );
}
```

**3. Animation Libraries:**

```javascript
const AnimatedBox = forwardRef((props, ref) => {
  return (
    <div ref={ref} className="box">
      {props.children}
    </div>
  );
});

function App() {
  const boxRef = useRef(null);

  const animate = () => {
    // Using GSAP or similar
    gsap.to(boxRef.current, { x: 100, duration: 1 });
  };

  return <AnimatedBox ref={boxRef}>Animate me</AnimatedBox>;
}
```

**4. Component Libraries:**

```javascript
// Common pattern in UI libraries
const Button = forwardRef(({ variant, children, ...props }, ref) => {
  return (
    <button ref={ref} className={`btn btn-${variant}`} {...props}>
      {children}
    </button>
  );
});

// Users can now get ref to actual button element
function App() {
  const btnRef = useRef();
  return (
    <Button ref={btnRef} variant="primary">
      Click
    </Button>
  );
}
```

---

### 5. Combining with Other Hooks

**With useState:**

```javascript
const Counter = forwardRef((props, ref) => {
  const [count, setCount] = useState(0);

  return (
    <div>
      <button ref={ref} onClick={() => setCount((c) => c + 1)}>
        Count: {count}
      </button>
    </div>
  );
});

function App() {
  const buttonRef = useRef(null);

  const scrollToButton = () => {
    buttonRef.current.scrollIntoView({ behavior: "smooth" });
  };

  return (
    <>
      <Counter ref={buttonRef} />
      <button onClick={scrollToButton}>Scroll to counter</button>
    </>
  );
}
```

**With useEffect:**

```javascript
const VideoPlayer = forwardRef((props, ref) => {
  useEffect(() => {
    // Access the forwarded ref in effects
    if (ref.current && props.autoPlay) {
      ref.current.play();
    }
  }, [props.autoPlay]);

  return <video ref={ref} src={props.src} />;
});
```

---

### 6. Multiple Refs Pattern

**When you need both internal and external refs:**

```javascript
const FancyInput = forwardRef((props, ref) => {
  const internalRef = useRef(null);

  // Merge both refs
  useEffect(() => {
    if (ref) {
      if (typeof ref === "function") {
        ref(internalRef.current);
      } else {
        ref.current = internalRef.current;
      }
    }
  }, [ref]);

  // Use internal ref for component logic
  const handleFocus = () => {
    internalRef.current.style.background = "yellow";
  };

  return <input ref={internalRef} onFocus={handleFocus} {...props} />;
});
```

**Better approach with callback ref:**

```javascript
const FancyInput = forwardRef((props, ref) => {
  const internalRef = useRef(null);

  const setRefs = useCallback(
    (element) => {
      // Set internal ref
      internalRef.current = element;

      // Set external ref
      if (ref) {
        if (typeof ref === "function") {
          ref(element);
        } else {
          ref.current = element;
        }
      }
    },
    [ref]
  );

  return <input ref={setRefs} {...props} />;
});
```

---

### 7. TypeScript Usage

**Typing forwardRef:**

```typescript
import { forwardRef, InputHTMLAttributes } from "react";

interface CustomInputProps extends InputHTMLAttributes<HTMLInputElement> {
  label: string;
}

const CustomInput = forwardRef<HTMLInputElement, CustomInputProps>(
  ({ label, ...props }, ref) => {
    return (
      <div>
        <label>{label}</label>
        <input ref={ref} {...props} />
      </div>
    );
  }
);

// Usage with full type safety
function App() {
  const inputRef = useRef<HTMLInputElement>(null);

  return <CustomInput ref={inputRef} label="Name" placeholder="Enter name" />;
}
```

---

### 8. Display Names

**Setting display name for DevTools:**

```javascript
const CustomInput = forwardRef((props, ref) => {
  return <input ref={ref} {...props} />;
});

// ‚úÖ Set display name for better debugging
CustomInput.displayName = "CustomInput";

// Now appears as "CustomInput" in React DevTools
// Instead of "ForwardRef" or "Anonymous"
```

---

## üé§ Top Interview Questions & Model Answers

### Q1: What is forwardRef and why is it needed?

**Answer:**

> "forwardRef is a React API that allows a component to receive a ref from its parent and pass it down to a child element. It's needed because refs aren't passed through components like normal props‚ÄîReact treats `ref` specially, similar to `key`. Without forwardRef, if you pass a ref to a functional component, React will show a warning and the ref won't work. forwardRef explicitly enables a component to forward its ref to an underlying DOM element or child component. This is essential for component libraries where you need to expose DOM elements to parent components for things like focus management, animations, or measuring."

---

### Q2: How do you use forwardRef?

**Answer:**

> "You wrap your component function with forwardRef, which then provides the ref as a second parameter alongside props. The basic syntax is `forwardRef((props, ref) => { ... })`. Inside the component, you attach the ref to the element you want to expose, typically using `ref={ref}`. The parent component can then create a ref with `useRef()` and pass it to your component, giving it direct access to the underlying DOM element."

**Show code:**

```javascript
const Input = forwardRef((props, ref) => {
  return <input ref={ref} {...props} />;
});

// Parent
const inputRef = useRef(null);
<Input ref={inputRef} />;
```

---

### Q3: When would you use forwardRef in a real application?

**Answer:**

> "I'd use forwardRef in several scenarios. First, when building reusable UI components that wrap native elements‚Äîlike a custom Input or Button component‚Äîwhere parent components might need direct DOM access for focus management or animations. Second, when integrating with third-party libraries that require refs, like animation libraries (GSAP, Framer Motion) or form libraries. Third, in component libraries where you want to provide a clean API that matches native elements. For example, if I'm building a design system, I'd use forwardRef on all components so they can be used seamlessly with refs just like native HTML elements."

---

### Q4: What's the difference between forwardRef and useImperativeHandle?

**Answer:**

> "forwardRef forwards a ref to a DOM element, giving the parent full access to that element. useImperativeHandle, which must be used with forwardRef, lets you customize what the parent receives on the ref‚Äîinstead of exposing the entire DOM element, you can expose only specific methods or values. For example, instead of giving access to the entire input element, you could expose just a `focus()` method. This provides better encapsulation and a cleaner API. useImperativeHandle is typically used when you want to hide implementation details or provide a custom imperative API."

---

### Q5: Can you have multiple refs in a component?

**Answer:**

> "Yes, absolutely. A component can have both an internal ref for its own use and accept a forwarded ref from a parent. The pattern is to create an internal ref with useRef, then use either a callback ref or a useEffect to sync both refs to the same element. The callback ref approach is generally cleaner‚Äîyou create a function that sets both the internal ref and the forwarded ref to the element. This way, both the component and its parent can access the same DOM node."

**Show pattern:**

```javascript
const Component = forwardRef((props, ref) => {
  const internalRef = useRef();

  const setRefs = (el) => {
    internalRef.current = el;
    if (ref) ref.current = el;
  };

  return <div ref={setRefs} />;
});
```

---

### Q6: Why do component libraries use forwardRef extensively?

**Answer:**

> "Component libraries use forwardRef to make their components behave like native HTML elements. When you use a native `<input>`, you can attach a ref to it. Users expect the same from a library's `<Input>` component. Without forwardRef, the ref would point to the component instance (or nothing in functional components), not the underlying input element. This would break common patterns like focus management, form libraries that need refs, or animation libraries. By using forwardRef, libraries ensure their components can be drop-in replacements for native elements while still providing custom styling and behavior."

---

## üîë Must Know Checklist

### ‚úÖ Must Know (Core concepts)

- ‚úÖ What forwardRef is and why it's needed
- ‚úÖ Basic syntax and usage
- ‚úÖ Why refs aren't normal props
- ‚úÖ Common use cases (focus, measuring, animations)

### ‚úÖ Should Know (Practical implementation)

- ‚úÖ Setting display names for debugging
- ‚úÖ Combining with other hooks
- ‚úÖ Multiple refs pattern
- ‚úÖ When to use vs when not to use

### ‚úÖ Nice to Know (Advanced)

- [ ] TypeScript typing for forwardRef
- [ ] Combining with useImperativeHandle
- [ ] Ref callback patterns
- [ ] Performance considerations

---

## üö® Common Mistakes to Avoid

### 1. Forgetting forwardRef Wrapper

```javascript
// ‚ùå Doesn't work - ref won't be passed
function CustomInput(props, ref) {
  return <input ref={ref} {...props} />;
}

// ‚úÖ Correct - wrapped with forwardRef
const CustomInput = forwardRef((props, ref) => {
  return <input ref={ref} {...props} />;
});
```

### 2. Not Setting Display Name

```javascript
// ‚ùå Shows as "ForwardRef" in DevTools
const CustomInput = forwardRef((props, ref) => {
  return <input ref={ref} {...props} />;
});

// ‚úÖ Shows as "CustomInput" in DevTools
const CustomInput = forwardRef((props, ref) => {
  return <input ref={ref} {...props} />;
});
CustomInput.displayName = "CustomInput";
```

### 3. Incorrect Multiple Refs Pattern

```javascript
// ‚ùå Only one ref works
const Component = forwardRef((props, ref) => {
  const internalRef = useRef();

  return (
    <>
      <div ref={internalRef}>Internal</div>
      <div ref={ref}>External</div>
    </>
  );
});

// ‚úÖ Both refs point to same element
const Component = forwardRef((props, ref) => {
  const internalRef = useRef();

  const setRefs = (el) => {
    internalRef.current = el;
    if (ref) ref.current = el;
  };

  return <div ref={setRefs}>Content</div>;
});
```

### 4. Accessing Ref Too Early

```javascript
// ‚ùå Ref is null during render
const Component = forwardRef((props, ref) => {
  console.log(ref.current); // null!
  return <div ref={ref}>Content</div>;
});

// ‚úÖ Access ref in useEffect or event handlers
const Component = forwardRef((props, ref) => {
  useEffect(() => {
    console.log(ref.current); // Now it exists
  }, []);

  return <div ref={ref}>Content</div>;
});
```

### 5. Forwarding to Wrong Element

```javascript
// ‚ùå Ref forwarded to wrapper, not input
const CustomInput = forwardRef((props, ref) => {
  return (
    <div ref={ref}>
      <input {...props} />
    </div>
  );
});

// ‚úÖ Ref forwarded to actual input
const CustomInput = forwardRef((props, ref) => {
  return (
    <div>
      <input ref={ref} {...props} />
    </div>
  );
});
```

---

## üí° Pro Tips

1. **Always set displayName** for better debugging experience
2. **Use callback refs** for complex ref merging scenarios
3. **Combine with useImperativeHandle** to create custom APIs
4. **Forward refs in component libraries** to match native element behavior
5. **Type your refs properly** in TypeScript for better type safety
6. **Document what element the ref points to** in component documentation
7. **Consider if you really need forwardRef** - sometimes lifting state up is better than imperative ref usage
