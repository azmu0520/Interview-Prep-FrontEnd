# useImperativeHandle

## üéØ Key Concepts

### 1. What is useImperativeHandle?

**What it means:**

- A hook that lets you customize the value exposed when a parent component accesses a ref
- Used with `forwardRef` to control what the parent can do with the child's ref
- Allows you to expose specific methods/values instead of the entire DOM node
- Creates an imperative API for a component

**Why it exists:**

- Encapsulation: Hide internal implementation details
- Control: Decide exactly what parent can access
- Abstraction: Provide a clean API instead of direct DOM access

**Basic pattern:**

```javascript
import { forwardRef, useImperativeHandle, useRef } from "react";

const MyInput = forwardRef((props, ref) => {
  const inputRef = useRef();

  useImperativeHandle(ref, () => ({
    // Expose only what you want parent to access
    focus: () => {
      inputRef.current.focus();
    },
    getValue: () => {
      return inputRef.current.value;
    },
  }));

  return <input ref={inputRef} {...props} />;
});

// Parent usage
const parentRef = useRef();
parentRef.current.focus(); // ‚úÖ Works
parentRef.current.value; // ‚ùå Undefined - not exposed
```

---

### 2. Must Be Used with forwardRef

**What it means:**

- `useImperativeHandle` only makes sense with `forwardRef`
- `forwardRef` passes the ref from parent to child
- `useImperativeHandle` customizes what that ref points to

**The Complete Pattern:**

```javascript
// ‚ùå WRONG - Missing forwardRef
const MyComponent = (props) => {
  useImperativeHandle(ref, () => ({
    // Where does 'ref' come from?
    doSomething: () => {},
  }));
  return <div>Content</div>;
};

// ‚úÖ CORRECT - With forwardRef
const MyComponent = forwardRef((props, ref) => {
  useImperativeHandle(ref, () => ({
    doSomething: () => {
      console.log("Doing something!");
    },
  }));
  return <div>Content</div>;
});

// Parent component
function Parent() {
  const myRef = useRef();

  const handleClick = () => {
    myRef.current.doSomething(); // Calls custom method
  };

  return (
    <>
      <MyComponent ref={myRef} />
      <button onClick={handleClick}>Do Something</button>
    </>
  );
}
```

---

### 3. Customizing the Ref Value

**What it means:**

- The second argument is a function that returns an object
- This object becomes the value of `ref.current` in the parent
- You have full control over the API

**Exposing Methods:**

```javascript
const VideoPlayer = forwardRef((props, ref) => {
  const videoRef = useRef();
  const [isPlaying, setIsPlaying] = useState(false);

  useImperativeHandle(ref, () => ({
    play: () => {
      videoRef.current.play();
      setIsPlaying(true);
    },
    pause: () => {
      videoRef.current.pause();
      setIsPlaying(false);
    },
    seek: (time) => {
      videoRef.current.currentTime = time;
    },
    getIsPlaying: () => isPlaying,
  }));

  return <video ref={videoRef} src={props.src} />;
});
```

**Exposing Values:**

```javascript
const Counter = forwardRef((props, ref) => {
  const [count, setCount] = useState(0);

  useImperativeHandle(ref, () => ({
    count, // Expose current count
    increment: () => setCount((c) => c + 1),
    decrement: () => setCount((c) => c - 1),
    reset: () => setCount(0),
  }));

  return <div>Count: {count}</div>;
});
```

---

### 4. Dependency Array (Performance)

**What it means:**

- Third argument is a dependency array (like useEffect)
- The ref value is only recreated when dependencies change
- Optimization to prevent unnecessary work

**Without Dependencies:**

```javascript
// ‚ùå Creates new ref object on EVERY render
useImperativeHandle(ref, () => ({
  focus: () => inputRef.current.focus(),
  clear: () => (inputRef.current.value = ""),
}));
```

**With Dependencies:**

```javascript
// ‚úÖ Only recreates when inputRef changes
useImperativeHandle(
  ref,
  () => ({
    focus: () => inputRef.current.focus(),
    clear: () => (inputRef.current.value = ""),
  }),
  [inputRef]
);

// ‚úÖ Empty array - created once
useImperativeHandle(
  ref,
  () => ({
    focus: () => inputRef.current.focus(),
    clear: () => (inputRef.current.value = ""),
  }),
  []
);
```

**With State Dependencies:**

```javascript
const [value, setValue] = useState("");

useImperativeHandle(
  ref,
  () => ({
    getValue: () => value, // Needs to return latest value
    clear: () => setValue(""),
  }),
  [value]
); // Recreate when value changes
```

---

### 5. Common Use Cases

**1. Focus Management:**

```javascript
const FancyInput = forwardRef((props, ref) => {
  const inputRef = useRef();

  useImperativeHandle(ref, () => ({
    focus: () => inputRef.current.focus(),
    blur: () => inputRef.current.blur(),
    select: () => inputRef.current.select(),
  }));

  return (
    <div className="fancy-input-wrapper">
      <input ref={inputRef} {...props} />
    </div>
  );
});
```

**2. Form Controls:**

```javascript
const Form = forwardRef((props, ref) => {
  const formRef = useRef();

  useImperativeHandle(ref, () => ({
    submit: () => formRef.current.submit(),
    reset: () => formRef.current.reset(),
    getFormData: () => new FormData(formRef.current),
  }));

  return <form ref={formRef}>{props.children}</form>;
});
```

**3. Animation Controls:**

```javascript
const AnimatedBox = forwardRef((props, ref) => {
  const [isAnimating, setIsAnimating] = useState(false);

  useImperativeHandle(ref, () => ({
    start: () => setIsAnimating(true),
    stop: () => setIsAnimating(false),
    reset: () => {
      setIsAnimating(false);
      // reset animation state
    },
  }));

  return <div className={isAnimating ? "animate" : ""}>{props.children}</div>;
});
```

**4. Modal/Dialog Controls:**

```javascript
const Modal = forwardRef((props, ref) => {
  const [isOpen, setIsOpen] = useState(false);

  useImperativeHandle(ref, () => ({
    open: () => setIsOpen(true),
    close: () => setIsOpen(false),
    toggle: () => setIsOpen((prev) => !prev),
  }));

  if (!isOpen) return null;

  return <div className="modal">{props.children}</div>;
});

// Parent usage
function Parent() {
  const modalRef = useRef();

  return (
    <>
      <button onClick={() => modalRef.current.open()}>Open Modal</button>
      <Modal ref={modalRef}>
        <h2>Modal Content</h2>
        <button onClick={() => modalRef.current.close()}>Close</button>
      </Modal>
    </>
  );
}
```

---

### 6. When NOT to Use

**Anti-patterns:**

```javascript
// ‚ùå BAD - Exposing everything (defeats the purpose)
useImperativeHandle(ref, () => inputRef.current);
// Just use regular forwardRef instead!

// ‚ùå BAD - Using for data flow (use props instead)
useImperativeHandle(ref, () => ({
  getData: () => data, // Use props callbacks instead!
}));

// ‚ùå BAD - Overusing imperative code
// Most React patterns should be declarative
```

**When to avoid:**

- ‚ùå For normal data flow (use props/callbacks)
- ‚ùå For state management (use context/state management)
- ‚ùå When you can use regular props
- ‚ùå For everything - it's an escape hatch, not the default

**Prefer declarative:**

```javascript
// ‚ùå Imperative with useImperativeHandle
const modalRef = useRef();
<button onClick={() => modalRef.current.open()}>Open</button>

// ‚úÖ Declarative with props
const [isOpen, setIsOpen] = useState(false);
<button onClick={() => setIsOpen(true)}>Open</button>
<Modal isOpen={isOpen} onClose={() => setIsOpen(false)} />
```

---

## üé§ Top Interview Questions & Model Answers

### Q1: What is useImperativeHandle and when would you use it?

**Answer:**

> "useImperativeHandle is a hook that lets you customize the instance value that is exposed to parent components when using ref. It must be used together with forwardRef. Instead of exposing the entire DOM node, you can expose only specific methods or values. I'd use it when building reusable component libraries where I want to provide a clean API, like a custom input that exposes focus() and clear() methods, or a video player that exposes play(), pause(), and seek(). However, it's an escape hatch - most of the time, declarative props-based APIs are better."

---

### Q2: How does useImperativeHandle work with forwardRef?

**Answer:**

> "forwardRef allows a component to receive a ref from its parent and forward it. useImperativeHandle then customizes what that ref points to. Without forwardRef, the child component doesn't receive the ref prop. Together, they let you create components with imperative APIs that the parent can call via ref.current, while keeping the internal implementation hidden."

**Example to mention:**

```javascript
const Input = forwardRef((props, ref) => {
  const inputRef = useRef();

  useImperativeHandle(ref, () => ({
    focus: () => inputRef.current.focus(),
  }));

  return <input ref={inputRef} />;
});

// Parent calls: myRef.current.focus()
```

---

### Q3: Why would you use useImperativeHandle instead of just forwarding the ref directly?

**Answer:**

> "useImperativeHandle provides encapsulation and control. When you forward a ref directly, the parent gets access to the entire DOM node and can manipulate it in any way, which breaks encapsulation. With useImperativeHandle, you expose only what you want - a controlled API. For example, for a custom input wrapper, you might only expose focus() and clear() methods while hiding the actual DOM structure. This makes your component more maintainable and prevents parents from depending on internal implementation details."

---

### Q4: What's the third argument to useImperativeHandle?

**Answer:**

> "The third argument is a dependency array, similar to useEffect. It controls when the ref object is recreated. If you pass an empty array, the ref object is created once on mount. If you include dependencies, it's recreated when they change. This is a performance optimization - you want to include any values from props or state that are used in the exposed methods to ensure they always have the latest values."

---

### Q5: Can you give a real-world example of when useImperativeHandle is necessary?

**Answer:**

> "A good example is a custom form component library. Let's say you have a Form component that wraps native form elements with custom styling and validation. You want to expose submit(), reset(), and validate() methods to parent components, but you don't want parents to access the internal form state or DOM structure directly. Using useImperativeHandle, you can create a clean API that parents can use imperatively while keeping all the complex internal logic hidden."

---

### Q6: What are the downsides or risks of useImperativeHandle?

**Answer:**

> "The main downside is that it promotes imperative code, which goes against React's declarative nature. Overusing it can make your code harder to reason about because component behavior is controlled from the outside rather than through props. It can also make testing more difficult and create tight coupling between parent and child. It should be used sparingly - only when you genuinely need imperative APIs, like focus management, animations, or integrating with non-React libraries. Most of the time, a declarative, props-based API is clearer and more maintainable."

---

## üîë Key Takeaways

### ‚úÖ Must Know (Critical)

- ‚úÖ Must be used with forwardRef
- ‚úÖ Customizes what parent accesses via ref
- ‚úÖ Takes a ref and a function returning an object
- ‚úÖ Used for exposing imperative methods

### ‚úÖ Should Know (Often asked)

- ‚úÖ Dependency array for optimization
- ‚úÖ Common use cases (focus, form controls, animations)
- ‚úÖ When NOT to use it (prefer declarative)
- ‚úÖ Encapsulation benefits

### ‚úÖ Nice to Know (Senior level)

- [ ] Performance implications
- [ ] Testing strategies with imperative refs
- [ ] Comparison with class component imperative methods
- [ ] Integration with TypeScript

---

## üö® Common Mistakes to Avoid

### 1. Using Without forwardRef

```javascript
// ‚ùå WRONG - ref parameter doesn't exist
const MyComponent = (props) => {
  useImperativeHandle(ref, () => ({}));
  return <div />;
};

// ‚úÖ CORRECT
const MyComponent = forwardRef((props, ref) => {
  useImperativeHandle(ref, () => ({}));
  return <div />;
});
```

### 2. Exposing Everything (Defeats Purpose)

```javascript
// ‚ùå BAD - Just use regular ref forwarding
useImperativeHandle(ref, () => divRef.current);

// ‚úÖ GOOD - Expose specific API
useImperativeHandle(ref, () => ({
  focus: () => divRef.current.focus(),
  scrollToTop: () => (divRef.current.scrollTop = 0),
}));
```

### 3. Forgetting Dependencies

```javascript
const [count, setCount] = useState(0);

// ‚ùå BAD - getCount always returns stale value
useImperativeHandle(
  ref,
  () => ({
    getCount: () => count,
  }),
  []
);

// ‚úÖ GOOD - Recreates when count changes
useImperativeHandle(
  ref,
  () => ({
    getCount: () => count,
  }),
  [count]
);
```

### 4. Using for Data Flow

```javascript
// ‚ùå BAD - Use props/callbacks instead
useImperativeHandle(ref, () => ({
  getData: () => data,
  onDataChange: (newData) => setData(newData),
}));

// ‚úÖ GOOD - Use props
<MyComponent data={data} onDataChange={setData} />;
```

### 5. Overusing Imperative APIs

```javascript
// ‚ùå BAD - Everything is imperative
const modalRef = useRef();
modalRef.current.open();
modalRef.current.close();
modalRef.current.setContent("...");

// ‚úÖ GOOD - Declarative with props
<Modal isOpen={isOpen} onClose={() => setIsOpen(false)} content={content} />;
```

---

## üí° Pro Tips

1. **Prefer Declarative**: Only use when imperative API truly makes sense
2. **Encapsulation**: Expose minimal API, hide implementation
3. **Dependencies Matter**: Include all closures in dependency array
4. **TypeScript**: Type the exposed API for better DX
5. **Testing**: Test the exposed methods, not implementation
6. **Documentation**: Document the imperative API clearly

---

## üìö Advanced Pattern: Combining Multiple Refs

```javascript
const AdvancedInput = forwardRef((props, ref) => {
  const inputRef = useRef();
  const wrapperRef = useRef();
  const [history, setHistory] = useState([]);

  useImperativeHandle(
    ref,
    () => ({
      // Input methods
      focus: () => inputRef.current.focus(),
      getValue: () => inputRef.current.value,
      setValue: (val) => {
        inputRef.current.value = val;
        setHistory((prev) => [...prev, val]);
      },

      // Wrapper methods
      scrollIntoView: () => wrapperRef.current.scrollIntoView(),

      // State methods
      getHistory: () => history,
      clearHistory: () => setHistory([]),
    }),
    [history]
  );

  return (
    <div ref={wrapperRef}>
      <input ref={inputRef} {...props} />
    </div>
  );
});
```
