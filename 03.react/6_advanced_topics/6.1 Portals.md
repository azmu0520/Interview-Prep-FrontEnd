# Portals

## üéØ Key Concepts

### 1. What Are Portals?

**What it means:**

- Portals provide a way to render children into a DOM node that exists outside the parent component's DOM hierarchy
- Created using `ReactDOM.createPortal(child, container)`
- The portal's children appear in a different place in the DOM, but behave like normal React children in every other way

**Why it matters:**

```javascript
// Typical React rendering - child goes inside parent
<div id="app">
  <Modal>Content</Modal>  {/* Renders inside #app */}
</div>

// With Portal - child goes to different DOM node
<div id="app">
  <Modal>Content</Modal>  {/* Actually renders in #modal-root */}
</div>
<div id="modal-root"></div>  {/* Portal target */}
```

**Key Points:**

- Useful for modals, tooltips, dropdowns, notifications
- Breaks out of CSS overflow/z-index constraints
- Event bubbling still works through React tree (not DOM tree)
- Maintains React context and state flow

---

### 2. Creating a Portal

**Basic Syntax:**

```javascript
import { createPortal } from "react-dom";

const MyPortal = ({ children }) => {
  // Find or create the portal container
  const portalRoot = document.getElementById("portal-root");

  return createPortal(
    children, // What to render
    portalRoot // Where to render it
  );
};
```

**Complete Modal Example:**

```javascript
import { createPortal } from "react-dom";
import { useEffect, useState } from "react";

const Modal = ({ isOpen, onClose, children }) => {
  if (!isOpen) return null;

  return createPortal(
    <div className="modal-overlay" onClick={onClose}>
      <div className="modal-content" onClick={(e) => e.stopPropagation()}>
        {children}
        <button onClick={onClose}>Close</button>
      </div>
    </div>,
    document.getElementById("modal-root")
  );
};

// Usage
function App() {
  const [isOpen, setIsOpen] = useState(false);

  return (
    <div className="app">
      <button onClick={() => setIsOpen(true)}>Open Modal</button>
      <Modal isOpen={isOpen} onClose={() => setIsOpen(false)}>
        <h2>Modal Content</h2>
      </Modal>
    </div>
  );
}
```

**HTML Setup:**

```html
<body>
  <div id="root"></div>
  <div id="modal-root"></div>
  <!-- Portal target -->
</body>
```

---

### 3. Event Bubbling Through Portals

**Critical Understanding:**

- Events bubble through the **React component tree**, not the DOM tree
- Even though the portal renders elsewhere in the DOM, events propagate to React ancestors

**Example:**

```javascript
function Parent() {
  const handleClick = () => {
    console.log("Parent clicked!");
  };

  return (
    <div onClick={handleClick}>
      <Child />
    </div>
  );
}

function Child() {
  return createPortal(
    <button>Click me</button>,
    document.getElementById("portal-root")
  );
}

// Clicking the button WILL trigger Parent's handleClick
// Even though button is NOT a DOM child of the div!
```

**Why this matters:**

- Context providers work across portals
- Event delegation patterns still work
- You can catch events from portaled children
- Maintains React's declarative event handling

---

### 4. Common Use Cases

**Modals/Dialogs:**

```javascript
const Modal = ({ children, onClose }) => {
  useEffect(() => {
    // Prevent body scroll when modal is open
    document.body.style.overflow = "hidden";
    return () => {
      document.body.style.overflow = "unset";
    };
  }, []);

  return createPortal(
    <div className="modal-backdrop">
      <div className="modal">{children}</div>
    </div>,
    document.body
  );
};
```

**Tooltips:**

```javascript
const Tooltip = ({ targetRef, children, position }) => {
  const [coords, setCoords] = useState({ top: 0, left: 0 });

  useEffect(() => {
    if (targetRef.current) {
      const rect = targetRef.current.getBoundingClientRect();
      setCoords({
        top: rect.bottom + window.scrollY,
        left: rect.left + window.scrollX,
      });
    }
  }, [targetRef]);

  return createPortal(
    <div
      className="tooltip"
      style={{
        position: "absolute",
        top: coords.top,
        left: coords.left,
      }}
    >
      {children}
    </div>,
    document.body
  );
};
```

**Notifications/Toasts:**

```javascript
const Toast = ({ message, type }) => {
  return createPortal(
    <div className={`toast toast-${type}`}>{message}</div>,
    document.getElementById("toast-root")
  );
};
```

**Dropdowns that escape overflow:**

```javascript
const Dropdown = ({ triggerRef, items }) => {
  const [position, setPosition] = useState({ top: 0, left: 0 });

  useEffect(() => {
    if (triggerRef.current) {
      const rect = triggerRef.current.getBoundingClientRect();
      setPosition({
        top: rect.bottom,
        left: rect.left,
      });
    }
  }, [triggerRef]);

  return createPortal(
    <ul
      className="dropdown-menu"
      style={{
        position: "fixed",
        top: position.top,
        left: position.left,
      }}
    >
      {items.map((item) => (
        <li key={item.id}>{item.label}</li>
      ))}
    </ul>,
    document.body
  );
};
```

---

### 5. Managing Portal Container

**Dynamic Container Creation:**

```javascript
const Portal = ({ children, containerId = "portal-root" }) => {
  const [container] = useState(() => {
    // Create container if it doesn't exist
    let element = document.getElementById(containerId);
    if (!element) {
      element = document.createElement("div");
      element.id = containerId;
      document.body.appendChild(element);
    }
    return element;
  });

  useEffect(() => {
    // Cleanup: remove if empty when component unmounts
    return () => {
      if (container.childNodes.length === 0) {
        container.remove();
      }
    };
  }, [container]);

  return createPortal(children, container);
};
```

**With Cleanup:**

```javascript
const usePortal = (id) => {
  const [container] = useState(() => {
    const el = document.createElement("div");
    el.id = id;
    return el;
  });

  useEffect(() => {
    document.body.appendChild(container);
    return () => {
      document.body.removeChild(container);
    };
  }, [container]);

  return container;
};

// Usage
const Modal = ({ children }) => {
  const target = usePortal("modal-root");
  return createPortal(children, target);
};
```

---

### 6. CSS Considerations

**Why Portals Help with CSS:**

```javascript
// Problem: Modal inside container with overflow: hidden
<div style={{ overflow: 'hidden', position: 'relative' }}>
  <Modal />  {/* Gets clipped! */}
</div>

// Solution: Portal escapes the container
<div style={{ overflow: 'hidden', position: 'relative' }}>
  <ModalTrigger />
</div>
{/* Modal renders at body level via portal - not clipped! */}
```

**Z-Index Issues Solved:**

```javascript
// Parent has z-index context that limits modal
<div style={{ zIndex: 1, position: "relative" }}>
  <Modal /> {/* Stuck in parent's stacking context */}
</div>;

// Portal breaks free
{
  createPortal(
    <Modal />, // Can have its own high z-index
    document.body
  );
}
```

---

### 7. Accessibility Considerations

**Focus Management:**

```javascript
const Modal = ({ isOpen, onClose, children }) => {
  const modalRef = useRef(null);

  useEffect(() => {
    if (isOpen && modalRef.current) {
      // Focus first focusable element
      const focusable = modalRef.current.querySelector(
        'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
      );
      focusable?.focus();
    }
  }, [isOpen]);

  if (!isOpen) return null;

  return createPortal(
    <div
      ref={modalRef}
      role="dialog"
      aria-modal="true"
      aria-labelledby="modal-title"
    >
      {children}
    </div>,
    document.getElementById("modal-root")
  );
};
```

**Keyboard Handling:**

```javascript
const Modal = ({ isOpen, onClose, children }) => {
  useEffect(() => {
    if (!isOpen) return;

    const handleEscape = (e) => {
      if (e.key === "Escape") onClose();
    };

    document.addEventListener("keydown", handleEscape);
    return () => document.removeEventListener("keydown", handleEscape);
  }, [isOpen, onClose]);

  // ... rest of component
};
```

---

## üé§ Top Interview Questions & Model Answers

### Q1: What is a React Portal and when would you use it?

**Answer:**

> "A React Portal allows you to render a component's children into a DOM node that exists outside the parent component's DOM hierarchy, while maintaining the React component tree relationship. You use `ReactDOM.createPortal(child, container)` to create one. The most common use cases are modals, tooltips, and dropdowns that need to break out of a parent container's CSS constraints like `overflow: hidden` or `z-index` stacking contexts. Even though the portal renders elsewhere in the DOM, events still bubble through the React tree, and context and props flow normally."

---

### Q2: How does event bubbling work with Portals?

**Answer:**

> "This is a key feature of portals‚Äîevents bubble according to the React component tree, not the DOM tree. So even if a portal renders a button outside the parent's DOM hierarchy, clicking that button will still trigger onClick handlers on React parent components. This happens because React implements its own event system with synthetic events. This means you can use normal React patterns like event delegation, and context providers work across portals as expected."

---

### Q3: How do you create a portal and what are the steps involved?

**Answer:**

> "First, you need a DOM node to render into, typically a div with an id like 'portal-root' added to your HTML. Then in your component, you import `createPortal` from 'react-dom' and call it with two arguments: the JSX you want to render, and a reference to the target DOM node. You can use `document.getElementById()` or create the element dynamically. For production code, I'd typically create a reusable Portal component that handles container creation and cleanup in useEffect to avoid memory leaks."

**Show code:**

```javascript
createPortal(<div>Modal content</div>, document.getElementById("modal-root"));
```

---

### Q4: What are the advantages of using Portals for modals?

**Answer:**

> "Portals solve several CSS and DOM issues with modals. First, they escape parent containers that have `overflow: hidden`, which would clip the modal. Second, they avoid z-index stacking context issues‚Äîby rendering at the document root, the modal can have its own high z-index. Third, they make it easier to add a page-level backdrop overlay. Fourth, they simplify styling since the modal isn't constrained by parent container styles. From an accessibility standpoint, having modals at the root level also makes it easier to manage focus trapping and screen reader announcements."

---

### Q5: How do you handle cleanup when using Portals?

**Answer:**

> "You need to be careful about creating and removing portal containers. If you're creating the container element dynamically, you should do it in useState with lazy initialization, append it to the document in useEffect, and remove it in the cleanup function. You also need to check if the container has any children before removing it, in case multiple components are using the same portal root. Additionally, for modals, you might want to prevent body scroll when the modal is open and restore it on cleanup."

**Show pattern:**

```javascript
useEffect(() => {
  document.body.appendChild(container);
  return () => {
    document.body.removeChild(container);
  };
}, [container]);
```

---

### Q6: Do Context providers work across Portals?

**Answer:**

> "Yes, absolutely. Even though portals render children in a different location in the DOM tree, they remain part of the React component tree. This means Context providers, props, and state all flow normally through portals. A component rendered through a portal can access any context from its React ancestors, and can call callbacks passed as props. This is one of the key advantages of portals‚Äîyou get positional flexibility in the DOM while maintaining all React relationships."

---

## üîë Must Know Checklist

### ‚úÖ Must Know (Core concepts)

- ‚úÖ What portals are and basic syntax
- ‚úÖ Common use cases (modals, tooltips, dropdowns)
- ‚úÖ Event bubbling through React tree, not DOM tree
- ‚úÖ CSS benefits (escaping overflow and z-index)

### ‚úÖ Should Know (Practical implementation)

- ‚úÖ Creating and managing portal containers
- ‚úÖ Cleanup and memory considerations
- ‚úÖ Accessibility concerns (focus management)
- ‚úÖ How context and props work with portals

### ‚úÖ Nice to Know (Advanced)

- [ ] Server-side rendering considerations
- [ ] Multiple portal targets
- [ ] Performance implications
- [ ] Testing components with portals

---

## üö® Common Mistakes to Avoid

### 1. Forgetting to Create Portal Container

```javascript
// ‚ùå Container doesn't exist in HTML
createPortal(
  <Modal />,
  document.getElementById("modal-root") // Returns null!
);

// ‚úÖ Ensure container exists or create it
const container =
  document.getElementById("modal-root") ||
  (() => {
    const div = document.createElement("div");
    div.id = "modal-root";
    document.body.appendChild(div);
    return div;
  })();
```

### 2. Not Cleaning Up Portal Containers

```javascript
// ‚ùå Memory leak - container never removed
const container = document.createElement("div");
document.body.appendChild(container);
// No cleanup!

// ‚úÖ Clean up in useEffect
useEffect(() => {
  const container = document.createElement("div");
  document.body.appendChild(container);
  return () => {
    document.body.removeChild(container);
  };
}, []);
```

### 3. Assuming DOM Tree Event Bubbling

```javascript
// ‚ùå Thinking DOM structure matters
<div id="app" onclick="handleClick()">
  {createPortal(<button />, document.body)}
  {/* onClick WON'T fire - different DOM tree */}
</div>

// ‚úÖ Use React event handlers
<div onClick={handleClick}>
  {createPortal(<button />, document.body)}
  {/* onClick WILL fire - same React tree */}
</div>
```

### 4. Ignoring Accessibility

```javascript
// ‚ùå No ARIA attributes or focus management
createPortal(
  <div>
    <h2>Modal</h2>
  </div>,
  modalRoot
);

// ‚úÖ Proper accessibility
createPortal(
  <div role="dialog" aria-modal="true" aria-labelledby="title">
    <h2 id="title">Modal</h2>
  </div>,
  modalRoot
);
```

### 5. Multiple Unnecessary Portal Roots

```javascript
// ‚ùå Creating new container for each instance
function Modal() {
  const container = document.createElement("div");
  document.body.appendChild(container);
  return createPortal(<div>Modal</div>, container);
}

// ‚úÖ Share a single portal root
const modalRoot = document.getElementById("modal-root");
function Modal() {
  return createPortal(<div>Modal</div>, modalRoot);
}
```

---

## üí° Pro Tips

1. **Reusable Portal Component**: Create a generic `<Portal>` component for all portal needs
2. **Body Scroll Lock**: Prevent background scrolling when modal is open
3. **Focus Trap**: Keep keyboard navigation within modal
4. **ESC Key**: Close modal on Escape key press
5. **Click Outside**: Close on backdrop click (with stopPropagation on content)
6. **Animation**: Use CSS transitions for smooth enter/exit animations
7. **Multiple Portals**: Use different portal roots for different purposes (modals, toasts, tooltips)
