# React Server Components

## üéØ Key Concepts

### 1. What are React Server Components?

**What it means:**

- A new paradigm introduced by React team (still evolving)
- Components that render **only on the server**, never sent to client
- Different from traditional Server-Side Rendering (SSR)
- Work alongside traditional "Client Components"
- Part of React's vision for the future

**Key difference from SSR:**

- **SSR**: Renders HTML on server, then hydrates with JavaScript on client
- **RSC**: Component code never goes to client at all, zero JavaScript bundle impact

**Current state (as of 2024-2025):**

- Implemented in Next.js 13+ (App Router)
- Not yet available in standalone React
- Experimental features still being refined
- Production-ready in Next.js, emerging in other frameworks

**Why it matters:**

> "Server Components represent a fundamental shift in how we think about React applications. Understanding them is crucial for senior frontend roles."

---

### 2. Server Components vs Client Components

**Server Components (default in Next.js App Router):**

```javascript
// This is a Server Component (default)
// No 'use client' directive

async function BlogPost({ id }) {
  // Can directly access database!
  const post = await db.posts.findById(id);

  // Can use Node.js APIs
  const fs = require("fs");

  // Can import large libraries without bundle impact
  const marked = require("marked"); // Zero client bundle size!

  return (
    <article>
      <h1>{post.title}</h1>
      <div dangerouslySetInnerHTML={{ __html: marked(post.content) }} />
    </article>
  );
}

export default BlogPost;
```

**Client Components:**

```javascript
// Must explicitly mark with 'use client'
"use client";

import { useState } from "react";

function Counter() {
  // Can use state, effects, event handlers
  const [count, setCount] = useState(0);

  return <button onClick={() => setCount(count + 1)}>Count: {count}</button>;
}

export default Counter;
```

**Key differences:**

| Feature               | Server Components | Client Components |
| --------------------- | ----------------- | ----------------- |
| **Directive**         | None (default)    | `'use client'`    |
| **Where runs**        | Server only       | Server + Client   |
| **JavaScript bundle** | Zero impact       | Added to bundle   |
| **Can use hooks**     | ‚ùå No             | ‚úÖ Yes            |
| **Can use state**     | ‚ùå No             | ‚úÖ Yes            |
| **Can use effects**   | ‚ùå No             | ‚úÖ Yes            |
| **Event handlers**    | ‚ùå No             | ‚úÖ Yes            |
| **Direct DB access**  | ‚úÖ Yes            | ‚ùå No             |
| **Node.js APIs**      | ‚úÖ Yes            | ‚ùå No             |
| **Async components**  | ‚úÖ Yes            | ‚ùå No             |
| **Import heavy libs** | ‚úÖ No bundle cost | ‚ùå Bundle cost    |

---

### 3. Benefits of Server Components

#### 3.1 Zero Bundle Size

**The problem with traditional React:**

```javascript
// Client Component - ALL OF THIS goes to browser
import React, { useState } from "react";
import { marked } from "marked"; // 50kb
import Prism from "prismjs"; // 100kb
import { format } from "date-fns"; // 200kb
import _ from "lodash"; // 70kb

// Total: 420kb just for this component! üî•
```

**With Server Components:**

```javascript
// Server Component - ZERO bytes to browser
import { marked } from "marked"; // 0kb to client
import Prism from "prismjs"; // 0kb to client
import { format } from "date-fns"; // 0kb to client
import _ from "lodash"; // 0kb to client

async function BlogPost({ slug }) {
  const post = await getPost(slug);
  const html = marked(post.content); // Processed on server

  return <div dangerouslySetInnerHTML={{ __html: html }} />;
}

// Only the rendered HTML is sent to client!
```

**Impact:**

- Dramatically smaller JavaScript bundles
- Faster page loads
- Better performance on low-end devices
- Improved Core Web Vitals

#### 3.2 Direct Backend Access

**Traditional React - Need API routes:**

```javascript
// ‚ùå Traditional way - Two layers
// pages/api/posts.js
export default async function handler(req, res) {
  const posts = await db.posts.findAll();
  res.json(posts);
}

// components/PostList.jsx
function PostList() {
  const [posts, setPosts] = useState([]);

  useEffect(() => {
    fetch('/api/posts')          // HTTP request
      .then(res => res.json())
      .then(setPosts);
  }, []);

  return <div>{posts.map(...)}</div>;
}
```

**Server Components - Direct access:**

```javascript
// ‚úÖ Server Component - Direct DB access
async function PostList() {
  // No API route needed!
  const posts = await db.posts.findAll();

  return <div>{posts.map(...)}</div>;
}
```

**Benefits:**

- No API route boilerplate
- No extra network request
- Simpler code
- Better type safety (no API boundary)
- Co-located data fetching with UI

#### 3.3 Automatic Code Splitting

**Traditional React:**

```javascript
// Must manually specify what to lazy load
const HeavyComponent = lazy(() => import("./HeavyComponent"));

function App() {
  return (
    <Suspense fallback={<Loading />}>
      <HeavyComponent />
    </Suspense>
  );
}
```

**Server Components:**

```javascript
// Automatic! Server Components don't go to client
function App() {
  return (
    <div>
      <Header /> {/* Server Component - auto split */}
      <Sidebar /> {/* Server Component - auto split */}
      <ClientInteractive /> {/* Only this goes to client */}
      <Footer /> {/* Server Component - auto split */}
    </div>
  );
}
```

**React automatically handles:**

- Component splitting
- Parallel loading
- Optimal chunk sizes
- No manual lazy() needed

#### 3.4 Better Security

**Server Components can:**

```javascript
async function UserProfile({ userId }) {
  // API keys never exposed to client
  const user = await fetch("https://api.example.com/users/" + userId, {
    headers: {
      Authorization: process.env.SECRET_API_KEY, // Safe!
    },
  });

  // Sensitive business logic stays on server
  const canAccessPremium = await checkSubscription(userId);

  return <div>...</div>;
}
```

**Security benefits:**

- API keys stay on server
- Business logic not exposed
- Database queries hidden
- Sensitive data never leaked to client

---

### 4. Composition Rules

**Understanding the component boundary:**

#### Rule 1: Server Components can import Client Components

```javascript
// ‚úÖ VALID - Server Component importing Client Component
// ServerComponent.jsx (Server)
import ClientButton from "./ClientButton"; // Client Component

function ServerComponent() {
  return (
    <div>
      <h1>Server Content</h1>
      <ClientButton /> {/* Works! */}
    </div>
  );
}

// ClientButton.jsx
("use client");

function ClientButton() {
  const [clicked, setClicked] = useState(false);
  return <button onClick={() => setClicked(true)}>Click</button>;
}
```

#### Rule 2: Client Components CANNOT import Server Components

```javascript
// ‚ùå INVALID - Client importing Server
// ClientComponent.jsx
"use client";

import ServerComponent from "./ServerComponent"; // ‚ùå ERROR!

function ClientComponent() {
  return <ServerComponent />; // Won't work!
}
```

**Why?** Client components run in browser, can't execute server-only code.

#### Rule 3: But you CAN pass Server Components as children/props

```javascript
// ‚úÖ VALID - Composition pattern
// Layout.jsx (Server)
import ClientSidebar from "./ClientSidebar";
import ServerContent from "./ServerContent";

function Layout() {
  return (
    <ClientSidebar>
      {/* Passing Server Component as children */}
      <ServerContent />
    </ClientSidebar>
  );
}

// ClientSidebar.jsx
("use client");

function ClientSidebar({ children }) {
  const [isOpen, setIsOpen] = useState(true);

  return (
    <aside>
      {isOpen && children} {/* Server Component rendered here */}
    </aside>
  );
}
```

**This is called "Server Component as props" pattern**

---

### 5. Async Components

**Server Components can be async:**

```javascript
// ‚úÖ VALID - Async Server Component
async function UserProfile({ userId }) {
  // Can use await at component level!
  const user = await fetchUser(userId);
  const posts = await fetchUserPosts(userId);

  return (
    <div>
      <h1>{user.name}</h1>
      <PostList posts={posts} />
    </div>
  );
}
```

**This was NEVER possible before!**

**Traditional React:**

```javascript
// ‚ùå Can't do this in regular React
async function UserProfile({ userId }) {
  // ‚ùå Components can't be async
  const user = await fetchUser(userId); // ‚ùå Doesn't work
  return <div>{user.name}</div>;
}

// Had to use useEffect instead
function UserProfile({ userId }) {
  const [user, setUser] = useState(null);

  useEffect(() => {
    fetchUser(userId).then(setUser);
  }, [userId]);

  if (!user) return <Loading />;
  return <div>{user.name}</div>;
}
```

**Benefits of async components:**

- More intuitive data fetching
- No loading state management
- No useEffect needed
- Suspense integration automatic

---

### 6. Streaming and Suspense

**Server Components work seamlessly with Suspense:**

```javascript
// Server Component with Suspense
import { Suspense } from "react";

function Page() {
  return (
    <div>
      <Header /> {/* Renders immediately */}
      <Suspense fallback={<Spinner />}>
        <SlowServerComponent /> {/* Streams in when ready */}
      </Suspense>
      <Suspense fallback={<Skeleton />}>
        <AnotherSlowComponent /> {/* Independent loading */}
      </Suspense>
      <Footer /> {/* Renders immediately */}
    </div>
  );
}

async function SlowServerComponent() {
  // Slow database query
  const data = await db.complexQuery(); // Takes 2 seconds
  return <div>{data}</div>;
}
```

**What happens:**

1. Header renders immediately
2. Spinner shows while SlowServerComponent loads
3. Skeleton shows while AnotherSlowComponent loads
4. Footer renders immediately
5. As each completes, it **streams** to the client
6. No JavaScript needed for this behavior!

**Benefits:**

- Progressive rendering
- Faster perceived performance
- Independent loading states
- Automatic with Suspense

---

### 7. Data Fetching Patterns

#### Pattern 1: Parallel Fetching

```javascript
// ‚ùå Waterfall - Slow
async function Page() {
  const user = await fetchUser(); // Wait 100ms
  const posts = await fetchPosts(user.id); // Wait 200ms
  // Total: 300ms sequential
}

// ‚úÖ Parallel - Fast
async function Page() {
  const [user, posts] = await Promise.all([
    fetchUser(), // Both start immediately
    fetchPosts(),
  ]);
  // Total: 200ms (longest of the two)
}
```

#### Pattern 2: Fetching close to where it's used

```javascript
// ‚úÖ Co-location - Each component fetches its own data
async function UserPage({ userId }) {
  return (
    <div>
      <UserProfile userId={userId} />
      <UserPosts userId={userId} />
      <UserComments userId={userId} />
    </div>
  );
}

async function UserProfile({ userId }) {
  const user = await fetchUser(userId);  // Fetches only user data
  return <div>{user.name}</div>;
}

async function UserPosts({ userId }) {
  const posts = await fetchPosts(userId);  // Fetches only posts
  return <ul>{posts.map(...)}</ul>;
}
```

#### Pattern 3: Request Deduplication

**React automatically deduplicates identical requests:**

```javascript
// Both components fetch same data
async function Header() {
  const user = await fetchUser(123); // Request 1
  return <div>{user.name}</div>;
}

async function Sidebar() {
  const user = await fetchUser(123); // Automatically deduplicated!
  return <div>{user.avatar}</div>;
}

// Only ONE actual fetch happens!
// React caches during the render
```

---

### 8. Limitations and Trade-offs

#### What you CAN'T do in Server Components:

```javascript
// ‚ùå No state
const [count, setCount] = useState(0);

// ‚ùå No effects
useEffect(() => {}, []);

// ‚ùå No event handlers
<button onClick={() => {}}>Click</button>;

// ‚ùå No browser APIs
window.localStorage.getItem("key");
document.getElementById("element");

// ‚ùå No Context (in the traditional sense)
const value = useContext(MyContext);
```

#### When you MUST use Client Components:

- ‚úÖ Any interactivity (clicks, hovers, etc.)
- ‚úÖ State management (useState, useReducer)
- ‚úÖ Effects (useEffect, useLayoutEffect)
- ‚úÖ Browser APIs (localStorage, etc.)
- ‚úÖ Event listeners
- ‚úÖ Custom hooks that use client-only hooks
- ‚úÖ React Context consumers

#### The mental model:

> **Server Components**: Data fetching, rendering, static content
>
> **Client Components**: Interactivity, state, browser APIs

**Think of it as:**

- Server Components = "The page structure and data"
- Client Components = "The interactive widgets"

---

### 9. Current Framework Support

#### Next.js 13+ (App Router)

**Status**: ‚úÖ Production-ready

```javascript
// app/page.jsx - Server Component by default
async function Page() {
  const data = await fetchData();
  return <div>{data}</div>;
}

// app/components/ClientButton.jsx
("use client");

export default function ClientButton() {
  return <button onClick={() => alert("Hi!")}>Click</button>;
}
```

**Features:**

- Server Components by default
- File-based routing
- Built-in data fetching
- Streaming SSR
- Full tooling support

#### Other Frameworks

- **Remix**: Exploring RSC integration
- **Gatsby**: Investigating RSC support
- **Hydrogen** (Shopify): Uses RSC patterns
- **Standalone React**: Not yet available

**Current state:**

- Next.js is the primary way to use RSC today
- Other frameworks are adopting
- React team working on framework-agnostic approach

---

### 10. Migration Considerations

**From traditional React to RSC:**

#### Step 1: Identify component types

```javascript
// Analysis questions for each component:

// 1. Does it use state/effects? ‚Üí Client Component
// 2. Does it handle events? ‚Üí Client Component
// 3. Does it fetch data? ‚Üí Server Component
// 4. Is it purely presentational? ‚Üí Server Component
```

#### Step 2: Start from the leaves

```javascript
// ‚úÖ Start with leaf components
// Button.jsx
"use client"; // Has onClick, must be client

export default function Button({ onClick, children }) {
  return <button onClick={onClick}>{children}</button>;
}

// ‚úÖ Parent can be Server Component
// BlogPost.jsx (no 'use client')
import Button from "./Button";

async function BlogPost({ id }) {
  const post = await fetchPost(id);

  return (
    <article>
      <h1>{post.title}</h1>
      <p>{post.content}</p>
      <Button onClick={() => {}}>Like</Button> {/* Works! */}
    </article>
  );
}
```

#### Step 3: Minimize client boundaries

```javascript
// ‚ùå BAD - Entire component is client
"use client";

function BlogPost() {
  const [liked, setLiked] = useState(false);

  return (
    <article>
      <h1>Title</h1>
      <p>Long content...</p>
      <button onClick={() => setLiked(true)}>Like</button>
    </article>
  );
}

// ‚úÖ GOOD - Only button is client
// BlogPost.jsx (Server Component)
import LikeButton from "./LikeButton";

function BlogPost() {
  return (
    <article>
      <h1>Title</h1>
      <p>Long content...</p>
      <LikeButton /> {/* Only this is client */}
    </article>
  );
}

// LikeButton.jsx
("use client");

function LikeButton() {
  const [liked, setLiked] = useState(false);
  return <button onClick={() => setLiked(true)}>Like</button>;
}
```

---

## üé§ Top Interview Questions & Model Answers

### Q1: What are React Server Components and how do they differ from traditional SSR?

**Answer:**

> "React Server Components are components that render exclusively on the server and never send their code to the client. This is different from traditional Server-Side Rendering, where components render on the server to HTML but then hydrate with JavaScript on the client. With RSC, server components have zero JavaScript bundle impact - their code never reaches the browser. They can directly access databases, use Node.js APIs, and import large libraries without affecting client bundle size. Meanwhile, Client Components marked with 'use client' work like traditional React components with full interactivity. The key insight is that you can compose both types together - server components for data fetching and static content, client components for interactivity."

---

### Q2: What are the main benefits of Server Components?

**Answer:**

> "The main benefits are: First, zero bundle size impact - server component code and dependencies never go to the client, dramatically reducing JavaScript bundle sizes. Second, direct backend access - you can query databases, access file systems, and use server-only APIs directly in your components without API routes. Third, automatic code splitting - React handles this automatically without manual lazy loading. Fourth, better security - API keys, business logic, and sensitive operations stay on the server. And fifth, improved performance on low-end devices since less JavaScript needs to be parsed and executed. These benefits make RSC particularly powerful for data-heavy applications."

---

### Q3: What are the limitations of Server Components?

**Answer:**

> "Server Components cannot use any browser-specific or client-side React features. This means no useState, useEffect, or other stateful hooks. They can't have event handlers like onClick. They can't access browser APIs like localStorage or window. They can't use React Context in the traditional way. Essentially, if it requires interactivity or browser capabilities, you need a Client Component. The pattern is to use Server Components for data fetching and static rendering, and strategically place Client Components for interactive elements. It's about composing both types together effectively."

---

### Q4: Can you explain the composition rules between Server and Client Components?

**Answer:**

> "Server Components can import and render Client Components - this works fine. However, Client Components cannot directly import Server Components because client components run in the browser and can't execute server-only code. But there's a workaround: you can pass Server Components as children or props to Client Components. This is called the 'Server Component as props' pattern. The parent Server Component renders both the Client Component and other Server Components, passing the Server Components as children to the Client Component. This way, you can have client-side interactivity wrapping server-side content."

---

### Q5: How do async components work in React Server Components?

**Answer:**

> "Server Components can be async functions, which was never possible before in React. You can use await directly in the component body to fetch data, making the code more intuitive. For example, 'async function UserProfile() { const user = await fetchUser(); return <div>{user.name}</div>; }'. This works seamlessly with Suspense boundaries for streaming and progressive rendering. While the async component is waiting, Suspense shows a fallback, and once the data arrives, it streams to the client. This eliminates the need for useEffect and useState for data fetching in server components."

---

### Q6: Where can you use React Server Components today?

**Answer:**

> "Currently, Next.js 13+ with the App Router is the primary production-ready way to use React Server Components. They're the default in the App Router - any component without 'use client' is a server component. Other frameworks like Remix and Gatsby are exploring integration, and Shopify's Hydrogen uses RSC patterns. The React team is working on making RSC available outside of frameworks, but for now, Next.js is the main path. It's important to note that this is still an evolving feature - while production-ready in Next.js, the broader ecosystem is still catching up."

---

### Q7: How would you approach migrating a traditional React app to use Server Components?

**Answer:**

> "I'd start by analyzing each component to determine if it needs client-side features. Components using state, effects, or event handlers must be Client Components. I'd mark these with 'use client'. Then I'd identify components that just fetch data or render static content - these can be Server Components. The key strategy is to push 'use client' down to the leaves of the component tree, keeping client boundaries as small as possible. For example, instead of making an entire blog post component client-side, I'd extract just the Like button as a Client Component. I'd also leverage the composition pattern - passing Server Components as children to Client Components when needed. And importantly, I'd migrate incrementally, starting with new features or less critical pages to gain experience."

---

### Q8: What performance benefits do Server Components provide?

**Answer:**

> "The performance benefits are substantial. First, reduced JavaScript bundle size leads to faster initial page loads and improved Time to Interactive. Components and their dependencies don't need to be downloaded, parsed, or executed on the client. Second, faster data fetching since server components can access data sources directly without round-trip HTTP requests to API routes. Third, streaming rendering with Suspense allows the page to start rendering immediately while slower components stream in progressively. Fourth, automatic request deduplication means if multiple components fetch the same data, React only makes one request. And fifth, better performance on low-end devices and slow networks since there's less client-side work. These combine to significantly improve Core Web Vitals, especially LCP and TTI."

---

## üîë Key Takeaways

### ‚úÖ Must Know (Critical)

- ‚úÖ Server Components vs Client Components distinction
- ‚úÖ Zero bundle size benefit for server components
- ‚úÖ Must use 'use client' directive for client components
- ‚úÖ Server components can't use hooks, state, or events
- ‚úÖ Async components are possible in server components

### ‚úÖ Should Know (Often asked)

- ‚úÖ Composition rules (Server can import Client, not vice versa)
- ‚úÖ Direct backend access capability
- ‚úÖ Streaming with Suspense integration
- ‚úÖ Next.js App Router as primary implementation
- ‚úÖ When to use each component type

### ‚úÖ Nice to Know (Senior level)

- [ ] Request deduplication mechanism
- [ ] Migration strategies from traditional React
- [ ] Performance implications and measurements
- [ ] Framework adoption status
- [ ] Future of RSC in React ecosystem

---

## üö® Common Mistakes to Avoid

### 1. Marking Everything as 'use client'

```javascript
// ‚ùå BAD - Unnecessary client component
"use client";

function BlogPost({ title, content }) {
  // No state, effects, or events - doesn't need 'use client'!
  return (
    <article>
      <h1>{title}</h1>
      <p>{content}</p>
    </article>
  );
}

// ‚úÖ GOOD - Server Component (default)
function BlogPost({ title, content }) {
  return (
    <article>
      <h1>{title}</h1>
      <p>{content}</p>
    </article>
  );
}
```

### 2. Client Component Importing Server Component

```javascript
// ‚ùå WRONG - Client importing Server
"use client";

import ServerComponent from "./ServerComponent";

function ClientComponent() {
  return <ServerComponent />; // Won't work!
}

// ‚úÖ CORRECT - Use children pattern
// Parent.jsx (Server)
function Parent() {
  return (
    <ClientComponent>
      <ServerComponent /> {/* Pass as children */}
    </ClientComponent>
  );
}
```

### 3. Forgetting Async Data Fetching Benefits

```javascript
// ‚ùå OLD WAY - Still using useEffect in Server Component
function UserProfile({ userId }) {
  const [user, setUser] = useState(null);

  useEffect(() => {
    fetchUser(userId).then(setUser);
  }, [userId]);

  // Can't use useEffect in Server Component anyway!
}

// ‚úÖ NEW WAY - Use async/await
async function UserProfile({ userId }) {
  const user = await fetchUser(userId); // Simple!
  return <div>{user.name}</div>;
}
```

### 4. Creating Large Client Boundaries

```javascript
// ‚ùå BAD - Entire dashboard is client
"use client";

function Dashboard() {
  const [tab, setTab] = useState("home");

  return (
    <div>
      <Header /> {/* Could be server */}
      <Sidebar /> {/* Could be server */}
      <Tabs value={tab} onChange={setTab} /> {/* Needs client */}
      <Content /> {/* Could be server */}
    </div>
  );
}

// ‚úÖ GOOD - Minimal client boundary
function Dashboard() {
  // Server Component
  return (
    <div>
      <Header /> {/* Server */}
      <Sidebar /> {/* Server */}
      <ClientTabs /> {/* Only tabs are client */}
      <Content /> {/* Server */}
    </div>
  );
}
```

### 5. Not Using Suspense for Async Components

```javascript
// ‚ùå Missing Suspense boundary
function Page() {
  return (
    <div>
      <SlowServerComponent /> {/* Blocks entire page */}
    </div>
  );
}

// ‚úÖ GOOD - Suspense for progressive rendering
function Page() {
  return (
    <div>
      <Suspense fallback={<Skeleton />}>
        <SlowServerComponent /> {/* Streams independently */}
      </Suspense>
    </div>
  );
}
```

---

## üí° Pro Tips

### Tip 1: The "use client" Directive Boundary

- Place 'use client' at the **top** of files that need it
- It creates a boundary - everything imported becomes client code
- Keep client boundaries small and at leaf nodes

### Tip 2: Think in Layers

```
Server Layer (Data fetching, business logic)
    ‚Üì
Client Layer (Interactivity)
    ‚Üì
Server Layer (Nested data, static content)
```

You can alternate between layers!

### Tip 3: Server Component Patterns

- **Data Fetching**: Use server components
- **Layout/Structure**: Use server components
- **Static Content**: Use server components
- **Forms (display)**: Server components
- **Forms (interaction)**: Client components

### Tip 4: Debugging

- Check Network tab for RSC payloads
- Look for `.rsc` requests
- Use React DevTools (shows S for Server, C for Client)
- Console.log in server components shows in terminal, not browser!

### Tip 5: Performance Optimization

- Fetch data as close to where it's used as possible
- Use Promise.all() for parallel fetching
- Rely on automatic request deduplication
- Wrap slow components in Suspense

---

## üìö Real-World Example: E-commerce Product Page

```javascript
// app/product/[id]/page.jsx - Server Component
import AddToCartButton from "./AddToCartButton";
import ReviewForm from "./ReviewForm";

async function ProductPage({ params }) {
  // Direct database access
  const [product, reviews, recommendations] = await Promise.all([
    db.products.findById(params.id),
    db.reviews.findByProductId(params.id),
    db.products.findRecommendations(params.id),
  ]);

  return (
    <div>
      {/* Server Components - Static content */}
      <ProductImages images={product.images} />
      <ProductInfo product={product} />

      {/* Client Component - Interactivity */}
      <AddToCartButton productId={product.id} />

      {/* Server Component - More static content */}
      <ProductDescription description={product.description} />

      {/* Server Component with Suspense */}
      <Suspense fallback={<ReviewsSkeleton />}>
        <ReviewList reviews={reviews} />
      </Suspense>

      {/* Client Component - Form */}
      <ReviewForm productId={product.id} />

      {/* Server Component - Recommendations */}
      <Suspense fallback={<Loading />}>
        <Recommendations products={recommendations} />
      </Suspense>
    </div>
  );
}

// AddToCartButton.jsx
("use client");

import { useState } from "react";

export default function AddToCartButton({ productId }) {
  const [isAdding, setIsAdding] = useState(false);

  const handleClick = async () => {
    setIsAdding(true);
    await addToCart(productId);
    setIsAdding(false);
  };

  return (
    <button onClick={handleClick} disabled={isAdding}>
      {isAdding ? "Adding..." : "Add to Cart"}
    </button>
  );
}
```

**What's happening:**

- Product data fetched on server (fast, direct DB access)
- Static content rendered as Server Components (zero bundle cost)
- Interactive elements (button, form) are Client Components
- Slow sections (reviews, recommendations) wrapped in Suspense
- Everything streams progressively for fast perceived performance
- Total JavaScript sent to client: Only the button and form logic!

---

## üéØ Interview Readiness Checklist

- [ ] Can explain Server vs Client Components clearly
- [ ] Understand zero bundle size benefit
- [ ] Know the composition rules
- [ ] Can explain async component pattern
- [ ] Aware of current framework support (Next.js)
- [ ] Understand when to use each type
- [ ] Know the limitations of server components
- [ ] Can discuss performance benefits
- [ ] Understand migration considerations
- [ ] Aware this is an evolving feature

**Final Tip**: Since RSC is still emerging, it's okay to say "I understand the concepts and have followed the development, but I haven't used them in production yet." Show enthusiasm for learning and understanding of the benefits!
