# State Colocation

## üéØ Key Concepts

### 1. What is State Colocation?

**What it means:**

- Keep state as close as possible to where it's used
- Don't lift state up unless multiple components truly need it
- Principle: "State should live at the lowest common ancestor"
- Avoid premature global state

**The Core Principle:**

```javascript
// ‚ùå BAD - State too high in tree
function App() {
  const [modalOpen, setModalOpen] = useState(false);
  const [selectedItem, setSelectedItem] = useState(null);
  const [filterText, setFilterText] = useState("");
  const [sortOrder, setSortOrder] = useState("asc");

  // These are only used in one component!
  // Why are they in App? üò±

  return (
    <div>
      <Header />
      <Sidebar />
      <ProductList
        modalOpen={modalOpen}
        setModalOpen={setModalOpen}
        selectedItem={selectedItem}
        setSelectedItem={setSelectedItem}
        filterText={filterText}
        setFilterText={setFilterText}
        sortOrder={sortOrder}
        setSortOrder={setSortOrder}
      />
      <Footer />
    </div>
  );
}

// ‚úÖ GOOD - State colocated with usage
function App() {
  return (
    <div>
      <Header />
      <Sidebar />
      <ProductList /> {/* Manages its own state */}
      <Footer />
    </div>
  );
}

function ProductList() {
  // State lives here, where it's actually used
  const [modalOpen, setModalOpen] = useState(false);
  const [selectedItem, setSelectedItem] = useState(null);
  const [filterText, setFilterText] = useState("");
  const [sortOrder, setSortOrder] = useState("asc");

  // ... use the state
}
```

**Key Points:**

- State at the top causes unnecessary re-renders
- Makes components less reusable
- Harder to maintain and understand
- Violates single responsibility principle

**Interview Gold:** This is a fundamental React principle that separates junior from senior developers!

---

### 2. The Performance Benefits

**What it means:**

- Colocated state only re-renders the component that owns it
- Prevents unnecessary re-renders up the tree
- Dramatically improves performance in large apps

**The Problem - State Too High:**

```javascript
// ‚ùå BAD - State in App component
function App() {
  const [count, setCount] = useState(0);

  console.log("App rendered"); // Logs on every count change!

  return (
    <div>
      <Header /> {/* Re-renders unnecessarily */}
      <Navigation /> {/* Re-renders unnecessarily */}
      <Sidebar /> {/* Re-renders unnecessarily */}
      <Counter count={count} setCount={setCount} />
      <Footer /> {/* Re-renders unnecessarily */}
    </div>
  );
}

// Every count update re-renders App AND all its children! üò±
```

**The Solution - Colocate State:**

```javascript
// ‚úÖ GOOD - State in Counter component
function App() {
  console.log("App rendered"); // Only renders once!

  return (
    <div>
      <Header /> {/* Never re-renders */}
      <Navigation /> {/* Never re-renders */}
      <Sidebar /> {/* Never re-renders */}
      <Counter /> {/* Only this re-renders */}
      <Footer /> {/* Never re-renders */}
    </div>
  );
}

function Counter() {
  const [count, setCount] = useState(0);

  console.log("Counter rendered"); // Only this logs on count change

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount((c) => c + 1)}>Increment</button>
    </div>
  );
}

// Only Counter re-renders on count change! ‚úì
```

**Performance Impact:**

```javascript
// Measuring the difference
// Bad approach (state in App):
// - App renders: 2ms
// - Header renders: 1ms
// - Nav renders: 1ms
// - Sidebar renders: 3ms
// - Counter renders: 1ms
// - Footer renders: 1ms
// Total: 9ms per count update √ó 100 updates = 900ms! üò±

// Good approach (state colocated):
// - Counter renders: 1ms
// Total: 1ms per count update √ó 100 updates = 100ms ‚úì
```

---

### 3. Knowing When to Lift State Up

**What it means:**

- Only lift state when multiple components ACTUALLY need to share it
- Lift to the lowest common ancestor, not higher
- Consider alternatives before lifting

**Decision Framework:**

```javascript
// ‚ùì Question: Do multiple components need this state?

// Case 1: Only one component needs it
// ‚úÖ Keep state local
function TodoList() {
  const [filter, setFilter] = useState("all");
  // Only TodoList uses filter, keep it here
}

// Case 2: Sibling components need it
// ‚úÖ Lift to common parent
function TodoApp() {
  const [todos, setTodos] = useState([]);
  // Both TodoList and TodoStats need todos
  return (
    <>
      <TodoList todos={todos} setTodos={setTodos} />
      <TodoStats todos={todos} />
    </>
  );
}

// Case 3: Distant components need it
// ü§î Consider alternatives BEFORE lifting
// - Can you pass as prop through intermediate components?
// - Can you use composition (children prop)?
// - Does it truly need to be shared?
// - Last resort: Context API
```

**Lifting State - The Right Way:**

```javascript
// ‚ùå BAD - Lifted too high
function App() {
  const [searchQuery, setSearchQuery] = useState("");

  return (
    <div>
      <Header />
      <MainContent>
        <Sidebar />
        <Products>
          <SearchBar
            searchQuery={searchQuery}
            setSearchQuery={setSearchQuery}
          />
          <ProductList searchQuery={searchQuery} />
        </Products>
      </MainContent>
      <Footer />
    </div>
  );
}
// Lifted to App, but only Products section needs it!

// ‚úÖ GOOD - Lifted to lowest common ancestor
function App() {
  return (
    <div>
      <Header />
      <MainContent>
        <Sidebar />
        <Products /> {/* State lives here */}
      </MainContent>
      <Footer />
    </div>
  );
}

function Products() {
  const [searchQuery, setSearchQuery] = useState("");
  // State at lowest common ancestor of SearchBar and ProductList

  return (
    <>
      <SearchBar searchQuery={searchQuery} setSearchQuery={setSearchQuery} />
      <ProductList searchQuery={searchQuery} />
    </>
  );
}
```

---

### 4. Composition Over State Lifting

**What it means:**

- Use component composition to avoid lifting state
- Pass components as children props
- Invert the ownership relationship

**The Problem:**

```javascript
// ‚ùå Need to lift state just to pass it down
function App() {
  const [theme, setTheme] = useState("light");

  return (
    <Layout theme={theme}>
      <Header theme={theme} />
      <Content theme={theme}>
        <Article theme={theme} />
      </Content>
    </Layout>
  );
}
// theme passed through every level!
```

**Solution 1: Children Prop Pattern**

```javascript
// ‚úÖ GOOD - Use composition
function App() {
  const [theme, setTheme] = useState("light");

  return (
    <Layout>
      <Header />
      <Content>
        <Article theme={theme} /> {/* Only Article needs it */}
      </Content>
    </Layout>
  );
}

// Layout doesn't need theme prop
function Layout({ children }) {
  return <div className="layout">{children}</div>;
}

// Content doesn't need theme prop
function Content({ children }) {
  return <main>{children}</main>;
}
```

**Solution 2: Render Props**

```javascript
// ‚úÖ GOOD - Render prop for more control
function App() {
  const [theme, setTheme] = useState("light");

  return (
    <Layout>
      <Header />
      <Content>{() => <Article theme={theme} />}</Content>
    </Layout>
  );
}

function Content({ children }) {
  // Content can provide additional data if needed
  const contentData = useContentData();
  return <main>{children(contentData)}</main>;
}
```

**Benefits:**

- Fewer props to pass through
- Components more reusable
- State stays local longer
- Better separation of concerns

---

### 5. Common State Lifting Mistakes

**Mistake 1: Premature Global State**

```javascript
// ‚ùå BAD - Making everything global "just in case"
import create from "zustand";

const useStore = create((set) => ({
  modalOpen: false,
  setModalOpen: (open) => set({ modalOpen: open }),

  filterText: "",
  setFilterText: (text) => set({ filterText: text }),

  sortOrder: "asc",
  setSortOrder: (order) => set({ sortOrder: order }),

  // ... 50 more things "just in case we need them globally"
}));

// 99% of these are only used in one component!

// ‚úÖ GOOD - Start local, lift when needed
function ProductList() {
  // Start here, lift IF multiple components need it
  const [filterText, setFilterText] = useState("");
  const [sortOrder, setSortOrder] = useState("asc");
}
```

**Mistake 2: Not Using Derived State**

```javascript
// ‚ùå BAD - Storing derived state
function ProductList() {
  const [products, setProducts] = useState([]);
  const [filteredProducts, setFilteredProducts] = useState([]);
  const [productCount, setProductCount] = useState(0);

  useEffect(() => {
    const filtered = products.filter(/* ... */);
    setFilteredProducts(filtered);
    setProductCount(filtered.length);
  }, [products]);

  // Syncing state is complex and error-prone!
}

// ‚úÖ GOOD - Derive on render
function ProductList() {
  const [products, setProducts] = useState([]);
  const [filterText, setFilterText] = useState("");

  // Derive during render
  const filteredProducts = products.filter((p) => p.name.includes(filterText));
  const productCount = filteredProducts.length;

  // No syncing needed! ‚úì
}
```

**Mistake 3: Lifting State for One-Time Communication**

```javascript
// ‚ùå BAD - Lifting state for callback
function Parent() {
  const [selectedId, setSelectedId] = useState(null);

  return (
    <>
      <List onSelect={setSelectedId} />
      <Details id={selectedId} />
    </>
  );
}

// If Details only needs to know ONCE, use callback!

// ‚úÖ GOOD - Direct callback
function Parent() {
  const handleSelect = (id) => {
    // Handle selection
    fetchDetails(id);
  };

  return <List onSelect={handleSelect} />;
}
```

---

### 6. Real-World Examples

**Example 1: Form State**

```javascript
// ‚ùå BAD - Form state in App
function App() {
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [rememberMe, setRememberMe] = useState(false);

  return (
    <div>
      <Header />
      <LoginForm
        email={email}
        setEmail={setEmail}
        password={password}
        setPassword={setPassword}
        rememberMe={rememberMe}
        setRememberMe={setRememberMe}
      />
      <Footer />
    </div>
  );
}

// ‚úÖ GOOD - Form state colocated
function App() {
  return (
    <div>
      <Header />
      <LoginForm /> {/* Manages its own state */}
      <Footer />
    </div>
  );
}

function LoginForm() {
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [rememberMe, setRememberMe] = useState(false);

  const handleSubmit = async (e) => {
    e.preventDefault();
    await login({ email, password, rememberMe });
  };

  return <form onSubmit={handleSubmit}>{/* form fields */}</form>;
}
```

**Example 2: Modal State**

```javascript
// ‚ùå BAD - Modal state in parent
function Dashboard() {
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [modalData, setModalData] = useState(null);

  return (
    <div>
      <UserList
        onUserClick={(user) => {
          setModalData(user);
          setIsModalOpen(true);
        }}
      />

      <UserModal
        isOpen={isModalOpen}
        onClose={() => setIsModalOpen(false)}
        data={modalData}
      />
    </div>
  );
}

// ‚úÖ GOOD - Modal manages its own state
function Dashboard() {
  return (
    <div>
      <UserList />
    </div>
  );
}

function UserList() {
  const [selectedUser, setSelectedUser] = useState(null);

  return (
    <>
      <ul>
        {users.map((user) => (
          <li onClick={() => setSelectedUser(user)}>{user.name}</li>
        ))}
      </ul>

      {selectedUser && (
        <UserModal user={selectedUser} onClose={() => setSelectedUser(null)} />
      )}
    </>
  );
}
```

**Example 3: Tab State**

```javascript
// ‚ùå BAD - Tab state too high
function App() {
  const [activeTab, setActiveTab] = useState("profile");

  return (
    <div>
      <Header />
      <Sidebar />
      <MainContent>
        <UserDashboard activeTab={activeTab} setActiveTab={setActiveTab} />
      </MainContent>
      <Footer />
    </div>
  );
}

// ‚úÖ GOOD - Tab state in the component with tabs
function App() {
  return (
    <div>
      <Header />
      <Sidebar />
      <MainContent>
        <UserDashboard />
      </MainContent>
      <Footer />
    </div>
  );
}

function UserDashboard() {
  const [activeTab, setActiveTab] = useState("profile");

  return (
    <div>
      <Tabs activeTab={activeTab} onChange={setActiveTab} />
      <TabContent activeTab={activeTab} />
    </div>
  );
}
```

---

### 7. State Colocation Checklist

**Before placing state, ask:**

```javascript
// 1. Which components need this state?
//    - Only one? ‚Üí Keep it local
//    - Multiple siblings? ‚Üí Lift to parent
//    - Many distant? ‚Üí Consider Context/global state

// 2. How often does it change?
//    - Frequently? ‚Üí Keep local if possible
//    - Rarely? ‚Üí Can lift higher if needed

// 3. Is it derived from other state?
//    - Yes? ‚Üí Don't store it, calculate it
//    - No? ‚Üí Store it

// 4. Could composition solve this?
//    - Can I use children prop?
//    - Can I restructure components?

// 5. Will this state be needed elsewhere later?
//    - Maybe? ‚Üí Start local anyway, lift when needed
//    - Definitely? ‚Üí Lift to appropriate level

// 6. Does this make the component less reusable?
//    - Yes? ‚Üí Keep state local
//    - No? ‚Üí Lifting might be okay
```

**The Progressive Approach:**

```javascript
// Step 1: Start local
function Component() {
  const [state, setState] = useState(initial);
  // Keep it here
}

// Step 2: If sibling needs it, lift to parent
function Parent() {
  const [state, setState] = useState(initial);
  return (
    <>
      <ComponentA state={state} />
      <ComponentB setState={setState} />
    </>
  );
}

// Step 3: If many components need it, use composition
function Parent() {
  const [state, setState] = useState(initial);
  return (
    <Layout>
      <ChildrenThatNeedState state={state} setState={setState} />
    </Layout>
  );
}

// Step 4: If that's not enough, use Context
const StateContext = createContext();

function Provider({ children }) {
  const [state, setState] = useState(initial);
  return (
    <StateContext.Provider value={{ state, setState }}>
      {children}
    </StateContext.Provider>
  );
}

// Step 5: Last resort - global state (Redux/Zustand)
const useStore = create((set) => ({
  state: initial,
  setState: (state) => set({ state }),
}));
```

---

## üé§ Top Interview Questions & Model Answers

### Q1: What is state colocation and why is it important?

**Answer:**

> "State colocation means keeping state as close as possible to where it's used. It's important for performance because when state is high in the component tree, every update causes the entire subtree to re-render, including components that don't use that state. By keeping state local, we minimize re-renders and make components more maintainable and reusable. The principle is to start with local state and only lift it when multiple components actually need to share it."

---

### Q2: When should you lift state up?

**Answer:**

> "You should lift state up when multiple components need to share and synchronize that state. The key is to lift it only to the lowest common ancestor of those components, not higher. Before lifting, I consider alternatives like component composition using the children prop, which can avoid the need to lift state. I also ask whether the components truly need to share state or if they could communicate through callbacks instead."

---

### Q3: How does state colocation improve performance?

**Answer:**

> "When state is colocated with its usage, only that component and its children re-render on state changes. If state is lifted too high, every component in the subtree re-renders, even those that don't use that state. For example, if a counter is in the App component, clicking the counter button re-renders the entire app. If the counter manages its own state, only that component re-renders. In a large app, this difference can be dramatic."

**Example to mention:**

```javascript
// Bad: App re-renders on every count change
function App() {
  const [count, setCount] = useState(0);
  return (
    <>
      <Header />
      <Counter count={count} />
    </>
  );
}

// Good: Only Counter re-renders
function Counter() {
  const [count, setCount] = useState(0);
  return <button onClick={() => setCount((c) => c + 1)}>{count}</button>;
}
```

---

### Q4: What's the difference between lifting state and using Context?

**Answer:**

> "Lifting state means moving it to a common parent and passing it through props. Context is for when you need to avoid passing props through many levels of intermediate components. I prefer lifting state when it's only a few levels deep because it's more explicit and easier to follow. I use Context for truly global state like theme or authentication that many distant components need. The key is that lifting state has clear data flow through props, while Context can make data flow less obvious."

---

### Q5: Can you give an example of premature state lifting?

**Answer:**

> "A common example is putting form state in the App component 'just in case' we need it elsewhere. For instance, putting email, password, and form validation state in App when only the LoginForm component uses it. This makes App re-render on every keystroke and couples App to the form's implementation. The form should manage its own state, and only communicate the final result (successful login) to App through a callback."

---

### Q6: How do you decide between local state, lifted state, and global state?

**Answer:**

> "I follow a progressive approach: Start with local state in the component that uses it. If a sibling needs it, lift to the common parent. If that creates too much prop drilling, use component composition with children props. If many distant components need it and it's truly global (like auth or theme), use Context. For complex state or when I need features like DevTools, I use a global state library. The key is starting local and only expanding scope when necessary."

---

## üîë Checklist

### ‚úÖ Must Know (Always asked)

- ‚úÖ What state colocation means
- ‚úÖ Performance benefits of colocated state
- ‚úÖ When to lift state up
- ‚úÖ Lowest common ancestor principle

### ‚úÖ Should Know (Often asked)

- ‚úÖ Composition over state lifting
- ‚úÖ Common state lifting mistakes
- ‚úÖ Progressive state lifting approach
- ‚úÖ Real-world examples (forms, modals, tabs)
- ‚úÖ Decision framework for state placement

### ‚úÖ Nice to Know (Senior level)

- [ ] Architectural patterns for large apps
- [ ] Performance profiling state placement
- [ ] Refactoring strategies
- [ ] Team patterns and conventions

---

## üö® Common Mistakes to Avoid

### 1. Premature Global State

```javascript
// ‚ùå BAD - Everything global "just in case"
const useStore = create((set) => ({
  modalOpen: false,
  filterText: "",
  sortOrder: "asc",
  // ... 50 more things only used in one place
}));

// ‚úÖ GOOD - Start local
function ProductList() {
  const [filterText, setFilterText] = useState("");
  const [sortOrder, setSortOrder] = useState("asc");
  // Lift when needed, not before
}
```

### 2. Lifting Too High

```javascript
// ‚ùå BAD - State in App
function App() {
  const [count, setCount] = useState(0);
  return (
    <Layout>
      <Header />
      <Content>
        <Counter count={count} setCount={setCount} />
      </Content>
    </Layout>
  );
}

// ‚úÖ GOOD - State at lowest common ancestor
function Content() {
  return <Counter />; // Counter manages its own state
}
```

### 3. Not Using Composition

```javascript
// ‚ùå BAD - Prop drilling
function App() {
  const [theme, setTheme] = useState("light");
  return (
    <Layout theme={theme}>
      <Content theme={theme}>
        <Article theme={theme} />
      </Content>
    </Layout>
  );
}

// ‚úÖ GOOD - Composition
function App() {
  const [theme, setTheme] = useState("light");
  return (
    <Layout>
      <Content>
        <Article theme={theme} />
      </Content>
    </Layout>
  );
}
```

### 4. Storing Derived State

```javascript
// ‚ùå BAD - Syncing derived state
const [items, setItems] = useState([]);
const [itemCount, setItemCount] = useState(0);

useEffect(() => {
  setItemCount(items.length);
}, [items]);

// ‚úÖ GOOD - Calculate during render
const [items, setItems] = useState([]);
const itemCount = items.length; // Just derive it!
```

### 5. Over-Engineering State Structure

```javascript
// ‚ùå BAD - Complex state structure "for future needs"
const [state, setState] = useState({
  user: { profile: {}, settings: {} },
  ui: { modals: {}, tooltips: {} },
  data: { products: [], cache: {} },
  // ... massive nested structure
});

// ‚úÖ GOOD - Simple, local state
function Component() {
  const [user, setUser] = useState(null);
  const [products, setProducts] = useState([]);
  // Simple, easy to understand
}
```
