# Context API

## üéØ Key Concepts

### 1. Context Basics - Provider and Consumer Pattern

**What it means:**

- Context provides a way to share data across the component tree without prop drilling
- Consists of three parts: `createContext`, `Provider`, and consumer (via `useContext`)
- Provider makes data available to all descendants

**Why it matters:**

```javascript
// Without Context - Prop Drilling Hell
<App>
  <Header theme={theme} user={user} />
    <Nav theme={theme} user={user} />
      <UserMenu theme={theme} user={user} />
        <Avatar user={user} /> {/* Finally used here! */}
      </UserMenu>
    </Nav>
  </Header>
</App>

// With Context - Clean!
<ThemeContext.Provider value={theme}>
  <UserContext.Provider value={user}>
    <App>
      <Header />
        <Nav />
          <UserMenu />
            <Avatar /> {/* Accesses context directly */}
          </UserMenu>
        </Nav>
      </Header>
    </App>
  </UserContext.Provider>
</ThemeContext.Provider>
```

**Creating and Using Context:**

```javascript
// 1. Create Context
import { createContext, useContext, useState } from "react";

const ThemeContext = createContext(undefined);

// 2. Create Provider Component
export function ThemeProvider({ children }) {
  const [theme, setTheme] = useState("light");

  const value = {
    theme,
    toggleTheme: () =>
      setTheme((prev) => (prev === "light" ? "dark" : "light")),
  };

  return (
    <ThemeContext.Provider value={value}>{children}</ThemeContext.Provider>
  );
}

// 3. Create Custom Hook for Consuming
export function useTheme() {
  const context = useContext(ThemeContext);
  if (context === undefined) {
    throw new Error("useTheme must be used within ThemeProvider");
  }
  return context;
}

// 4. Use in Components
function Button() {
  const { theme, toggleTheme } = useTheme();
  return (
    <button
      onClick={toggleTheme}
      className={theme === "light" ? "btn-light" : "btn-dark"}
    >
      Toggle Theme
    </button>
  );
}
```

**Key Points:**

- Context solves prop drilling problem elegantly
- Provider wraps part of tree that needs access
- Any depth of nesting can access the context
- Must wrap consumers with Provider or get undefined
- Custom hook pattern is best practice for consuming

---

### 2. The Re-render Problem (CRITICAL!)

**What it means:**

- **ALL** components that use a context will re-render when the context value changes
- Even if they only use a small part of the context value
- This is the #1 performance issue with Context API

**The Problem:**

```javascript
// ‚ùå BAD - Causes ALL consumers to re-render
const AppContext = createContext();

function AppProvider({ children }) {
  const [user, setUser] = useState(null);
  const [theme, setTheme] = useState("light");
  const [settings, setSettings] = useState({});

  // Every update to ANY value re-renders ALL consumers!
  const value = { user, setUser, theme, setTheme, settings, setSettings };

  return <AppContext.Provider value={value}>{children}</AppContext.Provider>;
}

function UserName() {
  const { user } = useContext(AppContext);
  // Re-renders when theme changes even though it only uses user! üò±
  return <div>{user?.name}</div>;
}

function ThemeToggle() {
  const { theme, setTheme } = useContext(AppContext);
  // Re-renders when user changes even though it only uses theme! üò±
  return (
    <button
      onClick={() => setTheme((prev) => (prev === "light" ? "dark" : "light"))}
    >
      {theme}
    </button>
  );
}
```

**Why this happens:**

- Context uses reference equality (`Object.is`)
- Creating new object `{ user, theme, settings }` on every render = new reference
- New reference = all consumers re-render
- No way to "subscribe" to just part of context

**Interview Gold:** This is THE critical Context API limitation! You MUST understand this.

---

### 3. Memoizing Context Value

**What it means:**

- Use `useMemo` to prevent creating a new context value object on every render
- Only create new value when dependencies actually change

**The Problem:**

```javascript
// ‚ùå BAD - New object on every AppProvider render
function AppProvider({ children }) {
  const [user, setUser] = useState(null);

  const value = { user, setUser }; // New object every render!

  return <AppContext.Provider value={value}>{children}</AppContext.Provider>;
}
```

**The Solution:**

```javascript
// ‚úÖ GOOD - Memoized value
function AppProvider({ children }) {
  const [user, setUser] = useState(null);

  const value = useMemo(
    () => ({ user, setUser }),
    [user] // Only create new object when user changes
  );

  return <AppContext.Provider value={value}>{children}</AppContext.Provider>;
}
```

**Important Note:**

- This prevents unnecessary re-renders when the Provider itself re-renders
- But when `user` changes, ALL consumers still re-render
- This is optimization for Provider re-renders, not context value changes

**When to memoize:**

- ‚úÖ Always memoize context value objects
- ‚úÖ Include all state and functions in the memoized object
- ‚úÖ List actual dependencies in useMemo array
- ‚úÖ Don't memoize if value is already stable (like a single primitive)

---

### 4. Splitting Contexts (Best Practice)

**What it means:**

- Create separate contexts for different concerns
- Each context only contains related data
- Consumers only re-render when their specific context changes

**The Problem:**

```javascript
// ‚ùå BAD - Single context with everything
const AppContext = createContext();

function AppProvider({ children }) {
  const [user, setUser] = useState(null);
  const [theme, setTheme] = useState("light");
  const [notifications, setNotifications] = useState([]);

  const value = useMemo(
    () => ({ user, setUser, theme, setTheme, notifications, setNotifications }),
    [user, theme, notifications]
  );

  return <AppContext.Provider value={value}>{children}</AppContext.Provider>;
}

// Every component re-renders when ANY value changes! üò±
```

**The Solution:**

```javascript
// ‚úÖ GOOD - Separate contexts
const UserContext = createContext();
const ThemeContext = createContext();
const NotificationContext = createContext();

function UserProvider({ children }) {
  const [user, setUser] = useState(null);
  const value = useMemo(() => ({ user, setUser }), [user]);
  return <UserContext.Provider value={value}>{children}</UserContext.Provider>;
}

function ThemeProvider({ children }) {
  const [theme, setTheme] = useState("light");
  const value = useMemo(() => ({ theme, setTheme }), [theme]);
  return (
    <ThemeContext.Provider value={value}>{children}</ThemeContext.Provider>
  );
}

function NotificationProvider({ children }) {
  const [notifications, setNotifications] = useState([]);
  const value = useMemo(
    () => ({ notifications, setNotifications }),
    [notifications]
  );
  return (
    <NotificationContext.Provider value={value}>
      {children}
    </NotificationContext.Provider>
  );
}

// Compose them
function AppProviders({ children }) {
  return (
    <UserProvider>
      <ThemeProvider>
        <NotificationProvider>{children}</NotificationProvider>
      </ThemeProvider>
    </UserProvider>
  );
}

// Now components only re-render when their context changes! ‚úì
function UserName() {
  const { user } = useContext(UserContext);
  // Only re-renders when user changes
  return <div>{user?.name}</div>;
}

function ThemeToggle() {
  const { theme, setTheme } = useContext(ThemeContext);
  // Only re-renders when theme changes
  return (
    <button
      onClick={() => setTheme((prev) => (prev === "light" ? "dark" : "light"))}
    >
      {theme}
    </button>
  );
}
```

**When to split:**

- ‚úÖ Different update frequencies (user rarely changes, notifications change often)
- ‚úÖ Different consumers (some need user, others need theme)
- ‚úÖ Logically separate concerns
- ‚úÖ Performance critical areas

---

### 5. Separating State and Updater Contexts

**What it means:**

- Split context into two: one for state, one for updaters
- Updaters have stable references (don't change)
- Components that only update state don't re-render

**The Pattern:**

```javascript
// Create two contexts
const ThemeStateContext = createContext();
const ThemeUpdaterContext = createContext();

function ThemeProvider({ children }) {
  const [theme, setTheme] = useState("light");

  // State changes frequently
  const state = useMemo(() => ({ theme }), [theme]);

  // Updaters never change (stable reference)
  const updaters = useMemo(
    () => ({
      toggleTheme: () =>
        setTheme((prev) => (prev === "light" ? "dark" : "light")),
      setTheme,
    }),
    [] // Empty deps - stable reference
  );

  return (
    <ThemeStateContext.Provider value={state}>
      <ThemeUpdaterContext.Provider value={updaters}>
        {children}
      </ThemeUpdaterContext.Provider>
    </ThemeStateContext.Provider>
  );
}

// Custom hooks
export function useThemeState() {
  const context = useContext(ThemeStateContext);
  if (!context) throw new Error("Must be within ThemeProvider");
  return context;
}

export function useThemeUpdater() {
  const context = useContext(ThemeUpdaterContext);
  if (!context) throw new Error("Must be within ThemeProvider");
  return context;
}

// Component that only needs to update theme
function ThemeToggle() {
  const { toggleTheme } = useThemeUpdater();
  // Never re-renders because updaters never change! üéâ
  return <button onClick={toggleTheme}>Toggle</button>;
}

// Component that displays theme
function ThemeDisplay() {
  const { theme } = useThemeState();
  // Only re-renders when theme changes
  return <div>Current theme: {theme}</div>;
}
```

**Benefits:**

- Components that only dispatch actions don't re-render
- Reduces unnecessary re-renders significantly
- Common in complex state management patterns
- Works great with useReducer

---

### 6. Context with useReducer Pattern

**What it means:**

- Combine Context API with useReducer for complex state
- Provides Redux-like pattern without external library
- Predictable state updates through actions

**The Pattern:**

```javascript
// 1. Define reducer
const todoReducer = (state, action) => {
  switch (action.type) {
    case "ADD_TODO":
      return [
        ...state,
        { id: Date.now(), text: action.payload, completed: false },
      ];
    case "TOGGLE_TODO":
      return state.map((todo) =>
        todo.id === action.payload
          ? { ...todo, completed: !todo.completed }
          : todo
      );
    case "DELETE_TODO":
      return state.filter((todo) => todo.id !== action.payload);
    default:
      return state;
  }
};

// 2. Create contexts
const TodoStateContext = createContext();
const TodoDispatchContext = createContext();

// 3. Create provider
function TodoProvider({ children }) {
  const [todos, dispatch] = useReducer(todoReducer, []);

  return (
    <TodoStateContext.Provider value={todos}>
      <TodoDispatchContext.Provider value={dispatch}>
        {children}
      </TodoDispatchContext.Provider>
    </TodoStateContext.Provider>
  );
}

// 4. Custom hooks
export function useTodos() {
  const context = useContext(TodoStateContext);
  if (context === undefined) {
    throw new Error("useTodos must be used within TodoProvider");
  }
  return context;
}

export function useTodoDispatch() {
  const context = useContext(TodoDispatchContext);
  if (context === undefined) {
    throw new Error("useTodoDispatch must be used within TodoProvider");
  }
  return context;
}

// 5. Use in components
function TodoList() {
  const todos = useTodos();
  // Only re-renders when todos change
  return (
    <ul>
      {todos.map((todo) => (
        <TodoItem key={todo.id} todo={todo} />
      ))}
    </ul>
  );
}

function AddTodo() {
  const dispatch = useTodoDispatch();
  const [text, setText] = useState("");

  // Doesn't re-render when todos change because dispatch is stable!
  const handleSubmit = () => {
    dispatch({ type: "ADD_TODO", payload: text });
    setText("");
  };

  return (
    <form onSubmit={handleSubmit}>
      <input value={text} onChange={(e) => setText(e.target.value)} />
      <button type="submit">Add</button>
    </form>
  );
}
```

**Benefits:**

- Complex state logic in one place
- Predictable state updates
- Easy to test (reducers are pure functions)
- dispatch is stable, doesn't cause re-renders
- Great for form state, app state, feature state

---

### 7. When to Use Context

**Use Context when:**

- ‚úÖ Data needed by many components at different nesting levels
- ‚úÖ Avoiding prop drilling is the main goal
- ‚úÖ Data doesn't change frequently (theme, auth, locale)
- ‚úÖ You want simple solution without external dependencies
- ‚úÖ Medium-sized apps with moderate state complexity

**Don't use Context when:**

- ‚ùå Data changes very frequently (every keystroke, mouse move)
- ‚ùå Need partial subscriptions (only render when specific field changes)
- ‚ùå Complex state with many computed values
- ‚ùå Need middleware, DevTools, time-travel debugging
- ‚ùå Large-scale apps with complex state management needs

**Alternatives to consider:**

- **Redux/Redux Toolkit**: Complex apps, DevTools, middleware
- **Zustand**: Simpler API, better performance, partial subscriptions
- **Jotai/Recoil**: Atomic state management, granular updates
- **TanStack Query**: Server state management
- **Local state + props**: Simple cases, don't overuse global state

---

## üé§ Top Interview Questions & Model Answers

### Q1: How does Context API work?

**Answer:**

> "Context API provides a way to pass data through the component tree without manually passing props at every level. You create a context using `createContext`, provide data using a `Provider` component, and consume it in child components using `useContext`. The key thing to understand is that all components consuming a context will re-render whenever the context value changes, which is the main performance consideration."

---

### Q2: What are the performance implications of Context?

**Answer:**

> "The main performance issue with Context is that ALL consumers re-render when the context value changes, even if they only use a small part of it. Context doesn't support partial subscriptions. To optimize this, you should: split contexts by concern, memoize the context value object with useMemo, and consider separating state and updater contexts. For frequently changing data or when you need granular subscriptions, libraries like Zustand or Redux might be better choices."

---

### Q3: How do you optimize Context usage?

**Answer:**

> "I optimize Context in several ways: First, I split contexts so different concerns are separate and components only subscribe to what they need. Second, I always memoize the context value using useMemo to prevent unnecessary re-renders when the provider itself re-renders. Third, for complex state, I separate state and updater contexts so components that only dispatch actions don't re-render. Finally, I use React.memo on components where appropriate and keep state as local as possible before lifting to context."

**Code to mention:**

```javascript
// Split contexts
const UserContext = createContext();
const ThemeContext = createContext();

// Memoize value
const value = useMemo(() => ({ user, setUser }), [user]);

// Separate state and updaters
const StateContext = createContext();
const DispatchContext = createContext();
```

---

### Q4: When should you use Context vs Redux?

**Answer:**

> "I use Context for simpler scenarios: theme, authentication, locale - things that don't change often and are needed across the app. I choose Redux when I need DevTools for debugging, middleware for side effects, complex derived state with selectors, or fine-grained performance control. Redux Toolkit has reduced the boilerplate significantly. For medium complexity, I might use Zustand as a middle ground - it's simpler than Redux but has better performance than Context with its selector pattern."

---

### Q5: Can you explain the re-render behavior of Context?

**Answer:**

> "When a context value changes, React re-renders every component that calls useContext with that context, regardless of which part of the context value they use. This happens because Context uses reference equality (Object.is) to detect changes. If you create a new object like `{ user, theme }` even with the same values, it's a new reference, triggering re-renders. This is why memoization is crucial, and why splitting contexts by concern is a best practice."

---

### Q6: How do you handle errors in Context?

**Answer:**

> "I create a custom hook for consuming context that throws an error if the context is undefined, which happens when you try to use it outside a Provider. This gives clear error messages during development. For example: `if (context === undefined) throw new Error('useAuth must be used within AuthProvider')`. This pattern makes Context usage safer and more explicit."

---

## üîë Checklist

### ‚úÖ Must Know (Always asked)

- ‚úÖ How to create and use Context (createContext, Provider, useContext)
- ‚úÖ The re-render problem and why it happens
- ‚úÖ When to use Context vs other state management
- ‚úÖ Basic optimization: memoizing value

### ‚úÖ Should Know (Often asked)

- ‚úÖ Splitting contexts by concern
- ‚úÖ Separating state and updater contexts
- ‚úÖ Context with useReducer pattern
- ‚úÖ Custom hooks for consuming context
- ‚úÖ Provider composition patterns

### ‚úÖ Nice to Know (Senior level)

- [ ] Performance comparison with other solutions
- [ ] When Context isn't enough
- [ ] Advanced optimization techniques
- [ ] Context in large-scale applications

---

## üö® Common Mistakes to Avoid

### 1. Not Memoizing Context Value

```javascript
// ‚ùå WRONG - New object every render
function Provider({ children }) {
  const [user, setUser] = useState(null);
  return (
    <Context.Provider value={{ user, setUser }}>{children}</Context.Provider>
  );
}

// ‚úÖ CORRECT - Memoized
function Provider({ children }) {
  const [user, setUser] = useState(null);
  const value = useMemo(() => ({ user, setUser }), [user]);
  return <Context.Provider value={value}>{children}</Context.Provider>;
}
```

### 2. Using Single Context for Everything

```javascript
// ‚ùå BAD - Everything in one context
const AppContext = createContext();
// user, theme, settings, notifications all together

// ‚úÖ GOOD - Split by concern
const UserContext = createContext();
const ThemeContext = createContext();
const SettingsContext = createContext();
```

### 3. Not Providing Error Handling

```javascript
// ‚ùå BAD - No error checking
export function useTheme() {
  return useContext(ThemeContext);
}

// ‚úÖ GOOD - Clear error message
export function useTheme() {
  const context = useContext(ThemeContext);
  if (context === undefined) {
    throw new Error("useTheme must be used within ThemeProvider");
  }
  return context;
}
```

### 4. Using Context for Frequently Changing Data

```javascript
// ‚ùå BAD - Updates on every keystroke
function SearchProvider({ children }) {
  const [searchQuery, setSearchQuery] = useState("");
  // All consumers re-render on every keystroke!
  return (
    <SearchContext.Provider value={{ searchQuery, setSearchQuery }}>
      ...
    </SearchContext.Provider>
  );
}

// ‚úÖ BETTER - Keep local, lift only when needed
function SearchBar() {
  const [query, setQuery] = useState("");
  // Local state, no global re-renders
  return <input value={query} onChange={(e) => setQuery(e.target.value)} />;
}
```
