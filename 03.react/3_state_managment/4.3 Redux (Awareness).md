# Redux Toolkit

## ðŸŽ¯ Key Concepts

### 1. Core Redux Principles

**What it means:**

- Redux is a predictable state container for JavaScript applications
- Single source of truth: entire app state lives in one store
- State is read-only: only way to change state is to dispatch an action
- Changes are made with pure reducer functions

**Why it matters:**

```javascript
// Traditional Redux (verbose)
const INCREMENT = "INCREMENT";
const increment = () => ({ type: INCREMENT });
const counterReducer = (state = 0, action) => {
  switch (action.type) {
    case INCREMENT:
      return state + 1;
    default:
      return state;
  }
};

// Redux Toolkit (modern, simplified)
import { createSlice } from "@reduxjs/toolkit";

const counterSlice = createSlice({
  name: "counter",
  initialState: 0,
  reducers: {
    increment: (state) => state + 1, // Direct mutation allowed!
  },
});
```

**Key Points:**

- Redux Toolkit is the official, opinionated way to write Redux
- Reduces boilerplate by 70-80%
- Includes Immer for immutable updates
- Built-in Redux DevTools integration
- Best practices baked in

---

### 2. configureStore (CRITICAL!)

**What it means:**

- Simplified store setup that wraps Redux's `createStore`
- Automatically sets up Redux DevTools
- Adds middleware by default (thunk, serialization checks)
- Combines reducers automatically

**The Old Way:**

```javascript
// âŒ Traditional Redux - Too much boilerplate
import { createStore, applyMiddleware, combineReducers } from "redux";
import thunk from "redux-thunk";
import { composeWithDevTools } from "redux-devtools-extension";

const rootReducer = combineReducers({
  counter: counterReducer,
  user: userReducer,
});

const store = createStore(
  rootReducer,
  composeWithDevTools(applyMiddleware(thunk))
);
```

**The Modern Way:**

```javascript
// âœ… Redux Toolkit - Simple and clean
import { configureStore } from "@reduxjs/toolkit";
import counterReducer from "./counterSlice";
import userReducer from "./userSlice";

const store = configureStore({
  reducer: {
    counter: counterReducer,
    user: userReducer,
  },
});

export default store;
```

**Key Points:**

- One function call replaces 10+ lines of setup code
- DevTools and thunk middleware included automatically
- Type-safe by default with TypeScript
- Development mode checks (mutation detection, serialization)

---

### 3. createSlice (CRITICAL!)

**What it means:**

- Generates action creators and action types automatically
- Allows "mutating" syntax thanks to Immer under the hood
- Combines reducer logic with actions in one place
- Eliminates switch statements and action type constants

**Complete Example:**

```javascript
import { createSlice } from "@reduxjs/toolkit";

const todosSlice = createSlice({
  name: "todos", // Used to generate action types
  initialState: {
    items: [],
    status: "idle",
  },
  reducers: {
    // âœ… "Mutating" syntax - Immer handles immutability
    addTodo: (state, action) => {
      state.items.push(action.payload);
    },

    // âœ… Can also return new state
    removeTodo: (state, action) => {
      return {
        ...state,
        items: state.items.filter((item) => item.id !== action.payload),
      };
    },

    // âœ… Action payload preparation
    addTodoWithId: {
      reducer: (state, action) => {
        state.items.push(action.payload);
      },
      prepare: (text) => ({
        payload: { id: Date.now(), text, completed: false },
      }),
    },
  },
});

// Auto-generated action creators
export const { addTodo, removeTodo, addTodoWithId } = todosSlice.actions;

// Export reducer
export default todosSlice.reducer;
```

**Using in Components:**

```javascript
import { useDispatch, useSelector } from 'react-redux';
import { addTodo } from './todosSlice';

function TodoApp() {
  const dispatch = useDispatch();
  const todos = useSelector(state => state.todos.items);

  const handleAdd = (text) => {
    dispatch(addTodo({ id: Date.now(), text, completed: false }));
  };

  return (/* JSX */);
}
```

**Key Points:**

- Action types generated automatically: `todos/addTodo`, `todos/removeTodo`
- Direct "mutations" are safe - Immer creates immutable updates
- Reduces 50+ lines of traditional Redux to ~15 lines
- prepare callback for complex action payloads

---

### 4. createAsyncThunk (CRITICAL!)

**What it means:**

- Handles async logic (API calls) with automatic action dispatching
- Generates pending/fulfilled/rejected action types
- Integrates seamlessly with `createSlice`
- Replaces manual thunk writing

**Complete Example:**

```javascript
import { createSlice, createAsyncThunk } from "@reduxjs/toolkit";

// âœ… Define async thunk
export const fetchUsers = createAsyncThunk(
  "users/fetch", // Action type prefix
  async (userId, thunkAPI) => {
    // thunkAPI provides: dispatch, getState, rejectWithValue, etc.
    try {
      const response = await fetch(`/api/users/${userId}`);
      return await response.json(); // Becomes fulfilled payload
    } catch (error) {
      return thunkAPI.rejectWithValue(error.message);
    }
  }
);

const usersSlice = createSlice({
  name: "users",
  initialState: {
    entities: [],
    loading: false,
    error: null,
  },
  reducers: {
    // Regular synchronous actions
  },
  extraReducers: (builder) => {
    builder
      // âœ… Handle pending state
      .addCase(fetchUsers.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      // âœ… Handle success
      .addCase(fetchUsers.fulfilled, (state, action) => {
        state.loading = false;
        state.entities.push(action.payload);
      })
      // âœ… Handle failure
      .addCase(fetchUsers.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload;
      });
  },
});

export default usersSlice.reducer;
```

**Using in Components:**

```javascript
import { useEffect } from "react";
import { useDispatch, useSelector } from "react-redux";
import { fetchUsers } from "./usersSlice";

function UserProfile({ userId }) {
  const dispatch = useDispatch();
  const { entities, loading, error } = useSelector((state) => state.users);

  useEffect(() => {
    dispatch(fetchUsers(userId));
  }, [dispatch, userId]);

  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error}</div>;

  return <div>{/* Render user data */}</div>;
}
```

**Key Points:**

- Automatically dispatches: `pending`, `fulfilled`, `rejected` actions
- `thunkAPI` provides access to dispatch, getState, rejectWithValue
- Handles loading and error states cleanly
- Return value becomes `fulfilled` payload
- `rejectWithValue` for custom error handling

---

### 5. useSelector and useDispatch

**What it means:**

- React hooks for accessing Redux store
- `useSelector`: extract data from store
- `useDispatch`: dispatch actions

**Best Practices:**

```javascript
import { useSelector, useDispatch } from "react-redux";
import { increment, decrement } from "./counterSlice";

function Counter() {
  // âœ… GOOD - Selector extracts minimal data
  const count = useSelector((state) => state.counter.value);

  // âŒ BAD - Selects entire slice unnecessarily
  const counter = useSelector((state) => state.counter);

  const dispatch = useDispatch();

  return (
    <>
      <div>{count}</div>
      <button onClick={() => dispatch(increment())}>+</button>
      <button onClick={() => dispatch(decrement())}>-</button>
    </>
  );
}
```

**Selector Performance:**

```javascript
// âœ… GOOD - Memoized selector with createSelector
import { createSelector } from "@reduxjs/toolkit";

const selectTodos = (state) => state.todos.items;
const selectFilter = (state) => state.todos.filter;

const selectFilteredTodos = createSelector(
  [selectTodos, selectFilter],
  (todos, filter) => {
    // Expensive computation only runs when todos or filter changes
    return todos.filter(
      (todo) =>
        filter === "all" ||
        (filter === "completed" && todo.completed) ||
        (filter === "active" && !todo.completed)
    );
  }
);

// Use in component
const filteredTodos = useSelector(selectFilteredTodos);
```

**Key Points:**

- `useSelector` uses strict equality (===) by default
- Select minimal data to avoid unnecessary re-renders
- Use `createSelector` for derived/computed state
- `useDispatch` returns stable dispatch function

---

### 6. Entity Adapter (Advanced Pattern)

**What it means:**

- Prebuilt reducers and selectors for normalized state
- Manages collections of items efficiently
- Provides CRUD operations out of the box
- Generates memoized selectors automatically

**Complete Example:**

```javascript
import { createSlice, createEntityAdapter } from "@reduxjs/toolkit";

// âœ… Create entity adapter
const usersAdapter = createEntityAdapter({
  selectId: (user) => user.userId, // Default is 'id'
  sortComparer: (a, b) => a.name.localeCompare(b.name), // Optional sorting
});

const usersSlice = createSlice({
  name: "users",
  initialState: usersAdapter.getInitialState({
    loading: false,
    error: null,
  }),
  reducers: {
    // âœ… Adapter provides CRUD methods
    userAdded: usersAdapter.addOne,
    usersReceived: usersAdapter.setAll,
    userUpdated: usersAdapter.updateOne,
    userRemoved: usersAdapter.removeOne,
  },
});

// âœ… Generated selectors
export const {
  selectAll: selectAllUsers,
  selectById: selectUserById,
  selectIds: selectUserIds,
} = usersAdapter.getSelectors((state) => state.users);

// Use in component
const users = useSelector(selectAllUsers);
const user = useSelector((state) => selectUserById(state, userId));
```

**Key Points:**

- Normalizes data: `{ ids: [], entities: {} }`
- Provides: `addOne`, `addMany`, `setAll`, `updateOne`, `removeOne`, etc.
- Auto-generates optimized selectors
- Great for lists of items (users, posts, products)

---

### 7. RTK Query (Bonus - Powerful!)

**What it means:**

- Data fetching and caching library built into Redux Toolkit
- Eliminates need for createAsyncThunk for API calls
- Automatic caching, invalidation, and refetching
- Generates hooks automatically

**Quick Example:**

```javascript
import { createApi, fetchBaseQuery } from "@reduxjs/toolkit/query/react";

// âœ… Define API slice
export const api = createApi({
  reducerPath: "api",
  baseQuery: fetchBaseQuery({ baseUrl: "/api" }),
  endpoints: (builder) => ({
    getUsers: builder.query({
      query: () => "users",
    }),
    addUser: builder.mutation({
      query: (user) => ({
        url: "users",
        method: "POST",
        body: user,
      }),
    }),
  }),
});

// âœ… Auto-generated hooks
export const { useGetUsersQuery, useAddUserMutation } = api;

// Use in component
function Users() {
  const { data, error, isLoading } = useGetUsersQuery();
  const [addUser] = useAddUserMutation();

  if (isLoading) return <div>Loading...</div>;
  if (error) return <div>Error!</div>;

  return <div>{/* Render users */}</div>;
}
```

---

## ðŸŽ¤ Top Interview Questions & Model Answers

### Q1: What is Redux Toolkit and why was it created?

**Answer:**

> "Redux Toolkit is the official, opinionated toolset for efficient Redux development. It was created to address three main pain points with traditional Redux: too much boilerplate code, complex store setup, and requiring too many packages. RTK includes utilities like `configureStore`, `createSlice`, and `createAsyncThunk` that reduce boilerplate by 70-80%. It also includes Immer, so you can write 'mutating' logic that's actually immutable under the hood, and has Redux DevTools built-in by default."

---

### Q2: How does createSlice simplify Redux code?

**Answer:**

> "`createSlice` combines action creators, action types, and reducers into a single function call. Instead of defining separate action type constants, action creator functions, and a reducer with a switch statementâ€”which could be 50+ lines of codeâ€”you write a single object with your reducer logic and RTK generates everything automatically. For example, if you have a reducer called `increment`, RTK automatically creates an action creator `increment()` and action type `counter/increment`. It also uses Immer internally, so you can write state.count++ instead of return {...state, count: state.count + 1}."

**Show code:**

```javascript
// Old way: 50+ lines
// New way with createSlice: ~15 lines, same functionality
```

---

### Q3: What is createAsyncThunk and when do you use it?

**Answer:**

> "`createAsyncThunk` is Redux Toolkit's solution for handling async operations like API calls. It automatically generates and dispatches three actions: pending when the async operation starts, fulfilled when it succeeds, and rejected when it fails. You define the async logic once, and RTK handles all the action dispatching and type generation. In your slice, you use `extraReducers` to handle these three lifecycle actions and update your loading states, data, and errors accordingly. Before RTK, you'd have to manually dispatch these actions and write all the boilerplate yourself."

---

### Q4: What's the difference between reducers and extraReducers in createSlice?

**Answer:**

> "`reducers` defines actions that belong to this specific slice and generates action creators for them. `extraReducers` handles actions that were defined elsewhereâ€”like actions from `createAsyncThunk` or actions from other slices. You use `extraReducers` when you need to respond to actions that you don't own. For example, if you have a `fetchUsers` async thunk, you'd handle its pending/fulfilled/rejected actions in `extraReducers` because those actions are generated by the thunk, not by the slice itself."

---

### Q5: How do you handle side effects in Redux Toolkit?

**Answer:**

> "Redux Toolkit includes Redux Thunk middleware by default, which is enabled automatically in `configureStore`. For most async operations like API calls, I use `createAsyncThunk` which generates a thunk function that I can dispatch. The thunk function receives `thunkAPI` as a second parameter, giving access to `dispatch`, `getState`, and `rejectWithValue` for error handling. For more complex side effects or when I need to listen for multiple actions, I might use Redux Toolkit's listener middleware or RTK Query for data fetching specifically."

---

### Q6: When should you use Redux Toolkit vs Context API?

**Answer:**

> "I use Context API for simple, localized state that doesn't change frequentlyâ€”like theme, user preferences, or authentication state. I choose Redux Toolkit when I need: (1) complex state logic with many actions, (2) state that's shared across many unrelated components, (3) time-travel debugging with Redux DevTools, (4) powerful middleware like async thunks, or (5) consistent, predictable state updates. Redux's centralized store also makes testing easier. RTK Query specifically shines when you have lots of API endpoints, as it handles caching and invalidation automatically."

---

### Q7: What is the Entity Adapter pattern?

**Answer:**

> "The Entity Adapter is Redux Toolkit's solution for managing normalized collections of data. It automatically structures your state as `{ ids: [], entities: {} }` and provides prebuilt reducers like `addOne`, `updateOne`, `removeOne`, and `setAll`. It also generates optimized, memoized selectors like `selectAll`, `selectById`, and `selectIds`. This pattern is perfect for managing lists of items like users, posts, or products. Without it, you'd have to write all this normalization and CRUD logic yourself, which is error-prone and repetitive."

---

## ðŸ”‘ Must Know Checklist

### âœ… Must Know (Critical)

- âœ… What Redux Toolkit is and why it exists
- âœ… `configureStore` for store setup
- âœ… `createSlice` for reducers and actions
- âœ… `createAsyncThunk` for async operations
- âœ… `useSelector` and `useDispatch` hooks
- âœ… Immer integration ("mutable" updates)
- âœ… When to use Redux vs Context API

### âœ… Should Know (Important)

- âœ… `extraReducers` for handling external actions
- âœ… Entity Adapter for normalized data
- âœ… `createSelector` for memoized selectors
- âœ… Redux DevTools integration
- âœ… Error handling patterns
- âœ… TypeScript integration

### âœ… Nice to Know (Senior level)

- [ ] RTK Query for data fetching
- [ ] Listener middleware for complex side effects
- [ ] Performance optimization patterns
- [ ] Testing Redux Toolkit code
- [ ] Migration from old Redux

---

## ðŸš¨ Common Mistakes to Avoid

### 1. Forgetting extraReducers for Async Thunks

```javascript
// âŒ WRONG - Async actions won't be handled
createSlice({
  reducers: {
    // Can't handle fetchUsers.pending/fulfilled/rejected here!
  },
});

// âœ… CORRECT - Use extraReducers
createSlice({
  extraReducers: (builder) => {
    builder.addCase(fetchUsers.fulfilled, (state, action) => {
      state.data = action.payload;
    });
  },
});
```

### 2. Selecting Too Much State

```javascript
// âŒ BAD - Component re-renders when ANY user property changes
const users = useSelector((state) => state.users);

// âœ… GOOD - Only re-renders when needed data changes
const userNames = useSelector((state) =>
  state.users.entities.map((u) => u.name)
);
```

### 3. Not Using Prepare Callback

```javascript
// âŒ BAD - ID generation in component
dispatch(addTodo({ id: Date.now(), text }));

// âœ… GOOD - ID generation in slice
addTodo: {
  reducer: (state, action) => {
    state.items.push(action.payload);
  },
  prepare: (text) => ({
    payload: { id: Date.now(), text }
  })
}
```

### 4. Returning State from "Mutable" Updates

```javascript
// âŒ WRONG - Don't mix mutation and return
addTodo: (state, action) => {
  state.items.push(action.payload);
  return state; // Unnecessary and wrong!
};

// âœ… CORRECT - Either mutate OR return, not both
addTodo: (state, action) => {
  state.items.push(action.payload); // Just mutate
};
```
